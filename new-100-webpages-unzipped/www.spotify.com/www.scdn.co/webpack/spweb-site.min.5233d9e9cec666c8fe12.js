! function(n) {
    var e = {};

    function t(i) {
        if (e[i]) return e[i].exports;
        var s = e[i] = {
            i: i,
            l: !1,
            exports: {}
        };
        return n[i].call(s.exports, s, s.exports, t), s.l = !0, s.exports
    }
    t.m = n, t.c = e, t.d = function(n, e, i) {
        t.o(n, e) || Object.defineProperty(n, e, {
            enumerable: !0,
            get: i
        })
    }, t.r = function(n) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(n, Symbol.toStringTag, {
            value: "Module"
        }), Object.defineProperty(n, "__esModule", {
            value: !0
        })
    }, t.t = function(n, e) {
        if (1 & e && (n = t(n)), 8 & e) return n;
        if (4 & e && "object" == typeof n && n && n.__esModule) return n;
        var i = Object.create(null);
        if (t.r(i), Object.defineProperty(i, "default", {
                enumerable: !0,
                value: n
            }), 2 & e && "string" != typeof n)
            for (var s in n) t.d(i, s, function(e) {
                return n[e]
            }.bind(null, s));
        return i
    }, t.n = function(n) {
        var e = n && n.__esModule ? function() {
            return n.default
        } : function() {
            return n
        };
        return t.d(e, "a", e), e
    }, t.o = function(n, e) {
        return Object.prototype.hasOwnProperty.call(n, e)
    }, t.p = "/webpack/", t(t.s = 808)
}({
    0: function(n, e) {
        n.exports = function(n) {
            function e(n) {
                "undefined" != typeof console && (console.error || console.log)("[Script Loader]", n)
            }
            try {
                "undefined" != typeof execScript && "undefined" != typeof attachEvent && "undefined" == typeof addEventListener ? execScript(n) : "undefined" != typeof eval ? eval.call(null, n) : e("EvalError: No eval function available")
            } catch (n) {
                e(n)
            }
        }
    },
    133: function(n, e, t) {
        "use strict";
        t(0)(t(134))
    },
    134: function(n, e) {
        n.exports = "/** Globals PubSub */\n\nspweb.analytics = (function(globals, pubSub, cookie) {\n  /**\n   * Manages Google Analytics\n   * @module spweb/analytics\n   * @requires Global\n   * @requires pubSub\n   */\n\n  /*\n   Google Analytics custom variable slots (50 slots available):\n   1 Cached (page)\n   2 User Type (session)\n   3 Product (session)\n   4 ??\n   5 Market (page)\n   6 utm_source (session)\n   7 utm_medium (session)\n   8 utm_campaign (session)\n   */\n\n  'use strict';\n\n  var exports = {},\n    _enableGaEvents;\n\n  globals.dataLayer = globals.dataLayer || [];\n\n  _enableGaEvents = function() {\n    var gaCategories = document.querySelectorAll('[data-ga-category]');\n\n    function sendGaEvent(e) {\n      var category = e.target.getAttribute('data-ga-category') || '';\n      var action = e.target.getAttribute('data-ga-action') || '';\n      var label = e.target.getAttribute('data-ga-label') || '';\n\n      if (category && action) {\n        exports.sendEvent(\n          category,\n          action,\n          label\n        );\n      }\n    }\n\n    for (var i = 0; i < gaCategories.length; i++) {\n      gaCategories[i].addEventListener(\"click\", sendGaEvent);\n    }\n\n    pubSub.subscribe('login_username_success', function() {\n      globals.dataLayer.push({'event': 'login_username_success'});\n    });\n\n    pubSub.subscribe('login_facebook_success', function() {\n      globals.dataLayer.push({'event': 'login_facebook_success'});\n    });\n\n    if (cookie.get('sp_fblt')) {\n      pubSub.publish('login_facebook_success');\n      cookie.remove('sp_fblt');\n    }\n  };\n\n  exports.getTest = function(testId){\n    var rawCookie, unescapedCookie, decodedJson, value;\n    rawCookie = cookie.get('sp_ab');\n    if (!rawCookie) {\n      return \"\";\n    }\n    unescapedCookie = unescape(rawCookie);\n    try {\n      decodedJson = JSON.parse(unescapedCookie);\n    } catch (err) {\n      return \"\";\n    }\n    if (!decodedJson) {\n      return \"\";\n    }\n    value = decodedJson[testId];\n    if (!value) {\n      return \"\";\n    }\n    return value;\n  };\n\n  /**\n   * Module set up:\n   * Initialize global ga variable\n   * Bind handlers for tracking Google Event tagged elements;\n   */\n  exports.init = function(){\n    if (globals.hasOwnProperty('dataLayer')) {\n      _enableGaEvents();\n    }\n  };\n\n  /**\n   * @deprecated use the sendEvent method below for Universal Analytics support\n   * @param {String} category\n   * @param {String} action\n   * @param {String} [label]\n   */\n  exports.trackEvent = function(category, action, label) {\n    this.sendEvent(category, action, label);\n  };\n\n  /**\n   * Wrapper around spAnalytics.logEvent api; send event data to GA and internal backend\n   * @param {String} category\n   * @param {String} action\n   * @param {String} [label]\n   * @param {Object} [context] arbitrary event data to be tracked\n   */\n  exports.sendEvent = function(category, action, label, context) {\n    if (typeof category !== 'string' || typeof action !== 'string') {\n      return;\n    }\n\n    // double tracking to compare old ga event logging against new backend architecture (via spAnalytics)\n    // that should be logging the same things. @jasonsmith to remove\n    globals.dataLayer.push({\n      'event': 'GAEvent',\n      'eventCategory': category,\n      'eventAction': action,\n      'eventLabel': label,\n      'eventValue': context\n    });\n    globals.spAnalytics.logEvent(category, action, label, context);\n  };\n\n  /**\n   * Push offer impression information into the dataLayer\n   * @param typesString\n   * @param campaignsString\n   * @param placementsString\n   * @param displayOrdersString\n   */\n  exports.pushOfferImpressions = function(typesString, campaignsString,\n    placementsString, displayOrdersString) {\n\n    var types = typesString.split(\",\");\n    var campaigns = campaignsString.split(\",\");\n    var placements = placementsString.split(\",\");\n    var displayOrders = displayOrdersString.split(\",\");\n\n    var offer_impressions = types.map(function (type, index) {\n      return {\n        'name': type,\n        'variant': campaigns[index],\n        'list': placements[index],\n        'position': displayOrders[index]\n      };\n    });\n\n    globals.dataLayer.push({\n      'ecommerce': {\n        'currencyCode': '', // Local currency is optional.\n        'impressions': offer_impressions\n      }\n    });\n  };\n\n  /**\n   * Push an \"in view\" event to the data layer\n   * @param trackingObject\n   */\n  function pushOfferInView(trackingObject) {\n    globals.dataLayer.push({\n      'event': 'productView',\n      'ecommerce': {\n        'promoView': {\n          'promotions': [trackingObject]\n        }\n      }\n    });\n  }\n\n  /**\n   * Push a click event to the data layer\n   * @param trackingObject\n   */\n  function pushOfferClick(trackingObject) {\n    globals.dataLayer.push({\n      'event': 'productClick',\n      'ecommerce': {\n        'click': {\n          'products': [trackingObject]\n        }\n      }\n    });\n  }\n\n  var seenCTAs = new Set();\n\n  function isElementInViewport (el) {\n    var rect = el.getBoundingClientRect();\n    return rect.top >= 0 &&\n      rect.left >= 0 &&\n      rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&\n      rect.right <= (window.innerWidth || document.documentElement.clientWidth);\n  }\n\n  function parseEventParameters(anchor) {\n    var eventParams = anchor.getAttribute('data-event-params');\n    if (!eventParams) return null;\n    try {\n      var trackingInfo = JSON.parse(eventParams);\n      return {\n        'country_code': trackingInfo[0],\n        'variant': trackingInfo[1],\n        'name': trackingInfo[3],\n        'list': trackingInfo[4],\n        'position': trackingInfo[5],\n        'href': anchor.getAttribute('href')\n      };\n    } catch (e) {\n      return null;\n    }\n  }\n\n  /**\n   * Set up the Enhanced e-commerce tracking for CampaignCallToActionClick\n   */\n  exports.setupPromotionsTracking = function(gaboEventEndpoint) {\n    var anchors = globals.document.links;\n    spweb.gaboEventTracker.init(gaboEventEndpoint);\n\n    function inViewCallback(anchor, trackingObject) {\n      return function () {\n        if (!seenCTAs.has(trackingObject) && isElementInViewport(anchor)) {\n          seenCTAs.add(trackingObject);\n          pushOfferInView(trackingObject);\n          spweb.gaboEventTracker.trackEvent(\n            'PromotionInViewport',\n            1,\n            [trackingObject.country_code,\n             trackingObject.variant,\n             trackingObject.list,\n             trackingObject.position,\n             trackingObject.name,\n             'prodCatId']\n          );\n        }\n      }\n    }\n\n    function clickCallback(trackingObject){\n      return function () {\n        pushOfferClick(trackingObject)\n      }\n    }\n\n    for (var i = 0; i < anchors.length; ++i){\n      var anchor = anchors[i];\n      if (anchor.getAttribute('data-event-name') === \"CampaignCallToActionClick\" &&\n          anchor.getAttribute('data-event-version') === \"2\"){\n\n        // If there's no 'data-event-params' or it's not in the format we expect it\n        // to be we skip to the next element\n        var trackingObject = parseEventParameters(anchor);\n        if (trackingObject === null) continue;\n\n        spweb.gaboEventTracker.trackEvent(\n          'CampaignLandingPageView',\n          2,\n          [trackingObject.country_code,\n           trackingObject.variant,\n           trackingObject.list,\n           trackingObject.position,\n           trackingObject.name,\n           'prodCatId']\n        );\n\n        (function(anchor, trackingObject) {\n          inViewCallback(anchor, trackingObject)();\n\n          window.addEventListener('resize', function() {\n            inViewCallback(anchor, trackingObject)();\n          });\n\n          window.addEventListener('scroll', function() {\n            inViewCallback(anchor, trackingObject)();\n          });\n        })(anchor, trackingObject);\n\n        if (anchor.addEventListener){\n          anchor.addEventListener(\"click\", clickCallback(trackingObject));\n        } else if (anchor.attachEvent){\n          anchor.attachEvent(\"onclick\", clickCallback(trackingObject));\n        }\n      }\n    }\n  };\n\n  /**\n   * Send an event to GTM\n   * Optional eventType tells GTM how to handle the event\n   *\n   * @param {obj} opts\n   * @param {string} eventType use to instruct GTM what kind of event this is (GAEvent by default)\n   * @param {Object} [context] arbitrary event data to be tracked\n   */\n  exports.sendGtmEvent = function(opts, eventType) {\n\n    if (typeof opts.category !== 'string' || typeof opts.action !== 'string') {\n      return;\n    }\n\n    globals.dataLayer.push({\n      'event' :  eventType || 'GAEvent',\n      'eventCategory' : opts.category,\n      'eventAction' : opts.action,\n      'eventLabel' : opts.label,\n      'eventValue' : opts.value,\n      'eventCallback': opts.callback,\n      'ecommerce' : opts.ecommerce\n    });\n  };\n\n  return exports;\n\n}(typeof global !== 'undefined' ? global : window, PubSub, spweb.cookie));\n"
    },
    158: function(n, e, t) {
        t(0)(t(159))
    },
    159: function(n, e) {
        n.exports = "/**\n * Copyright (c) 2010,2011,2012,2013,2014 Morgan Roderick http://roderick.dk\n * License: MIT - http://mrgnrdrck.mit-license.org\n *\n * https://github.com/mroderick/PubSubJS\n */\n\n(function (root, factory){\n    'use strict';\n\n    var PubSub = {};\n    root.PubSub = PubSub;\n\n    var define = root.define;\n\n    factory(PubSub);\n\n    // AMD support\n    if (typeof define === 'function' && define.amd){\n        define(function() { return PubSub; });\n\n        // CommonJS and Node.js module support\n    } else if (typeof exports === 'object'){\n        if (module !== undefined && module.exports) {\n            exports = module.exports = PubSub; // Node.js specific `module.exports`\n        }\n        exports.PubSub = PubSub; // CommonJS module 1.1.1 spec\n        module.exports = exports = PubSub; // CommonJS\n    }\n\n}(( typeof window === 'object' && window ) || this, function (PubSub){\n    'use strict';\n\n    var messages = {},\n        lastUid = -1;\n\n    function hasKeys(obj){\n        var key;\n\n        for (key in obj){\n            if ( obj.hasOwnProperty(key) ){\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns a function that throws the passed exception, for use as argument for setTimeout\n     * @alias throwException\n     * @function\n     * @param { Object } ex An Error object\n     */\n    function throwException( ex ){\n        return function reThrowException(){\n            throw ex;\n        };\n    }\n\n    function callSubscriberWithDelayedExceptions( subscriber, message, data ){\n        try {\n            subscriber( message, data );\n        } catch( ex ){\n            setTimeout( throwException( ex ), 0);\n        }\n    }\n\n    function callSubscriberWithImmediateExceptions( subscriber, message, data ){\n        subscriber( message, data );\n    }\n\n    function deliverMessage( originalMessage, matchedMessage, data, immediateExceptions ){\n        var subscribers = messages[matchedMessage],\n            callSubscriber = immediateExceptions ? callSubscriberWithImmediateExceptions : callSubscriberWithDelayedExceptions,\n            s;\n\n        if ( !messages.hasOwnProperty( matchedMessage ) ) {\n            return;\n        }\n\n        for (s in subscribers){\n            if ( subscribers.hasOwnProperty(s)){\n                callSubscriber( subscribers[s], originalMessage, data );\n            }\n        }\n    }\n\n    function createDeliveryFunction( message, data, immediateExceptions ){\n        return function deliverNamespaced(){\n            var topic = String( message ),\n                position = topic.lastIndexOf( '.' );\n\n            // deliver the message as it is now\n            deliverMessage(message, message, data, immediateExceptions);\n\n            // trim the hierarchy and deliver message to each level\n            while( position !== -1 ){\n                topic = topic.substr( 0, position );\n                position = topic.lastIndexOf('.');\n                deliverMessage( message, topic, data, immediateExceptions );\n            }\n        };\n    }\n\n    function messageHasSubscribers( message ){\n        var topic = String( message ),\n            found = Boolean(messages.hasOwnProperty( topic ) && hasKeys(messages[topic])),\n            position = topic.lastIndexOf( '.' );\n\n        while ( !found && position !== -1 ){\n            topic = topic.substr( 0, position );\n            position = topic.lastIndexOf( '.' );\n            found = Boolean(messages.hasOwnProperty( topic ) && hasKeys(messages[topic]));\n        }\n\n        return found;\n    }\n\n    function publish( message, data, sync, immediateExceptions ){\n        message = (typeof message === 'symbol') ? message.toString() : message;\n\n        var deliver = createDeliveryFunction( message, data, immediateExceptions ),\n            hasSubscribers = messageHasSubscribers( message );\n\n        if ( !hasSubscribers ){\n            return false;\n        }\n\n        if ( sync === true ){\n            deliver();\n        } else {\n            setTimeout( deliver, 0 );\n        }\n        return true;\n    }\n\n    /**\n     * Publishes the message, passing the data to it's subscribers\n     * @function\n     * @alias publish\n     * @param { String } message The message to publish\n     * @param {} data The data to pass to subscribers\n     * @return { Boolean }\n     */\n    PubSub.publish = function( message, data ){\n        return publish( message, data, false, PubSub.immediateExceptions );\n    };\n\n    /**\n     * Publishes the the message synchronously, passing the data to it's subscribers\n     * @function\n     * @alias publishSync\n     * @param { String } message The message to publish\n     * @param {} data The data to pass to subscribers\n     * @return { Boolean }\n     */\n    PubSub.publishSync = function( message, data ){\n        return publish( message, data, true, PubSub.immediateExceptions );\n    };\n\n    /**\n     * Subscribes the passed function to the passed message. Every returned token is unique and should be stored if you need to unsubscribe\n     * @function\n     * @alias subscribe\n     * @param { String } message The message to subscribe to\n     * @param { Function } func The function to call when a new message is published\n     * @return { String }\n     */\n    PubSub.subscribe = function( message, func ){\n        if ( typeof func !== 'function'){\n            return false;\n        }\n\n        message = (typeof message === 'symbol') ? message.toString() : message;\n\n        // message is not registered yet\n        if ( !messages.hasOwnProperty( message ) ){\n            messages[message] = {};\n        }\n\n        // forcing token as String, to allow for future expansions without breaking usage\n        // and allow for easy use as key names for the 'messages' object\n        var token = 'uid_' + String(++lastUid);\n        messages[message][token] = func;\n        \n        // return token for unsubscribing\n        return token;\n    };\n\n    /**\n     * Subscribes the passed function to the passed message once\n     * @function\n     * @alias subscribeOnce\n     * @param { String } message The message to subscribe to\n     * @param { Function } func The function to call when a new message is published\n     * @return { PubSub }\n     */\n    PubSub.subscribeOnce = function( message, func ){\n        var token = PubSub.subscribe( message, function(){\n            // before func apply, unsubscribe message\n            PubSub.unsubscribe( token );\n            func.apply( this, arguments );\n        });\n        return PubSub;\n    };\n\n    /**\n     * Clears all subscriptions\n     * @function\n     * @public\n     * @alias clearAllSubscriptions\n     */\n    PubSub.clearAllSubscriptions = function clearAllSubscriptions(){\n        messages = {};\n    };\n\n    /**\n     * Clear subscriptions by the topic\n     * @function\n     * @public\n     * @alias clearAllSubscriptions\n     */\n    PubSub.clearSubscriptions = function clearSubscriptions(topic){\n        var m;\n        for (m in messages){\n            if (messages.hasOwnProperty(m) && m.indexOf(topic) === 0){\n                delete messages[m];\n            }\n        }\n    };\n\n    /**\n     * Removes subscriptions\n     *\n     * - When passed a token, removes a specific subscription.\n     *\n\t * - When passed a function, removes all subscriptions for that function\n     *\n\t * - When passed a topic, removes all subscriptions for that topic (hierarchy)\n     * @function\n     * @public\n     * @alias subscribeOnce\n     * @param { String | Function } value A token, function or topic to unsubscribe from\n     * @example // Unsubscribing with a token\n     * var token = PubSub.subscribe('mytopic', myFunc);\n     * PubSub.unsubscribe(token);\n     * @example // Unsubscribing with a function\n     * PubSub.unsubscribe(myFunc);\n     * @example // Unsubscribing from a topic\n     * PubSub.unsubscribe('mytopic');\n     */\n    PubSub.unsubscribe = function(value){\n        var descendantTopicExists = function(topic) {\n                var m;\n                for ( m in messages ){\n                    if ( messages.hasOwnProperty(m) && m.indexOf(topic) === 0 ){\n                        // a descendant of the topic exists:\n                        return true;\n                    }\n                }\n\n                return false;\n            },\n            isTopic    = typeof value === 'string' && ( messages.hasOwnProperty(value) || descendantTopicExists(value) ),\n            isToken    = !isTopic && typeof value === 'string',\n            isFunction = typeof value === 'function',\n            result = false,\n            m, message, t;\n\n        if (isTopic){\n            PubSub.clearSubscriptions(value);\n            return;\n        }\n\n        for ( m in messages ){\n            if ( messages.hasOwnProperty( m ) ){\n                message = messages[m];\n\n                if ( isToken && message[value] ){\n                    delete message[value];\n                    result = value;\n                    // tokens are unique, so we can just stop here\n                    break;\n                }\n\n                if (isFunction) {\n                    for ( t in message ){\n                        if (message.hasOwnProperty(t) && message[t] === value){\n                            delete message[t];\n                            result = true;\n                        }\n                    }\n                }\n            }\n        }\n\n        return result;\n    };\n}));\n"
    },
    203: function(n, e, t) {
        "use strict";
        t(0)(t(204))
    },
    204: function(n, e) {
        n.exports = "spweb.cookie = (function() {\n  /**\n   * Cookie handling\n   * @module spweb/cookie\n   */\n\n  'use strict';\n\n  var exports = {};\n\n  /**\n   * Set the value for a given cookie. Create cookie if it does not exist.\n   * @param {Object} params\n   * @param {String} params.name Name of the cookie\n   * @param {String} [params.value] Value to set. Delete the cookie if this is omitted.\n   * @param {Integer}[params.expires] Days cookie is valid for. Defaults to session cookie if omitted.\n   * @param {String} [params.domain] Value to set. Default to current domain if omitted\n   */\n  exports.set = function(params) {\n    var name = params.name,\n      value,\n      expires,\n      domain;\n\n    if (typeof params.value === 'undefined') {\n      value = '';\n      expires = '-1';\n    } else {\n      value = params.value;\n    }\n\n    if (typeof params.expires !== 'undefined') {\n      var date = new Date();\n      date.setTime(date.getTime() + (params.expires * 24 * 60 * 60 * 1000));\n      expires = '; expires=' + date.toGMTString();\n    } else {\n      expires = '';\n    }\n\n    if (typeof params.domain !== 'undefined' && params.domain !== null) {\n      domain = '; domain=' + params.domain;\n    } else {\n      domain = '';\n    }\n\n    window.document.cookie = name + '=' + value + expires + domain + '; path=/';\n  };\n\n  /**\n   * Retrieve a cookie's value\n   * @param {String} name\n   * @returns {String|null}\n   */\n  exports.get = function(name) {\n    var nameEQ = name + '=',\n      ca = window.document.cookie.split(';'),\n      i;\n\n    for(i = 0; i < ca.length; i += 1) {\n      var c = ca[i];\n\n      while (c.charAt(0) === ' ') {\n        c = c.substring(1, c.length);\n      }\n      if (c.indexOf(nameEQ) === 0) {\n        return c.substring(nameEQ.length, c.length);\n      }\n    }\n\n    return null;\n  };\n\n  /**\n   * Delete a cookie\n   * @param {String} name of cookie to delete\n   */\n  exports.remove = function(name) {\n    this.set({name: name});\n  };\n\n  return exports;\n}());\n"
    },
    226: function(n, e, t) {
        "use strict";
        t(0)(t(227))
    },
    227: function(n, e) {
        n.exports = "/*eslint strict:0*/\n\n/*\n * Check if console is defined.\n * Avoid errors caused by debug-code.\n */\nif (typeof window.console === 'undefined') {\n  window.console = {\n    log: function() {}\n  };\n}\n\n\n/**\n * @namespace Defines the spotify.com global namespace.\n */\nvar spweb = spweb || {};\n"
    },
    293: function(n, e, t) {
        "use strict";
        t(0)(t(294))
    },
    294: function(n, e) {
        n.exports = "/** Globals PubSub, document */\n\nspweb.messageBars = (function (document, cookie, pubSub) {\n\n  /**\n   * Manage message bar ui components\n   * @module spweb/messageBars\n   * @requires jQuery\n   * @requires spweb.cookie\n   * @requires PubSub\n   */\n\n  'use strict';\n\n  var exports = {\n    /**\n     * The active messages collection keeps a record of the currently active message bars. This is\n     * used to tweak the padding of the .wrap element to ensure the header doesn't collide with\n     * the content.\n     */\n    active: {},\n\n    /**\n     * Initialises all the message bars\n     */\n    init: function() {\n\n      // This is a div in which all the message bars are contained\n      spweb.messageBars.holder = document.querySelectorAll('#js-message-bars');\n\n      // Initialize message bars\n      for (var messageBar in spweb.messageBars) {\n        spweb.messageBars.initMessageBar(messageBar);\n      }\n    },\n\n    /**\n     * Initialize a message bar\n     * @param {Object} messageBar\n     */\n    initMessageBar: function(messageBar) {\n      if (spweb.messageBars[messageBar] && spweb.messageBars[messageBar].name && spweb.messageBars[messageBar].selector) {\n\n        spweb.messageBars[messageBar].element = document.querySelector(spweb.messageBars[messageBar].selector);\n\n        // If the element doesn't exist in the HTML, don't continue\n        if (spweb.messageBars[messageBar].element === null) {\n          return;\n        }\n\n        // If we have the cookie, don't show the message\n        if (cookie.get(spweb.messageBars[messageBar].name)) {\n          return;\n        }\n\n        /**\n         * Show method should only be called in messages.add\n         * @private\n         */\n        spweb.messageBars[messageBar]._show = function() {\n          spweb.messageBars[messageBar].element.classList.remove('hidden');\n        };\n\n        /**\n         * Hide method should only be called in messages.remove\n         * @private\n         */\n        spweb.messageBars[messageBar]._hide = function() {\n          spweb.messageBars[messageBar].element.classList.add('hidden');\n        };\n\n        // Add the object to the active messages collection\n        spweb.messageBars.add(spweb.messageBars[messageBar]);\n\n        // Ties up the bootstrap alert close event\n        if (spweb.messageBars[messageBar].element.querySelector(\"button\")) {\n          spweb.messageBars[messageBar].element.querySelector(\"button\").addEventListener('click', function () {\n            // Sets the cookie so we don't show the message on subsequest page views. Note we don't\n            // want to call the alert close method here because we're navigating away from the page\n            // and hiding the message bar just before navigating looks a bit strange.\n            var cookieData = {\n              name: spweb.messageBars[messageBar].name,\n              value: '1'\n            }\n\n            if (spweb.messageBars[messageBar].multiDomainCookie) {\n              cookieData.domain = '.' + window.location.host.split('.').splice(1).join('.');\n            }\n\n            if (spweb.messageBars[messageBar].cookieExpirationDays) {\n              cookieData.expires = spweb.messageBars[messageBar].cookieExpirationDays;\n            }\n\n            cookie.set(cookieData);\n\n            // Remove the object from the active messages collection\n            spweb.messageBars.remove(spweb.messageBars[messageBar]);\n\n            // Do message-specific post-close stuff if need be\n            if (typeof spweb.messageBars[messageBar].onClose === 'function') {\n              spweb.messageBars[messageBar].onClose();\n            }\n          });\n        }\n\n        // Do message-specific initialization if need be\n        if (typeof spweb.messageBars[messageBar].init === 'function') {\n          spweb.messageBars[messageBar].init();\n        }\n      }\n    },\n\n    /**\n     * Add a message bar to the active messages collection and show it. We also\n     * fire the message_bars_shown event.\n     * @param {Object} message\n     */\n    add: function(message) {\n      spweb.messageBars.active[message.name] = message;\n      message._show();\n      pubSub.publish('message_bars_shown');\n    },\n\n    /**\n     * Remove a message bar from the active messages collection and hide it.\n     * If there are no active message bars left, we fore the message_bars_hidden\n     * event. Note we also fire the message_bars_shown event if there are still\n     * message bars because we're not 100% certain that the page starts off in the\n     * right state.\n     * @param {Object} message\n     */\n    remove: function(message) {\n      delete spweb.messageBars.active[message.name];\n      message._hide();\n      if (spweb.messageBars.hasItem()) {\n        pubSub.publish('message_bars_shown');\n      } else {\n        pubSub.publish('message_bars_hidden');\n      }\n    },\n\n    /**\n     * Is there an active message bar?\n     * @returns {boolean}\n     */\n    hasItem: function() {\n      var key;\n      for (key in spweb.messageBars.active) {\n        if (spweb.messageBars.active.hasOwnProperty(key)) {\n          return true;\n        }\n      }\n      return false;\n    },\n\n    /**\n     * Record acceptance of the cookie policy\n     */\n    trackAcceptance: function() {\n      new Image().src = 'https://pixel.spotify.com/v1/cpua';\n    },\n\n    /**\n     * Thai day of mourning bar - as a kludge this also includes the multi-language text.\n     */\n    thaiDom: {\n      /**\n       * Unique name for the cookie and active messages collection\n       */\n      name: 'thanDom',\n\n      /**\n       * Unique selector for the message bar element\n       */\n      selector: '#js-message-bar-thai-dom',\n\n      /**\n       * Initialise the thaiDom message bar\n       */\n      init: function() {\n\n        // Ties to the multi-language change link\n        document.querySelector('.multi-language-link').addEventListener('click', function() {\n\n          // Calls the update-preferred-locale endpoint to save the new market to the\n          // preferred-locale user atribute. Note if there's an error we don't want to interrupt\n          // the redirect, so we don't bother waiting for the response.\n\n          var request = new XMLHttpRequest();\n          request.open('GET', '/' + spweb.messageBars.multiLanguage.element.getAttribute('data-alternative-market') + '/update-preferred-locale/', true);\n          request.send();\n\n        });\n      }\n    },\n\n    /**\n     * Multi language bar: in multi-language markets (CH, CA, HK etc.), this prompts the visitor to\n     * change language.\n     */\n    multiLanguage: {\n      /**\n       * Unique name for the cookie and active messages collection\n       */\n      name: 'multiLanguage',\n\n      /**\n       * Unique selector for the message bar element\n       */\n      selector: '#js-message-bar-multi-language',\n\n      /**\n       * Initialise the multiLanguage message bar\n       */\n      init: function() {\n\n        // Ties to the multi-language change link\n        document.querySelector('.multi-language-link').addEventListener('click', function() {\n\n          // Calls the update-preferred-locale endpoint to save the new market to the\n          // preferred-locale user atribute. Note if there's an error we don't want to interrupt\n          // the redirect, so we don't bother waiting for the response.\n          var request = new XMLHttpRequest();\n          request.open('GET', '/' + spweb.messageBars.multiLanguage.element.getAttribute('data-alternative-market') + '/update-preferred-locale/', true);\n          request.send();\n\n        });\n      }\n    },\n\n    /**\n     * Cookie notice bar: in certain markets, this warns the user that the site uses cookies.\n     */\n    cookieNotice: {\n      /**\n       * Unique name for the cookie and active messages collection\n       */\n      name: 'cookieNotice',\n\n      /**\n       * Unique selector for the message bar element\n       */\n      selector: '#js-message-bar-cookie-notice',\n\n      /**\n       * Specify if cookie should exclude subdomain\n       */\n      multiDomainCookie: true,\n\n      /**\n       * Set cookie expiration\n       */\n      cookieExpirationDays: 90,\n\n      init: function() {\n        setTimeout(function () {\n            spweb.messageBars.trackAcceptance();\n        }, 250);\n      }\n    },\n\n    /**\n     * Cookie authorization bar: in certain markets, users need to authorized third party cookies.\n     */\n    cookieAuthorization: {\n      /**\n       * Unique name for the cookie and active messages collection\n       */\n      name: 'sp_tpc',\n\n      /**\n       * Unique selector for the message bar element\n       */\n      selector: '#js-message-bar-cookie-authorization',\n\n      /**\n       * Specify if cookie should exclude subdomain\n       */\n      multiDomainCookie: false,\n\n      /**\n       * Set cookie expiration\n       */\n      cookieExpirationDays: 365,\n\n      /**\n       * Perform post-close tasks\n       */\n      onClose: function() {\n        spweb.messageBars.trackAcceptance();\n        window.location.reload();\n      }\n    },\n\n    /**\n     * Special notice bar: warns the user with some arbitrary message.\n     */\n    specialNotice: {\n      /**\n       * Unique name for the cookie and active messages collection\n       */\n      name: 'specialNotice',\n\n      /**\n       * Unique selector for the message bar element\n       */\n      selector: '#js-message-bar-special-notice'\n    }\n\n  };\n\n  return exports;\n\n}(document, spweb.cookie, PubSub));\n"
    },
    297: function(n, e, t) {
        t(0)(t(298))
    },
    298: function(n, e) {
        n.exports = "\nif (typeof jQuery === 'undefined') {\n  throw new Error('Bootstrap\\'s JavaScript requires jQuery')\n}\n\n+function ($) {\n  'use strict';\n  var version = $.fn.jquery.split(' ')[0].split('.')\n  if ((version[0] < 2 && version[1] < 9) || (version[0] == 1 && version[1] == 9 && version[2] < 1) || (version[0] > 3)) {\n    throw new Error('Bootstrap\\'s JavaScript requires jQuery version 1.9.1 or higher, but lower than version 4')\n  }\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: transition.js v3.3.7\n * http://getbootstrap.com/javascript/#transitions\n * ========================================================================\n * Copyright 2011-2016 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)\n  // ============================================================\n\n  function transitionEnd() {\n    var el = document.createElement('bootstrap')\n\n    var transEndEventNames = {\n      WebkitTransition : 'webkitTransitionEnd',\n      MozTransition    : 'transitionend',\n      OTransition      : 'oTransitionEnd otransitionend',\n      transition       : 'transitionend'\n    }\n\n    for (var name in transEndEventNames) {\n      if (el.style[name] !== undefined) {\n        return { end: transEndEventNames[name] }\n      }\n    }\n\n    return false // explicit for ie8 (  ._.)\n  }\n\n  // http://blog.alexmaccaw.com/css-transitions\n  $.fn.emulateTransitionEnd = function (duration) {\n    var called = false\n    var $el = this\n    $(this).one('bsTransitionEnd', function () { called = true })\n    var callback = function () { if (!called) $($el).trigger($.support.transition.end) }\n    setTimeout(callback, duration)\n    return this\n  }\n\n  $(function () {\n    $.support.transition = transitionEnd()\n\n    if (!$.support.transition) return\n\n    $.event.special.bsTransitionEnd = {\n      bindType: $.support.transition.end,\n      delegateType: $.support.transition.end,\n      handle: function (e) {\n        if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)\n      }\n    }\n  })\n\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: alert.js v3.3.7\n * http://getbootstrap.com/javascript/#alerts\n * ========================================================================\n * Copyright 2011-2016 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // ALERT CLASS DEFINITION\n  // ======================\n\n  var dismiss = '[data-dismiss=\"alert\"]'\n  var Alert   = function (el) {\n    $(el).on('click', dismiss, this.close)\n  }\n\n  Alert.VERSION = '3.3.7'\n\n  Alert.TRANSITION_DURATION = 150\n\n  Alert.prototype.close = function (e) {\n    var $this    = $(this)\n    var selector = $this.attr('data-target')\n\n    if (!selector) {\n      selector = $this.attr('href')\n      selector = selector && selector.replace(/.*(?=#[^\\s]*$)/, '') // strip for ie7\n    }\n\n    var $parent = $(selector === '#' ? [] : selector)\n\n    if (e) e.preventDefault()\n\n    if (!$parent.length) {\n      $parent = $this.closest('.alert')\n    }\n\n    $parent.trigger(e = $.Event('close.bs.alert'))\n\n    if (e.isDefaultPrevented()) return\n\n    $parent.removeClass('in')\n\n    function removeElement() {\n      // detach from parent, fire event then clean up data\n      $parent.detach().trigger('closed.bs.alert').remove()\n    }\n\n    $.support.transition && $parent.hasClass('fade') ?\n      $parent\n        .one('bsTransitionEnd', removeElement)\n        .emulateTransitionEnd(Alert.TRANSITION_DURATION) :\n      removeElement()\n  }\n\n\n  // ALERT PLUGIN DEFINITION\n  // =======================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this = $(this)\n      var data  = $this.data('bs.alert')\n\n      if (!data) $this.data('bs.alert', (data = new Alert(this)))\n      if (typeof option == 'string') data[option].call($this)\n    })\n  }\n\n  var old = $.fn.alert\n\n  $.fn.alert             = Plugin\n  $.fn.alert.Constructor = Alert\n\n\n  // ALERT NO CONFLICT\n  // =================\n\n  $.fn.alert.noConflict = function () {\n    $.fn.alert = old\n    return this\n  }\n\n\n  // ALERT DATA-API\n  // ==============\n\n  $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close)\n\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: button.js v3.3.7\n * http://getbootstrap.com/javascript/#buttons\n * ========================================================================\n * Copyright 2011-2016 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // BUTTON PUBLIC CLASS DEFINITION\n  // ==============================\n\n  var Button = function (element, options) {\n    this.$element  = $(element)\n    this.options   = $.extend({}, Button.DEFAULTS, options)\n    this.isLoading = false\n  }\n\n  Button.VERSION  = '3.3.7'\n\n  Button.DEFAULTS = {\n    loadingText: 'loading...'\n  }\n\n  Button.prototype.setState = function (state) {\n    var d    = 'disabled'\n    var $el  = this.$element\n    var val  = $el.is('input') ? 'val' : 'html'\n    var data = $el.data()\n\n    state += 'Text'\n\n    if (data.resetText == null) $el.data('resetText', $el[val]())\n\n    // push to event loop to allow forms to submit\n    setTimeout($.proxy(function () {\n      $el[val](data[state] == null ? this.options[state] : data[state])\n\n      if (state == 'loadingText') {\n        this.isLoading = true\n        $el.addClass(d).attr(d, d).prop(d, true)\n      } else if (this.isLoading) {\n        this.isLoading = false\n        $el.removeClass(d).removeAttr(d).prop(d, false)\n      }\n    }, this), 0)\n  }\n\n  Button.prototype.toggle = function () {\n    var changed = true\n    var $parent = this.$element.closest('[data-toggle=\"buttons\"]')\n\n    if ($parent.length) {\n      var $input = this.$element.find('input')\n      if ($input.prop('type') == 'radio') {\n        if ($input.prop('checked')) changed = false\n        $parent.find('.active').removeClass('active')\n        this.$element.addClass('active')\n      } else if ($input.prop('type') == 'checkbox') {\n        if (($input.prop('checked')) !== this.$element.hasClass('active')) changed = false\n        this.$element.toggleClass('active')\n      }\n      $input.prop('checked', this.$element.hasClass('active'))\n      if (changed) $input.trigger('change')\n    } else {\n      this.$element.attr('aria-pressed', !this.$element.hasClass('active'))\n      this.$element.toggleClass('active')\n    }\n  }\n\n\n  // BUTTON PLUGIN DEFINITION\n  // ========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data('bs.button')\n      var options = typeof option == 'object' && option\n\n      if (!data) $this.data('bs.button', (data = new Button(this, options)))\n\n      if (option == 'toggle') data.toggle()\n      else if (option) data.setState(option)\n    })\n  }\n\n  var old = $.fn.button\n\n  $.fn.button             = Plugin\n  $.fn.button.Constructor = Button\n\n\n  // BUTTON NO CONFLICT\n  // ==================\n\n  $.fn.button.noConflict = function () {\n    $.fn.button = old\n    return this\n  }\n\n\n  // BUTTON DATA-API\n  // ===============\n\n  $(document)\n    .on('click.bs.button.data-api', '[data-toggle^=\"button\"]', function (e) {\n      var $btn = $(e.target).closest('.btn')\n      Plugin.call($btn, 'toggle')\n      if (!($(e.target).is('input[type=\"radio\"], input[type=\"checkbox\"]'))) {\n        // Prevent double click on radios, and the double selections (so cancellation) on checkboxes\n        e.preventDefault()\n        // The target component still receive the focus\n        if ($btn.is('input,button')) $btn.trigger('focus')\n        else $btn.find('input:visible,button:visible').first().trigger('focus')\n      }\n    })\n    .on('focus.bs.button.data-api blur.bs.button.data-api', '[data-toggle^=\"button\"]', function (e) {\n      $(e.target).closest('.btn').toggleClass('focus', /^focus(in)?$/.test(e.type))\n    })\n\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: carousel.js v3.3.7\n * http://getbootstrap.com/javascript/#carousel\n * ========================================================================\n * Copyright 2011-2016 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // CAROUSEL CLASS DEFINITION\n  // =========================\n\n  var Carousel = function (element, options) {\n    this.$element    = $(element)\n    this.$indicators = this.$element.find('.carousel-indicators')\n    this.options     = options\n    this.paused      = null\n    this.sliding     = null\n    this.interval    = null\n    this.$active     = null\n    this.$items      = null\n\n    this.options.keyboard && this.$element.on('keydown.bs.carousel', $.proxy(this.keydown, this))\n\n    this.options.pause == 'hover' && !('ontouchstart' in document.documentElement) && this.$element\n      .on('mouseenter.bs.carousel', $.proxy(this.pause, this))\n      .on('mouseleave.bs.carousel', $.proxy(this.cycle, this))\n  }\n\n  Carousel.VERSION  = '3.3.7'\n\n  Carousel.TRANSITION_DURATION = 600\n\n  Carousel.DEFAULTS = {\n    interval: 5000,\n    pause: 'hover',\n    wrap: true,\n    keyboard: true\n  }\n\n  Carousel.prototype.keydown = function (e) {\n    if (/input|textarea/i.test(e.target.tagName)) return\n    switch (e.which) {\n      case 37: this.prev(); break\n      case 39: this.next(); break\n      default: return\n    }\n\n    e.preventDefault()\n  }\n\n  Carousel.prototype.cycle = function (e) {\n    e || (this.paused = false)\n\n    this.interval && clearInterval(this.interval)\n\n    this.options.interval\n      && !this.paused\n      && (this.interval = setInterval($.proxy(this.next, this), this.options.interval))\n\n    return this\n  }\n\n  Carousel.prototype.getItemIndex = function (item) {\n    this.$items = item.parent().children('.item')\n    return this.$items.index(item || this.$active)\n  }\n\n  Carousel.prototype.getItemForDirection = function (direction, active) {\n    var activeIndex = this.getItemIndex(active)\n    var willWrap = (direction == 'prev' && activeIndex === 0)\n                || (direction == 'next' && activeIndex == (this.$items.length - 1))\n    if (willWrap && !this.options.wrap) return active\n    var delta = direction == 'prev' ? -1 : 1\n    var itemIndex = (activeIndex + delta) % this.$items.length\n    return this.$items.eq(itemIndex)\n  }\n\n  Carousel.prototype.to = function (pos) {\n    var that        = this\n    var activeIndex = this.getItemIndex(this.$active = this.$element.find('.item.active'))\n\n    if (pos > (this.$items.length - 1) || pos < 0) return\n\n    if (this.sliding)       return this.$element.one('slid.bs.carousel', function () { that.to(pos) }) // yes, \"slid\"\n    if (activeIndex == pos) return this.pause().cycle()\n\n    return this.slide(pos > activeIndex ? 'next' : 'prev', this.$items.eq(pos))\n  }\n\n  Carousel.prototype.pause = function (e) {\n    e || (this.paused = true)\n\n    if (this.$element.find('.next, .prev').length && $.support.transition) {\n      this.$element.trigger($.support.transition.end)\n      this.cycle(true)\n    }\n\n    this.interval = clearInterval(this.interval)\n\n    return this\n  }\n\n  Carousel.prototype.next = function () {\n    if (this.sliding) return\n    return this.slide('next')\n  }\n\n  Carousel.prototype.prev = function () {\n    if (this.sliding) return\n    return this.slide('prev')\n  }\n\n  Carousel.prototype.slide = function (type, next) {\n    var $active   = this.$element.find('.item.active')\n    var $next     = next || this.getItemForDirection(type, $active)\n    var isCycling = this.interval\n    var direction = type == 'next' ? 'left' : 'right'\n    var that      = this\n\n    if ($next.hasClass('active')) return (this.sliding = false)\n\n    var relatedTarget = $next[0]\n    var slideEvent = $.Event('slide.bs.carousel', {\n      relatedTarget: relatedTarget,\n      direction: direction\n    })\n    this.$element.trigger(slideEvent)\n    if (slideEvent.isDefaultPrevented()) return\n\n    this.sliding = true\n\n    isCycling && this.pause()\n\n    if (this.$indicators.length) {\n      this.$indicators.find('.active').removeClass('active')\n      var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)])\n      $nextIndicator && $nextIndicator.addClass('active')\n    }\n\n    var slidEvent = $.Event('slid.bs.carousel', { relatedTarget: relatedTarget, direction: direction }) // yes, \"slid\"\n    if ($.support.transition && this.$element.hasClass('slide')) {\n      $next.addClass(type)\n      $next[0].offsetWidth // force reflow\n      $active.addClass(direction)\n      $next.addClass(direction)\n      $active\n        .one('bsTransitionEnd', function () {\n          $next.removeClass([type, direction].join(' ')).addClass('active')\n          $active.removeClass(['active', direction].join(' '))\n          that.sliding = false\n          setTimeout(function () {\n            that.$element.trigger(slidEvent)\n          }, 0)\n        })\n        .emulateTransitionEnd(Carousel.TRANSITION_DURATION)\n    } else {\n      $active.removeClass('active')\n      $next.addClass('active')\n      this.sliding = false\n      this.$element.trigger(slidEvent)\n    }\n\n    isCycling && this.cycle()\n\n    return this\n  }\n\n\n  // CAROUSEL PLUGIN DEFINITION\n  // ==========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data('bs.carousel')\n      var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option)\n      var action  = typeof option == 'string' ? option : options.slide\n\n      if (!data) $this.data('bs.carousel', (data = new Carousel(this, options)))\n      if (typeof option == 'number') data.to(option)\n      else if (action) data[action]()\n      else if (options.interval) data.pause().cycle()\n    })\n  }\n\n  var old = $.fn.carousel\n\n  $.fn.carousel             = Plugin\n  $.fn.carousel.Constructor = Carousel\n\n\n  // CAROUSEL NO CONFLICT\n  // ====================\n\n  $.fn.carousel.noConflict = function () {\n    $.fn.carousel = old\n    return this\n  }\n\n\n  // CAROUSEL DATA-API\n  // =================\n\n  var clickHandler = function (e) {\n    var href\n    var $this   = $(this)\n    var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\\s]+$)/, '')) // strip for ie7\n    if (!$target.hasClass('carousel')) return\n    var options = $.extend({}, $target.data(), $this.data())\n    var slideIndex = $this.attr('data-slide-to')\n    if (slideIndex) options.interval = false\n\n    Plugin.call($target, options)\n\n    if (slideIndex) {\n      $target.data('bs.carousel').to(slideIndex)\n    }\n\n    e.preventDefault()\n  }\n\n  $(document)\n    .on('click.bs.carousel.data-api', '[data-slide]', clickHandler)\n    .on('click.bs.carousel.data-api', '[data-slide-to]', clickHandler)\n\n  $(window).on('load', function () {\n    $('[data-ride=\"carousel\"]').each(function () {\n      var $carousel = $(this)\n      Plugin.call($carousel, $carousel.data())\n    })\n  })\n\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: collapse.js v3.3.7\n * http://getbootstrap.com/javascript/#collapse\n * ========================================================================\n * Copyright 2011-2016 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n/* jshint latedef: false */\n\n+function ($) {\n  'use strict';\n\n  // COLLAPSE PUBLIC CLASS DEFINITION\n  // ================================\n\n  var Collapse = function (element, options) {\n    this.$element      = $(element)\n    this.options       = $.extend({}, Collapse.DEFAULTS, options)\n    this.$trigger      = $('[data-toggle=\"collapse\"][href=\"#' + element.id + '\"],' +\n                           '[data-toggle=\"collapse\"][data-target=\"#' + element.id + '\"]')\n    this.transitioning = null\n\n    if (this.options.parent) {\n      this.$parent = this.getParent()\n    } else {\n      this.addAriaAndCollapsedClass(this.$element, this.$trigger)\n    }\n\n    if (this.options.toggle) this.toggle()\n  }\n\n  Collapse.VERSION  = '3.3.7'\n\n  Collapse.TRANSITION_DURATION = 350\n\n  Collapse.DEFAULTS = {\n    toggle: true\n  }\n\n  Collapse.prototype.dimension = function () {\n    var hasWidth = this.$element.hasClass('width')\n    return hasWidth ? 'width' : 'height'\n  }\n\n  Collapse.prototype.show = function () {\n    if (this.transitioning || this.$element.hasClass('in')) return\n\n    var activesData\n    var actives = this.$parent && this.$parent.children('.panel').children('.in, .collapsing')\n\n    if (actives && actives.length) {\n      activesData = actives.data('bs.collapse')\n      if (activesData && activesData.transitioning) return\n    }\n\n    var startEvent = $.Event('show.bs.collapse')\n    this.$element.trigger(startEvent)\n    if (startEvent.isDefaultPrevented()) return\n\n    if (actives && actives.length) {\n      Plugin.call(actives, 'hide')\n      activesData || actives.data('bs.collapse', null)\n    }\n\n    var dimension = this.dimension()\n\n    this.$element\n      .removeClass('collapse')\n      .addClass('collapsing')[dimension](0)\n      .attr('aria-expanded', true)\n\n    this.$trigger\n      .removeClass('collapsed')\n      .attr('aria-expanded', true)\n\n    this.transitioning = 1\n\n    var complete = function () {\n      this.$element\n        .removeClass('collapsing')\n        .addClass('collapse in')[dimension]('')\n      this.transitioning = 0\n      this.$element\n        .trigger('shown.bs.collapse')\n    }\n\n    if (!$.support.transition) return complete.call(this)\n\n    var scrollSize = $.camelCase(['scroll', dimension].join('-'))\n\n    this.$element\n      .one('bsTransitionEnd', $.proxy(complete, this))\n      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize])\n  }\n\n  Collapse.prototype.hide = function () {\n    if (this.transitioning || !this.$element.hasClass('in')) return\n\n    var startEvent = $.Event('hide.bs.collapse')\n    this.$element.trigger(startEvent)\n    if (startEvent.isDefaultPrevented()) return\n\n    var dimension = this.dimension()\n\n    this.$element[dimension](this.$element[dimension]())[0].offsetHeight\n\n    this.$element\n      .addClass('collapsing')\n      .removeClass('collapse in')\n      .attr('aria-expanded', false)\n\n    this.$trigger\n      .addClass('collapsed')\n      .attr('aria-expanded', false)\n\n    this.transitioning = 1\n\n    var complete = function () {\n      this.transitioning = 0\n      this.$element\n        .removeClass('collapsing')\n        .addClass('collapse')\n        .trigger('hidden.bs.collapse')\n    }\n\n    if (!$.support.transition) return complete.call(this)\n\n    this.$element\n      [dimension](0)\n      .one('bsTransitionEnd', $.proxy(complete, this))\n      .emulateTransitionEnd(Collapse.TRANSITION_DURATION)\n  }\n\n  Collapse.prototype.toggle = function () {\n    this[this.$element.hasClass('in') ? 'hide' : 'show']()\n  }\n\n  Collapse.prototype.getParent = function () {\n    return $(this.options.parent)\n      .find('[data-toggle=\"collapse\"][data-parent=\"' + this.options.parent + '\"]')\n      .each($.proxy(function (i, element) {\n        var $element = $(element)\n        this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element)\n      }, this))\n      .end()\n  }\n\n  Collapse.prototype.addAriaAndCollapsedClass = function ($element, $trigger) {\n    var isOpen = $element.hasClass('in')\n\n    $element.attr('aria-expanded', isOpen)\n    $trigger\n      .toggleClass('collapsed', !isOpen)\n      .attr('aria-expanded', isOpen)\n  }\n\n  function getTargetFromTrigger($trigger) {\n    var href\n    var target = $trigger.attr('data-target')\n      || (href = $trigger.attr('href')) && href.replace(/.*(?=#[^\\s]+$)/, '') // strip for ie7\n\n    return $(target)\n  }\n\n\n  // COLLAPSE PLUGIN DEFINITION\n  // ==========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data('bs.collapse')\n      var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option)\n\n      if (!data && options.toggle && /show|hide/.test(option)) options.toggle = false\n      if (!data) $this.data('bs.collapse', (data = new Collapse(this, options)))\n      if (typeof option == 'string') data[option]()\n    })\n  }\n\n  var old = $.fn.collapse\n\n  $.fn.collapse             = Plugin\n  $.fn.collapse.Constructor = Collapse\n\n\n  // COLLAPSE NO CONFLICT\n  // ====================\n\n  $.fn.collapse.noConflict = function () {\n    $.fn.collapse = old\n    return this\n  }\n\n\n  // COLLAPSE DATA-API\n  // =================\n\n  $(document).on('click.bs.collapse.data-api', '[data-toggle=\"collapse\"]', function (e) {\n    var $this   = $(this)\n\n    if (!$this.attr('data-target')) e.preventDefault()\n\n    var $target = getTargetFromTrigger($this)\n    var data    = $target.data('bs.collapse')\n    var option  = data ? 'toggle' : $this.data()\n\n    Plugin.call($target, option)\n  })\n\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: dropdown.js v3.3.7\n * http://getbootstrap.com/javascript/#dropdowns\n * ========================================================================\n * Copyright 2011-2016 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // DROPDOWN CLASS DEFINITION\n  // =========================\n\n  var backdrop = '.dropdown-backdrop'\n  var toggle   = '[data-toggle=\"dropdown\"]'\n  var Dropdown = function (element) {\n    $(element).on('click.bs.dropdown', this.toggle)\n  }\n\n  Dropdown.VERSION = '3.3.7'\n\n  function getParent($this) {\n    var selector = $this.attr('data-target')\n\n    if (!selector) {\n      selector = $this.attr('href')\n      selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\\s]*$)/, '') // strip for ie7\n    }\n\n    var $parent = selector && $(selector)\n\n    return $parent && $parent.length ? $parent : $this.parent()\n  }\n\n  function clearMenus(e) {\n    if (e && e.which === 3) return\n    $(backdrop).remove()\n    $(toggle).each(function () {\n      var $this         = $(this)\n      var $parent       = getParent($this)\n      var relatedTarget = { relatedTarget: this }\n\n      if (!$parent.hasClass('open')) return\n\n      if (e && e.type == 'click' && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target)) return\n\n      $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget))\n\n      if (e.isDefaultPrevented()) return\n\n      $this.attr('aria-expanded', 'false')\n      $parent.removeClass('open').trigger($.Event('hidden.bs.dropdown', relatedTarget))\n    })\n  }\n\n  Dropdown.prototype.toggle = function (e) {\n    var $this = $(this)\n\n    if ($this.is('.disabled, :disabled')) return\n\n    var $parent  = getParent($this)\n    var isActive = $parent.hasClass('open')\n\n    clearMenus()\n\n    if (!isActive) {\n      if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {\n        // if mobile we use a backdrop because click events don't delegate\n        $(document.createElement('div'))\n          .addClass('dropdown-backdrop')\n          .insertAfter($(this))\n          .on('click', clearMenus)\n      }\n\n      var relatedTarget = { relatedTarget: this }\n      $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget))\n\n      if (e.isDefaultPrevented()) return\n\n      $this\n        .trigger('focus')\n        .attr('aria-expanded', 'true')\n\n      $parent\n        .toggleClass('open')\n        .trigger($.Event('shown.bs.dropdown', relatedTarget))\n    }\n\n    return false\n  }\n\n  Dropdown.prototype.keydown = function (e) {\n    if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return\n\n    var $this = $(this)\n\n    e.preventDefault()\n    e.stopPropagation()\n\n    if ($this.is('.disabled, :disabled')) return\n\n    var $parent  = getParent($this)\n    var isActive = $parent.hasClass('open')\n\n    if (!isActive && e.which != 27 || isActive && e.which == 27) {\n      if (e.which == 27) $parent.find(toggle).trigger('focus')\n      return $this.trigger('click')\n    }\n\n    var desc = ' li:not(.disabled):visible a'\n    var $items = $parent.find('.dropdown-menu' + desc)\n\n    if (!$items.length) return\n\n    var index = $items.index(e.target)\n\n    if (e.which == 38 && index > 0)                 index--         // up\n    if (e.which == 40 && index < $items.length - 1) index++         // down\n    if (!~index)                                    index = 0\n\n    $items.eq(index).trigger('focus')\n  }\n\n\n  // DROPDOWN PLUGIN DEFINITION\n  // ==========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this = $(this)\n      var data  = $this.data('bs.dropdown')\n\n      if (!data) $this.data('bs.dropdown', (data = new Dropdown(this)))\n      if (typeof option == 'string') data[option].call($this)\n    })\n  }\n\n  var old = $.fn.dropdown\n\n  $.fn.dropdown             = Plugin\n  $.fn.dropdown.Constructor = Dropdown\n\n\n  // DROPDOWN NO CONFLICT\n  // ====================\n\n  $.fn.dropdown.noConflict = function () {\n    $.fn.dropdown = old\n    return this\n  }\n\n\n  // APPLY TO STANDARD DROPDOWN ELEMENTS\n  // ===================================\n\n  $(document)\n    .on('click.bs.dropdown.data-api', clearMenus)\n    .on('click.bs.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() })\n    .on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle)\n    .on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown)\n    .on('keydown.bs.dropdown.data-api', '.dropdown-menu', Dropdown.prototype.keydown)\n\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: modal.js v3.3.7\n * http://getbootstrap.com/javascript/#modals\n * ========================================================================\n * Copyright 2011-2016 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // MODAL CLASS DEFINITION\n  // ======================\n\n  var Modal = function (element, options) {\n    this.options             = options\n    this.$body               = $(document.body)\n    this.$element            = $(element)\n    this.$dialog             = this.$element.find('.modal-dialog')\n    this.$backdrop           = null\n    this.isShown             = null\n    this.originalBodyPad     = null\n    this.scrollbarWidth      = 0\n    this.ignoreBackdropClick = false\n\n    if (this.options.remote) {\n      this.$element\n        .find('.modal-content')\n        .load(this.options.remote, $.proxy(function () {\n          this.$element.trigger('loaded.bs.modal')\n        }, this))\n    }\n  }\n\n  Modal.VERSION  = '3.3.7'\n\n  Modal.TRANSITION_DURATION = 300\n  Modal.BACKDROP_TRANSITION_DURATION = 150\n\n  Modal.DEFAULTS = {\n    backdrop: true,\n    keyboard: true,\n    show: true\n  }\n\n  Modal.prototype.toggle = function (_relatedTarget) {\n    return this.isShown ? this.hide() : this.show(_relatedTarget)\n  }\n\n  Modal.prototype.show = function (_relatedTarget) {\n    var that = this\n    var e    = $.Event('show.bs.modal', { relatedTarget: _relatedTarget })\n\n    this.$element.trigger(e)\n\n    if (this.isShown || e.isDefaultPrevented()) return\n\n    this.isShown = true\n\n    this.checkScrollbar()\n    this.setScrollbar()\n    this.$body.addClass('modal-open')\n\n    this.escape()\n    this.resize()\n\n    this.$element.on('click.dismiss.bs.modal', '[data-dismiss=\"modal\"]', $.proxy(this.hide, this))\n\n    this.$dialog.on('mousedown.dismiss.bs.modal', function () {\n      that.$element.one('mouseup.dismiss.bs.modal', function (e) {\n        if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true\n      })\n    })\n\n    this.backdrop(function () {\n      var transition = $.support.transition && that.$element.hasClass('fade')\n\n      if (!that.$element.parent().length) {\n        that.$element.appendTo(that.$body) // don't move modals dom position\n      }\n\n      that.$element\n        .show()\n        .scrollTop(0)\n\n      that.adjustDialog()\n\n      if (transition) {\n        that.$element[0].offsetWidth // force reflow\n      }\n\n      that.$element.addClass('in')\n\n      that.enforceFocus()\n\n      var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget })\n\n      transition ?\n        that.$dialog // wait for modal to slide in\n          .one('bsTransitionEnd', function () {\n            that.$element.trigger('focus').trigger(e)\n          })\n          .emulateTransitionEnd(Modal.TRANSITION_DURATION) :\n        that.$element.trigger('focus').trigger(e)\n    })\n  }\n\n  Modal.prototype.hide = function (e) {\n    if (e) e.preventDefault()\n\n    e = $.Event('hide.bs.modal')\n\n    this.$element.trigger(e)\n\n    if (!this.isShown || e.isDefaultPrevented()) return\n\n    this.isShown = false\n\n    this.escape()\n    this.resize()\n\n    $(document).off('focusin.bs.modal')\n\n    this.$element\n      .removeClass('in')\n      .off('click.dismiss.bs.modal')\n      .off('mouseup.dismiss.bs.modal')\n\n    this.$dialog.off('mousedown.dismiss.bs.modal')\n\n    $.support.transition && this.$element.hasClass('fade') ?\n      this.$element\n        .one('bsTransitionEnd', $.proxy(this.hideModal, this))\n        .emulateTransitionEnd(Modal.TRANSITION_DURATION) :\n      this.hideModal()\n  }\n\n  Modal.prototype.enforceFocus = function () {\n    $(document)\n      .off('focusin.bs.modal') // guard against infinite focus loop\n      .on('focusin.bs.modal', $.proxy(function (e) {\n        if (document !== e.target &&\n            this.$element[0] !== e.target &&\n            !this.$element.has(e.target).length) {\n          this.$element.trigger('focus')\n        }\n      }, this))\n  }\n\n  Modal.prototype.escape = function () {\n    if (this.isShown && this.options.keyboard) {\n      this.$element.on('keydown.dismiss.bs.modal', $.proxy(function (e) {\n        e.which == 27 && this.hide()\n      }, this))\n    } else if (!this.isShown) {\n      this.$element.off('keydown.dismiss.bs.modal')\n    }\n  }\n\n  Modal.prototype.resize = function () {\n    if (this.isShown) {\n      $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this))\n    } else {\n      $(window).off('resize.bs.modal')\n    }\n  }\n\n  Modal.prototype.hideModal = function () {\n    var that = this\n    this.$element.hide()\n    this.backdrop(function () {\n      that.$body.removeClass('modal-open')\n      that.resetAdjustments()\n      that.resetScrollbar()\n      that.$element.trigger('hidden.bs.modal')\n    })\n  }\n\n  Modal.prototype.removeBackdrop = function () {\n    this.$backdrop && this.$backdrop.remove()\n    this.$backdrop = null\n  }\n\n  Modal.prototype.backdrop = function (callback) {\n    var that = this\n    var animate = this.$element.hasClass('fade') ? 'fade' : ''\n\n    if (this.isShown && this.options.backdrop) {\n      var doAnimate = $.support.transition && animate\n\n      this.$backdrop = $(document.createElement('div'))\n        .addClass('modal-backdrop ' + animate)\n        .appendTo(this.$body)\n\n      this.$element.on('click.dismiss.bs.modal', $.proxy(function (e) {\n        if (this.ignoreBackdropClick) {\n          this.ignoreBackdropClick = false\n          return\n        }\n        if (e.target !== e.currentTarget) return\n        this.options.backdrop == 'static'\n          ? this.$element[0].focus()\n          : this.hide()\n      }, this))\n\n      if (doAnimate) this.$backdrop[0].offsetWidth // force reflow\n\n      this.$backdrop.addClass('in')\n\n      if (!callback) return\n\n      doAnimate ?\n        this.$backdrop\n          .one('bsTransitionEnd', callback)\n          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :\n        callback()\n\n    } else if (!this.isShown && this.$backdrop) {\n      this.$backdrop.removeClass('in')\n\n      var callbackRemove = function () {\n        that.removeBackdrop()\n        callback && callback()\n      }\n      $.support.transition && this.$element.hasClass('fade') ?\n        this.$backdrop\n          .one('bsTransitionEnd', callbackRemove)\n          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :\n        callbackRemove()\n\n    } else if (callback) {\n      callback()\n    }\n  }\n\n  // these following methods are used to handle overflowing modals\n\n  Modal.prototype.handleUpdate = function () {\n    this.adjustDialog()\n  }\n\n  Modal.prototype.adjustDialog = function () {\n    var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight\n\n    this.$element.css({\n      paddingLeft:  !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '',\n      paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ''\n    })\n  }\n\n  Modal.prototype.resetAdjustments = function () {\n    this.$element.css({\n      paddingLeft: '',\n      paddingRight: ''\n    })\n  }\n\n  Modal.prototype.checkScrollbar = function () {\n    var fullWindowWidth = window.innerWidth\n    if (!fullWindowWidth) { // workaround for missing window.innerWidth in IE8\n      var documentElementRect = document.documentElement.getBoundingClientRect()\n      fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left)\n    }\n    this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth\n    this.scrollbarWidth = this.measureScrollbar()\n  }\n\n  Modal.prototype.setScrollbar = function () {\n    var bodyPad = parseInt((this.$body.css('padding-right') || 0), 10)\n    this.originalBodyPad = document.body.style.paddingRight || ''\n    if (this.bodyIsOverflowing) this.$body.css('padding-right', bodyPad + this.scrollbarWidth)\n  }\n\n  Modal.prototype.resetScrollbar = function () {\n    this.$body.css('padding-right', this.originalBodyPad)\n  }\n\n  Modal.prototype.measureScrollbar = function () { // thx walsh\n    var scrollDiv = document.createElement('div')\n    scrollDiv.className = 'modal-scrollbar-measure'\n    this.$body.append(scrollDiv)\n    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth\n    this.$body[0].removeChild(scrollDiv)\n    return scrollbarWidth\n  }\n\n\n  // MODAL PLUGIN DEFINITION\n  // =======================\n\n  function Plugin(option, _relatedTarget) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data('bs.modal')\n      var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option)\n\n      if (!data) $this.data('bs.modal', (data = new Modal(this, options)))\n      if (typeof option == 'string') data[option](_relatedTarget)\n      else if (options.show) data.show(_relatedTarget)\n    })\n  }\n\n  var old = $.fn.modal\n\n  $.fn.modal             = Plugin\n  $.fn.modal.Constructor = Modal\n\n\n  // MODAL NO CONFLICT\n  // =================\n\n  $.fn.modal.noConflict = function () {\n    $.fn.modal = old\n    return this\n  }\n\n\n  // MODAL DATA-API\n  // ==============\n\n  $(document).on('click.bs.modal.data-api', '[data-toggle=\"modal\"]', function (e) {\n    var $this   = $(this)\n    var href    = $this.attr('href')\n    var $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\\s]+$)/, ''))) // strip for ie7\n    var option  = $target.data('bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data())\n\n    if ($this.is('a')) e.preventDefault()\n\n    $target.one('show.bs.modal', function (showEvent) {\n      if (showEvent.isDefaultPrevented()) return // only register focus restorer if modal will actually get shown\n      $target.one('hidden.bs.modal', function () {\n        $this.is(':visible') && $this.trigger('focus')\n      })\n    })\n    Plugin.call($target, option, this)\n  })\n\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: tooltip.js v3.3.7\n * http://getbootstrap.com/javascript/#tooltip\n * Inspired by the original jQuery.tipsy by Jason Frame\n * ========================================================================\n * Copyright 2011-2016 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // TOOLTIP PUBLIC CLASS DEFINITION\n  // ===============================\n\n  var Tooltip = function (element, options) {\n    this.type       = null\n    this.options    = null\n    this.enabled    = null\n    this.timeout    = null\n    this.hoverState = null\n    this.$element   = null\n    this.inState    = null\n\n    this.init('tooltip', element, options)\n  }\n\n  Tooltip.VERSION  = '3.3.7'\n\n  Tooltip.TRANSITION_DURATION = 150\n\n  Tooltip.DEFAULTS = {\n    animation: true,\n    placement: 'top',\n    selector: false,\n    template: '<div class=\"tooltip\" role=\"tooltip\"><div class=\"tooltip-arrow\"></div><div class=\"tooltip-inner\"></div></div>',\n    trigger: 'hover focus',\n    title: '',\n    delay: 0,\n    html: false,\n    container: false,\n    viewport: {\n      selector: 'body',\n      padding: 0\n    }\n  }\n\n  Tooltip.prototype.init = function (type, element, options) {\n    this.enabled   = true\n    this.type      = type\n    this.$element  = $(element)\n    this.options   = this.getOptions(options)\n    this.$viewport = this.options.viewport && $($.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : (this.options.viewport.selector || this.options.viewport))\n    this.inState   = { click: false, hover: false, focus: false }\n\n    if (this.$element[0] instanceof document.constructor && !this.options.selector) {\n      throw new Error('`selector` option must be specified when initializing ' + this.type + ' on the window.document object!')\n    }\n\n    var triggers = this.options.trigger.split(' ')\n\n    for (var i = triggers.length; i--;) {\n      var trigger = triggers[i]\n\n      if (trigger == 'click') {\n        this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this))\n      } else if (trigger != 'manual') {\n        var eventIn  = trigger == 'hover' ? 'mouseenter' : 'focusin'\n        var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout'\n\n        this.$element.on(eventIn  + '.' + this.type, this.options.selector, $.proxy(this.enter, this))\n        this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this))\n      }\n    }\n\n    this.options.selector ?\n      (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :\n      this.fixTitle()\n  }\n\n  Tooltip.prototype.getDefaults = function () {\n    return Tooltip.DEFAULTS\n  }\n\n  Tooltip.prototype.getOptions = function (options) {\n    options = $.extend({}, this.getDefaults(), this.$element.data(), options)\n\n    if (options.delay && typeof options.delay == 'number') {\n      options.delay = {\n        show: options.delay,\n        hide: options.delay\n      }\n    }\n\n    return options\n  }\n\n  Tooltip.prototype.getDelegateOptions = function () {\n    var options  = {}\n    var defaults = this.getDefaults()\n\n    this._options && $.each(this._options, function (key, value) {\n      if (defaults[key] != value) options[key] = value\n    })\n\n    return options\n  }\n\n  Tooltip.prototype.enter = function (obj) {\n    var self = obj instanceof this.constructor ?\n      obj : $(obj.currentTarget).data('bs.' + this.type)\n\n    if (!self) {\n      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())\n      $(obj.currentTarget).data('bs.' + this.type, self)\n    }\n\n    if (obj instanceof $.Event) {\n      self.inState[obj.type == 'focusin' ? 'focus' : 'hover'] = true\n    }\n\n    if (self.tip().hasClass('in') || self.hoverState == 'in') {\n      self.hoverState = 'in'\n      return\n    }\n\n    clearTimeout(self.timeout)\n\n    self.hoverState = 'in'\n\n    if (!self.options.delay || !self.options.delay.show) return self.show()\n\n    self.timeout = setTimeout(function () {\n      if (self.hoverState == 'in') self.show()\n    }, self.options.delay.show)\n  }\n\n  Tooltip.prototype.isInStateTrue = function () {\n    for (var key in this.inState) {\n      if (this.inState[key]) return true\n    }\n\n    return false\n  }\n\n  Tooltip.prototype.leave = function (obj) {\n    var self = obj instanceof this.constructor ?\n      obj : $(obj.currentTarget).data('bs.' + this.type)\n\n    if (!self) {\n      self = new this.constructor(obj.currentTarget, this.getDelegateOptions())\n      $(obj.currentTarget).data('bs.' + this.type, self)\n    }\n\n    if (obj instanceof $.Event) {\n      self.inState[obj.type == 'focusout' ? 'focus' : 'hover'] = false\n    }\n\n    if (self.isInStateTrue()) return\n\n    clearTimeout(self.timeout)\n\n    self.hoverState = 'out'\n\n    if (!self.options.delay || !self.options.delay.hide) return self.hide()\n\n    self.timeout = setTimeout(function () {\n      if (self.hoverState == 'out') self.hide()\n    }, self.options.delay.hide)\n  }\n\n  Tooltip.prototype.show = function () {\n    var e = $.Event('show.bs.' + this.type)\n\n    if (this.hasContent() && this.enabled) {\n      this.$element.trigger(e)\n\n      var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0])\n      if (e.isDefaultPrevented() || !inDom) return\n      var that = this\n\n      var $tip = this.tip()\n\n      var tipId = this.getUID(this.type)\n\n      this.setContent()\n      $tip.attr('id', tipId)\n      this.$element.attr('aria-describedby', tipId)\n\n      if (this.options.animation) $tip.addClass('fade')\n\n      var placement = typeof this.options.placement == 'function' ?\n        this.options.placement.call(this, $tip[0], this.$element[0]) :\n        this.options.placement\n\n      var autoToken = /\\s?auto?\\s?/i\n      var autoPlace = autoToken.test(placement)\n      if (autoPlace) placement = placement.replace(autoToken, '') || 'top'\n\n      $tip\n        .detach()\n        .css({ top: 0, left: 0, display: 'block' })\n        .addClass(placement)\n        .data('bs.' + this.type, this)\n\n      this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element)\n      this.$element.trigger('inserted.bs.' + this.type)\n\n      var pos          = this.getPosition()\n      var actualWidth  = $tip[0].offsetWidth\n      var actualHeight = $tip[0].offsetHeight\n\n      if (autoPlace) {\n        var orgPlacement = placement\n        var viewportDim = this.getPosition(this.$viewport)\n\n        placement = placement == 'bottom' && pos.bottom + actualHeight > viewportDim.bottom ? 'top'    :\n                    placement == 'top'    && pos.top    - actualHeight < viewportDim.top    ? 'bottom' :\n                    placement == 'right'  && pos.right  + actualWidth  > viewportDim.width  ? 'left'   :\n                    placement == 'left'   && pos.left   - actualWidth  < viewportDim.left   ? 'right'  :\n                    placement\n\n        $tip\n          .removeClass(orgPlacement)\n          .addClass(placement)\n      }\n\n      var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight)\n\n      this.applyPlacement(calculatedOffset, placement)\n\n      var complete = function () {\n        var prevHoverState = that.hoverState\n        that.$element.trigger('shown.bs.' + that.type)\n        that.hoverState = null\n\n        if (prevHoverState == 'out') that.leave(that)\n      }\n\n      $.support.transition && this.$tip.hasClass('fade') ?\n        $tip\n          .one('bsTransitionEnd', complete)\n          .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :\n        complete()\n    }\n  }\n\n  Tooltip.prototype.applyPlacement = function (offset, placement) {\n    var $tip   = this.tip()\n    var width  = $tip[0].offsetWidth\n    var height = $tip[0].offsetHeight\n\n    // manually read margins because getBoundingClientRect includes difference\n    var marginTop = parseInt($tip.css('margin-top'), 10)\n    var marginLeft = parseInt($tip.css('margin-left'), 10)\n\n    // we must check for NaN for ie 8/9\n    if (isNaN(marginTop))  marginTop  = 0\n    if (isNaN(marginLeft)) marginLeft = 0\n\n    offset.top  += marginTop\n    offset.left += marginLeft\n\n    // $.fn.offset doesn't round pixel values\n    // so we use setOffset directly with our own function B-0\n    $.offset.setOffset($tip[0], $.extend({\n      using: function (props) {\n        $tip.css({\n          top: Math.round(props.top),\n          left: Math.round(props.left)\n        })\n      }\n    }, offset), 0)\n\n    $tip.addClass('in')\n\n    // check to see if placing tip in new offset caused the tip to resize itself\n    var actualWidth  = $tip[0].offsetWidth\n    var actualHeight = $tip[0].offsetHeight\n\n    if (placement == 'top' && actualHeight != height) {\n      offset.top = offset.top + height - actualHeight\n    }\n\n    var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight)\n\n    if (delta.left) offset.left += delta.left\n    else offset.top += delta.top\n\n    var isVertical          = /top|bottom/.test(placement)\n    var arrowDelta          = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight\n    var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight'\n\n    $tip.offset(offset)\n    this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical)\n  }\n\n  Tooltip.prototype.replaceArrow = function (delta, dimension, isVertical) {\n    this.arrow()\n      .css(isVertical ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')\n      .css(isVertical ? 'top' : 'left', '')\n  }\n\n  Tooltip.prototype.setContent = function () {\n    var $tip  = this.tip()\n    var title = this.getTitle()\n\n    $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title)\n    $tip.removeClass('fade in top bottom left right')\n  }\n\n  Tooltip.prototype.hide = function (callback) {\n    var that = this\n    var $tip = $(this.$tip)\n    var e    = $.Event('hide.bs.' + this.type)\n\n    function complete() {\n      if (that.hoverState != 'in') $tip.detach()\n      if (that.$element) { // TODO: Check whether guarding this code with this `if` is really necessary.\n        that.$element\n          .removeAttr('aria-describedby')\n          .trigger('hidden.bs.' + that.type)\n      }\n      callback && callback()\n    }\n\n    this.$element.trigger(e)\n\n    if (e.isDefaultPrevented()) return\n\n    $tip.removeClass('in')\n\n    $.support.transition && $tip.hasClass('fade') ?\n      $tip\n        .one('bsTransitionEnd', complete)\n        .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :\n      complete()\n\n    this.hoverState = null\n\n    return this\n  }\n\n  Tooltip.prototype.fixTitle = function () {\n    var $e = this.$element\n    if ($e.attr('title') || typeof $e.attr('data-original-title') != 'string') {\n      $e.attr('data-original-title', $e.attr('title') || '').attr('title', '')\n    }\n  }\n\n  Tooltip.prototype.hasContent = function () {\n    return this.getTitle()\n  }\n\n  Tooltip.prototype.getPosition = function ($element) {\n    $element   = $element || this.$element\n\n    var el     = $element[0]\n    var isBody = el.tagName == 'BODY'\n\n    var elRect    = el.getBoundingClientRect()\n    if (elRect.width == null) {\n      // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093\n      elRect = $.extend({}, elRect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top })\n    }\n    var isSvg = window.SVGElement && el instanceof window.SVGElement\n    // Avoid using $.offset() on SVGs since it gives incorrect results in jQuery 3.\n    // See https://github.com/twbs/bootstrap/issues/20280\n    var elOffset  = isBody ? { top: 0, left: 0 } : (isSvg ? null : $element.offset())\n    var scroll    = { scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop() }\n    var outerDims = isBody ? { width: $(window).width(), height: $(window).height() } : null\n\n    return $.extend({}, elRect, scroll, outerDims, elOffset)\n  }\n\n  Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {\n    return placement == 'bottom' ? { top: pos.top + pos.height,   left: pos.left + pos.width / 2 - actualWidth / 2 } :\n           placement == 'top'    ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2 } :\n           placement == 'left'   ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :\n        /* placement == 'right' */ { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width }\n\n  }\n\n  Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {\n    var delta = { top: 0, left: 0 }\n    if (!this.$viewport) return delta\n\n    var viewportPadding = this.options.viewport && this.options.viewport.padding || 0\n    var viewportDimensions = this.getPosition(this.$viewport)\n\n    if (/right|left/.test(placement)) {\n      var topEdgeOffset    = pos.top - viewportPadding - viewportDimensions.scroll\n      var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight\n      if (topEdgeOffset < viewportDimensions.top) { // top overflow\n        delta.top = viewportDimensions.top - topEdgeOffset\n      } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow\n        delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset\n      }\n    } else {\n      var leftEdgeOffset  = pos.left - viewportPadding\n      var rightEdgeOffset = pos.left + viewportPadding + actualWidth\n      if (leftEdgeOffset < viewportDimensions.left) { // left overflow\n        delta.left = viewportDimensions.left - leftEdgeOffset\n      } else if (rightEdgeOffset > viewportDimensions.right) { // right overflow\n        delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset\n      }\n    }\n\n    return delta\n  }\n\n  Tooltip.prototype.getTitle = function () {\n    var title\n    var $e = this.$element\n    var o  = this.options\n\n    title = $e.attr('data-original-title')\n      || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title)\n\n    return title\n  }\n\n  Tooltip.prototype.getUID = function (prefix) {\n    do prefix += ~~(Math.random() * 1000000)\n    while (document.getElementById(prefix))\n    return prefix\n  }\n\n  Tooltip.prototype.tip = function () {\n    if (!this.$tip) {\n      this.$tip = $(this.options.template)\n      if (this.$tip.length != 1) {\n        throw new Error(this.type + ' `template` option must consist of exactly 1 top-level element!')\n      }\n    }\n    return this.$tip\n  }\n\n  Tooltip.prototype.arrow = function () {\n    return (this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow'))\n  }\n\n  Tooltip.prototype.enable = function () {\n    this.enabled = true\n  }\n\n  Tooltip.prototype.disable = function () {\n    this.enabled = false\n  }\n\n  Tooltip.prototype.toggleEnabled = function () {\n    this.enabled = !this.enabled\n  }\n\n  Tooltip.prototype.toggle = function (e) {\n    var self = this\n    if (e) {\n      self = $(e.currentTarget).data('bs.' + this.type)\n      if (!self) {\n        self = new this.constructor(e.currentTarget, this.getDelegateOptions())\n        $(e.currentTarget).data('bs.' + this.type, self)\n      }\n    }\n\n    if (e) {\n      self.inState.click = !self.inState.click\n      if (self.isInStateTrue()) self.enter(self)\n      else self.leave(self)\n    } else {\n      self.tip().hasClass('in') ? self.leave(self) : self.enter(self)\n    }\n  }\n\n  Tooltip.prototype.destroy = function () {\n    var that = this\n    clearTimeout(this.timeout)\n    this.hide(function () {\n      that.$element.off('.' + that.type).removeData('bs.' + that.type)\n      if (that.$tip) {\n        that.$tip.detach()\n      }\n      that.$tip = null\n      that.$arrow = null\n      that.$viewport = null\n      that.$element = null\n    })\n  }\n\n\n  // TOOLTIP PLUGIN DEFINITION\n  // =========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data('bs.tooltip')\n      var options = typeof option == 'object' && option\n\n      if (!data && /destroy|hide/.test(option)) return\n      if (!data) $this.data('bs.tooltip', (data = new Tooltip(this, options)))\n      if (typeof option == 'string') data[option]()\n    })\n  }\n\n  var old = $.fn.tooltip\n\n  $.fn.tooltip             = Plugin\n  $.fn.tooltip.Constructor = Tooltip\n\n\n  // TOOLTIP NO CONFLICT\n  // ===================\n\n  $.fn.tooltip.noConflict = function () {\n    $.fn.tooltip = old\n    return this\n  }\n\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: popover.js v3.3.7\n * http://getbootstrap.com/javascript/#popovers\n * ========================================================================\n * Copyright 2011-2016 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // POPOVER PUBLIC CLASS DEFINITION\n  // ===============================\n\n  var Popover = function (element, options) {\n    this.init('popover', element, options)\n  }\n\n  if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js')\n\n  Popover.VERSION  = '3.3.7'\n\n  Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {\n    placement: 'right',\n    trigger: 'click',\n    content: '',\n    template: '<div class=\"popover\" role=\"tooltip\"><div class=\"arrow\"></div><h3 class=\"popover-title\"></h3><div class=\"popover-content\"></div></div>'\n  })\n\n\n  // NOTE: POPOVER EXTENDS tooltip.js\n  // ================================\n\n  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype)\n\n  Popover.prototype.constructor = Popover\n\n  Popover.prototype.getDefaults = function () {\n    return Popover.DEFAULTS\n  }\n\n  Popover.prototype.setContent = function () {\n    var $tip    = this.tip()\n    var title   = this.getTitle()\n    var content = this.getContent()\n\n    $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title)\n    $tip.find('.popover-content').children().detach().end()[ // we use append for html objects to maintain js events\n      this.options.html ? (typeof content == 'string' ? 'html' : 'append') : 'text'\n    ](content)\n\n    $tip.removeClass('fade top bottom left right in')\n\n    // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do\n    // this manually by checking the contents.\n    if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide()\n  }\n\n  Popover.prototype.hasContent = function () {\n    return this.getTitle() || this.getContent()\n  }\n\n  Popover.prototype.getContent = function () {\n    var $e = this.$element\n    var o  = this.options\n\n    return $e.attr('data-content')\n      || (typeof o.content == 'function' ?\n            o.content.call($e[0]) :\n            o.content)\n  }\n\n  Popover.prototype.arrow = function () {\n    return (this.$arrow = this.$arrow || this.tip().find('.arrow'))\n  }\n\n\n  // POPOVER PLUGIN DEFINITION\n  // =========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data('bs.popover')\n      var options = typeof option == 'object' && option\n\n      if (!data && /destroy|hide/.test(option)) return\n      if (!data) $this.data('bs.popover', (data = new Popover(this, options)))\n      if (typeof option == 'string') data[option]()\n    })\n  }\n\n  var old = $.fn.popover\n\n  $.fn.popover             = Plugin\n  $.fn.popover.Constructor = Popover\n\n\n  // POPOVER NO CONFLICT\n  // ===================\n\n  $.fn.popover.noConflict = function () {\n    $.fn.popover = old\n    return this\n  }\n\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: scrollspy.js v3.3.7\n * http://getbootstrap.com/javascript/#scrollspy\n * ========================================================================\n * Copyright 2011-2016 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // SCROLLSPY CLASS DEFINITION\n  // ==========================\n\n  function ScrollSpy(element, options) {\n    this.$body          = $(document.body)\n    this.$scrollElement = $(element).is(document.body) ? $(window) : $(element)\n    this.options        = $.extend({}, ScrollSpy.DEFAULTS, options)\n    this.selector       = (this.options.target || '') + ' .nav li > a'\n    this.offsets        = []\n    this.targets        = []\n    this.activeTarget   = null\n    this.scrollHeight   = 0\n\n    this.$scrollElement.on('scroll.bs.scrollspy', $.proxy(this.process, this))\n    this.refresh()\n    this.process()\n  }\n\n  ScrollSpy.VERSION  = '3.3.7'\n\n  ScrollSpy.DEFAULTS = {\n    offset: 10\n  }\n\n  ScrollSpy.prototype.getScrollHeight = function () {\n    return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight)\n  }\n\n  ScrollSpy.prototype.refresh = function () {\n    var that          = this\n    var offsetMethod  = 'offset'\n    var offsetBase    = 0\n\n    this.offsets      = []\n    this.targets      = []\n    this.scrollHeight = this.getScrollHeight()\n\n    if (!$.isWindow(this.$scrollElement[0])) {\n      offsetMethod = 'position'\n      offsetBase   = this.$scrollElement.scrollTop()\n    }\n\n    this.$body\n      .find(this.selector)\n      .map(function () {\n        var $el   = $(this)\n        var href  = $el.data('target') || $el.attr('href')\n        var $href = /^#./.test(href) && $(href)\n\n        return ($href\n          && $href.length\n          && $href.is(':visible')\n          && [[$href[offsetMethod]().top + offsetBase, href]]) || null\n      })\n      .sort(function (a, b) { return a[0] - b[0] })\n      .each(function () {\n        that.offsets.push(this[0])\n        that.targets.push(this[1])\n      })\n  }\n\n  ScrollSpy.prototype.process = function () {\n    var scrollTop    = this.$scrollElement.scrollTop() + this.options.offset\n    var scrollHeight = this.getScrollHeight()\n    var maxScroll    = this.options.offset + scrollHeight - this.$scrollElement.height()\n    var offsets      = this.offsets\n    var targets      = this.targets\n    var activeTarget = this.activeTarget\n    var i\n\n    if (this.scrollHeight != scrollHeight) {\n      this.refresh()\n    }\n\n    if (scrollTop >= maxScroll) {\n      return activeTarget != (i = targets[targets.length - 1]) && this.activate(i)\n    }\n\n    if (activeTarget && scrollTop < offsets[0]) {\n      this.activeTarget = null\n      return this.clear()\n    }\n\n    for (i = offsets.length; i--;) {\n      activeTarget != targets[i]\n        && scrollTop >= offsets[i]\n        && (offsets[i + 1] === undefined || scrollTop < offsets[i + 1])\n        && this.activate(targets[i])\n    }\n  }\n\n  ScrollSpy.prototype.activate = function (target) {\n    this.activeTarget = target\n\n    this.clear()\n\n    var selector = this.selector +\n      '[data-target=\"' + target + '\"],' +\n      this.selector + '[href=\"' + target + '\"]'\n\n    var active = $(selector)\n      .parents('li')\n      .addClass('active')\n\n    if (active.parent('.dropdown-menu').length) {\n      active = active\n        .closest('li.dropdown')\n        .addClass('active')\n    }\n\n    active.trigger('activate.bs.scrollspy')\n  }\n\n  ScrollSpy.prototype.clear = function () {\n    $(this.selector)\n      .parentsUntil(this.options.target, '.active')\n      .removeClass('active')\n  }\n\n\n  // SCROLLSPY PLUGIN DEFINITION\n  // ===========================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data('bs.scrollspy')\n      var options = typeof option == 'object' && option\n\n      if (!data) $this.data('bs.scrollspy', (data = new ScrollSpy(this, options)))\n      if (typeof option == 'string') data[option]()\n    })\n  }\n\n  var old = $.fn.scrollspy\n\n  $.fn.scrollspy             = Plugin\n  $.fn.scrollspy.Constructor = ScrollSpy\n\n\n  // SCROLLSPY NO CONFLICT\n  // =====================\n\n  $.fn.scrollspy.noConflict = function () {\n    $.fn.scrollspy = old\n    return this\n  }\n\n\n  // SCROLLSPY DATA-API\n  // ==================\n\n  $(window).on('load.bs.scrollspy.data-api', function () {\n    $('[data-spy=\"scroll\"]').each(function () {\n      var $spy = $(this)\n      Plugin.call($spy, $spy.data())\n    })\n  })\n\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: tab.js v3.3.7\n * http://getbootstrap.com/javascript/#tabs\n * ========================================================================\n * Copyright 2011-2016 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // TAB CLASS DEFINITION\n  // ====================\n\n  var Tab = function (element) {\n    // jscs:disable requireDollarBeforejQueryAssignment\n    this.element = $(element)\n    // jscs:enable requireDollarBeforejQueryAssignment\n  }\n\n  Tab.VERSION = '3.3.7'\n\n  Tab.TRANSITION_DURATION = 150\n\n  Tab.prototype.show = function () {\n    var $this    = this.element\n    var $ul      = $this.closest('ul:not(.dropdown-menu)')\n    var selector = $this.data('target')\n\n    if (!selector) {\n      selector = $this.attr('href')\n      selector = selector && selector.replace(/.*(?=#[^\\s]*$)/, '') // strip for ie7\n    }\n\n    if ($this.parent('li').hasClass('active')) return\n\n    var $previous = $ul.find('.active:last a')\n    var hideEvent = $.Event('hide.bs.tab', {\n      relatedTarget: $this[0]\n    })\n    var showEvent = $.Event('show.bs.tab', {\n      relatedTarget: $previous[0]\n    })\n\n    $previous.trigger(hideEvent)\n    $this.trigger(showEvent)\n\n    if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return\n\n    var $target = $(selector)\n\n    this.activate($this.closest('li'), $ul)\n    this.activate($target, $target.parent(), function () {\n      $previous.trigger({\n        type: 'hidden.bs.tab',\n        relatedTarget: $this[0]\n      })\n      $this.trigger({\n        type: 'shown.bs.tab',\n        relatedTarget: $previous[0]\n      })\n    })\n  }\n\n  Tab.prototype.activate = function (element, container, callback) {\n    var $active    = container.find('> .active')\n    var transition = callback\n      && $.support.transition\n      && ($active.length && $active.hasClass('fade') || !!container.find('> .fade').length)\n\n    function next() {\n      $active\n        .removeClass('active')\n        .find('> .dropdown-menu > .active')\n          .removeClass('active')\n        .end()\n        .find('[data-toggle=\"tab\"]')\n          .attr('aria-expanded', false)\n\n      element\n        .addClass('active')\n        .find('[data-toggle=\"tab\"]')\n          .attr('aria-expanded', true)\n\n      if (transition) {\n        element[0].offsetWidth // reflow for transition\n        element.addClass('in')\n      } else {\n        element.removeClass('fade')\n      }\n\n      if (element.parent('.dropdown-menu').length) {\n        element\n          .closest('li.dropdown')\n            .addClass('active')\n          .end()\n          .find('[data-toggle=\"tab\"]')\n            .attr('aria-expanded', true)\n      }\n\n      callback && callback()\n    }\n\n    $active.length && transition ?\n      $active\n        .one('bsTransitionEnd', next)\n        .emulateTransitionEnd(Tab.TRANSITION_DURATION) :\n      next()\n\n    $active.removeClass('in')\n  }\n\n\n  // TAB PLUGIN DEFINITION\n  // =====================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this = $(this)\n      var data  = $this.data('bs.tab')\n\n      if (!data) $this.data('bs.tab', (data = new Tab(this)))\n      if (typeof option == 'string') data[option]()\n    })\n  }\n\n  var old = $.fn.tab\n\n  $.fn.tab             = Plugin\n  $.fn.tab.Constructor = Tab\n\n\n  // TAB NO CONFLICT\n  // ===============\n\n  $.fn.tab.noConflict = function () {\n    $.fn.tab = old\n    return this\n  }\n\n\n  // TAB DATA-API\n  // ============\n\n  var clickHandler = function (e) {\n    e.preventDefault()\n    Plugin.call($(this), 'show')\n  }\n\n  $(document)\n    .on('click.bs.tab.data-api', '[data-toggle=\"tab\"]', clickHandler)\n    .on('click.bs.tab.data-api', '[data-toggle=\"pill\"]', clickHandler)\n\n}(jQuery);\n\n/* ========================================================================\n * Bootstrap: affix.js v3.3.7\n * http://getbootstrap.com/javascript/#affix\n * ========================================================================\n * Copyright 2011-2016 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n * ======================================================================== */\n\n\n+function ($) {\n  'use strict';\n\n  // AFFIX CLASS DEFINITION\n  // ======================\n\n  var Affix = function (element, options) {\n    this.options = $.extend({}, Affix.DEFAULTS, options)\n\n    this.$target = $(this.options.target)\n      .on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this))\n      .on('click.bs.affix.data-api',  $.proxy(this.checkPositionWithEventLoop, this))\n\n    this.$element     = $(element)\n    this.affixed      = null\n    this.unpin        = null\n    this.pinnedOffset = null\n\n    this.checkPosition()\n  }\n\n  Affix.VERSION  = '3.3.7'\n\n  Affix.RESET    = 'affix affix-top affix-bottom'\n\n  Affix.DEFAULTS = {\n    offset: 0,\n    target: window\n  }\n\n  Affix.prototype.getState = function (scrollHeight, height, offsetTop, offsetBottom) {\n    var scrollTop    = this.$target.scrollTop()\n    var position     = this.$element.offset()\n    var targetHeight = this.$target.height()\n\n    if (offsetTop != null && this.affixed == 'top') return scrollTop < offsetTop ? 'top' : false\n\n    if (this.affixed == 'bottom') {\n      if (offsetTop != null) return (scrollTop + this.unpin <= position.top) ? false : 'bottom'\n      return (scrollTop + targetHeight <= scrollHeight - offsetBottom) ? false : 'bottom'\n    }\n\n    var initializing   = this.affixed == null\n    var colliderTop    = initializing ? scrollTop : position.top\n    var colliderHeight = initializing ? targetHeight : height\n\n    if (offsetTop != null && scrollTop <= offsetTop) return 'top'\n    if (offsetBottom != null && (colliderTop + colliderHeight >= scrollHeight - offsetBottom)) return 'bottom'\n\n    return false\n  }\n\n  Affix.prototype.getPinnedOffset = function () {\n    if (this.pinnedOffset) return this.pinnedOffset\n    this.$element.removeClass(Affix.RESET).addClass('affix')\n    var scrollTop = this.$target.scrollTop()\n    var position  = this.$element.offset()\n    return (this.pinnedOffset = position.top - scrollTop)\n  }\n\n  Affix.prototype.checkPositionWithEventLoop = function () {\n    setTimeout($.proxy(this.checkPosition, this), 1)\n  }\n\n  Affix.prototype.checkPosition = function () {\n    if (!this.$element.is(':visible')) return\n\n    var height       = this.$element.height()\n    var offset       = this.options.offset\n    var offsetTop    = offset.top\n    var offsetBottom = offset.bottom\n    var scrollHeight = Math.max($(document).height(), $(document.body).height())\n\n    if (typeof offset != 'object')         offsetBottom = offsetTop = offset\n    if (typeof offsetTop == 'function')    offsetTop    = offset.top(this.$element)\n    if (typeof offsetBottom == 'function') offsetBottom = offset.bottom(this.$element)\n\n    var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom)\n\n    if (this.affixed != affix) {\n      if (this.unpin != null) this.$element.css('top', '')\n\n      var affixType = 'affix' + (affix ? '-' + affix : '')\n      var e         = $.Event(affixType + '.bs.affix')\n\n      this.$element.trigger(e)\n\n      if (e.isDefaultPrevented()) return\n\n      this.affixed = affix\n      this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null\n\n      this.$element\n        .removeClass(Affix.RESET)\n        .addClass(affixType)\n        .trigger(affixType.replace('affix', 'affixed') + '.bs.affix')\n    }\n\n    if (affix == 'bottom') {\n      this.$element.offset({\n        top: scrollHeight - height - offsetBottom\n      })\n    }\n  }\n\n\n  // AFFIX PLUGIN DEFINITION\n  // =======================\n\n  function Plugin(option) {\n    return this.each(function () {\n      var $this   = $(this)\n      var data    = $this.data('bs.affix')\n      var options = typeof option == 'object' && option\n\n      if (!data) $this.data('bs.affix', (data = new Affix(this, options)))\n      if (typeof option == 'string') data[option]()\n    })\n  }\n\n  var old = $.fn.affix\n\n  $.fn.affix             = Plugin\n  $.fn.affix.Constructor = Affix\n\n\n  // AFFIX NO CONFLICT\n  // =================\n\n  $.fn.affix.noConflict = function () {\n    $.fn.affix = old\n    return this\n  }\n\n\n  // AFFIX DATA-API\n  // ==============\n\n  $(window).on('load', function () {\n    $('[data-spy=\"affix\"]').each(function () {\n      var $spy = $(this)\n      var data = $spy.data()\n\n      data.offset = data.offset || {}\n\n      if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom\n      if (data.offsetTop    != null) data.offset.top    = data.offsetTop\n\n      Plugin.call($spy, data)\n    })\n  })\n\n}(jQuery);\n\n+function ($) {\n  'use strict';\n\n  // SIDEPANEL PUBLIC CLASS DEFINITION\n  // ==================================\n\n  var SidePanel = function(element, options) {\n    var isForcedHamburgerMode = $('html, body').hasClass('force-hamburger');\n\n    this.options = $.extend({}, SidePanel.DEFAULTS, options);\n    this.isVisible = false;\n\n    this.$element = $(element);\n    this.$navbarHeader = $(element).siblings('.navbar-header');\n    this.$container = this.$element.parents('.navbar');\n    this.$toggle = this.$navbarHeader.find('.navbar-toggle');\n\n    this.animationEndEvent = _whichAnimationEndEvent();\n\n    $(window).resize(function() {\n      if(this.isVisible && window.innerWidth >= SidePanel.TOGGLE_BREAKPOINT && !isForcedHamburgerMode) {\n        this.hide({\n          skipAnimation: true\n        });\n      } else if(this.isVisible) {\n        this.setDimensions();\n      }\n    }.bind(this));\n\n    this.setDimensions();\n\n    if(this.options.toggle) this.toggle();\n  }\n\n  SidePanel.TOGGLE_BREAKPOINT = 992; // px\n  SidePanel.MOBILE_BREAKPOINT = 480; // px\n  SidePanel.DESKTOP_WIDTH = 400; // px\n  SidePanel.MOBILE_WIDTH = 270; // px\n  SidePanel.SIDEPANEL_PADDING = 38; // px\n  SidePanel.CLOSE_DURATION = 270; // ms\n  SidePanel.MENU_ITEM_ANIMATION_DELAY = 17; // ms\n\n  SidePanel.DEFAULTS = {};\n\n  SidePanel.prototype.setDimensions = function() {\n    var navbarWidth = this._getNavBarWidth();\n    var navScrollHeight = this.$element.find('.nav')[0].scrollHeight;\n    // NOTE: expecting .navbar-brand to be wrapped in <li>\n    var navBranding = this.$element.find('.navbar-brand').parent();\n    \n    var toggleGutter; \n    if(this.$toggleClone) {\n      toggleGutter = window.innerWidth - this.$toggleClone.position().left;\n    } else {\n      toggleGutter = window.innerWidth - this.$toggle.position().left;\n    }\n\n    if(_isTouchDevice()) {\n      this.$element.css({'width': '100%'});\n\n      // force iOS to recalc the panel height to prevent a bug with scrolling on orientation change\n      this.$element.css('overflow', 'hidden').height();\n      this.$element.css('overflow', 'auto');\n    } else {\n      // put the brand at the bottom of the panel unless the panel is large, then just put in the verticle flow\n      if(navScrollHeight + navBranding.outerHeight(true) + SidePanel.SIDEPANEL_PADDING < window.innerHeight) {\n        navBranding.addClass('fixed-bottom');\n      } else {\n        navBranding.removeClass('fixed-bottom');\n      }\n      if(window.innerWidth >= SidePanel.MOBILE_BREAKPOINT) {\n        this.$element.css({width: (toggleGutter + SidePanel.DESKTOP_WIDTH) + 'px'});\n      } else {\n        this.$element.css({width: (toggleGutter + SidePanel.MOBILE_WIDTH) + 'px'});\n      } \n    } \n\n    if(this.$toggleClone) {\n      var curLeftPos = this.$toggle.position().left;\n      this.$toggleClone.css({\n        'left': curLeftPos + 'px', \n        'top': 0\n      });\n    }\n  }\n\n  SidePanel.prototype.toggle = function() {\n    this[this.isVisible ? 'hide' : 'show']();\n  }\n\n  SidePanel.prototype.show = function() {\n    if(this.isTransitioning) {\n      return;\n    }\n\n    this.isVisible = true;\n    this.$toggle.removeClass('collapsed');\n\n    $('body').addClass('sidepanel-active');\n    this.$container.addClass('navbar-sidepanel');\n\n    // if branding is not present, add it in\n    if(!this.$element.find('.navbar-brand').length) {\n      this._generateBrand();\n    }\n\n    // dynamically apply animation delay to create swinging effect\n    if(this.animationEndEvent) {\n      this.$element.find('li a, .divider').each(function(i,e) {\n        $(e).css({'animation-delay': i * SidePanel.MENU_ITEM_ANIMATION_DELAY + 'ms'})\n      });\n    }\n\n    // create a backdrop\n    this.$container.prepend('<div class=\"sidepanel-backdrop\"></div>');\n    this.$container.on('click.sp.sidepanel', '.sidepanel-backdrop', function() {\n      this.hide();\n    }.bind(this));\n    \n    if(this.animationEndEvent) {\n      this.$element.one(this.animationEndEvent, function() {\n        this.isTransitioning = false;\n        this.$element.removeClass('animate-in');\n        this.$element.addClass('open');\n      }.bind(this));\n\n      this.isTransitioning = true;\n      this.$element.addClass('animate-in');\n    } else {\n      this.$element.addClass('open');\n    }\n\n    this.setDimensions();\n\n    // if the entire header is not fixed we handle the toggle button differently\n    // we don't want the toggle button to appear in the middle of the sidepanel\n    // so we clone the current toggle and affix the clone to the top-right of the view\n    if(this.$container.css('position') !== 'fixed') {\n      var curLeftPos = this.$toggle.position().left;\n      this.$toggleClone = this.$toggle.clone();\n      this.$toggle.css({\n        'opacity': 0\n      });\n      this.$toggleClone.css({\n        'display': 'none',\n        'position': 'fixed', \n        'left': curLeftPos + 'px', \n        'top': 0\n      });\n      this.$toggle.after(this.$toggleClone);\n      this.$toggleClone.show();\n    }\n  }\n\n  SidePanel.prototype.hide = function(options) {\n    var options = options || {};\n\n    if(this.isTransitioning) {\n      return;\n    }\n\n    this.isVisible = false;\n    this.$toggle.addClass('collapsed');\n\n    if(this.$toggleClone) {\n      this.$toggleClone.remove();\n      this.$toggle.css({\n        'opacity': 1\n      });\n      delete this.$toggleClone;\n    }\n\n    if(this.animationEndEvent && !options.skipAnimation) {\n      this.$element.one(this.animationEndEvent, function() {\n        this.isTransitioning = false;\n        this.$element.removeClass('animate-out');\n        complete.call(this, null);\n      }.bind(this));\n\n      this.isTransitioning = true;\n      this.$container.find('.sidepanel-backdrop').fadeOut(SidePanel.CLOSE_DURATION);\n      this.$element.addClass('animate-out');\n    } else {\n      complete.call(this, null);\n    }\n    \n    function complete() {\n      // remove some elements we created\n      this.$container.find('._generated-nav-brand').remove();\n      this.$container.find('.sidepanel-backdrop').remove();\n\n      this.$element\n        .css({width: 'auto'})\n        .removeClass('open');\n\n      this.$container.removeClass('navbar-sidepanel');\n      $('body').removeClass('sidepanel-active');\n    }\n  }\n\n  SidePanel.prototype._getNavBarWidth = function() {\n    return this.$element.outerWidth(true);\n  }\n\n  SidePanel.prototype._generateBrand = function() {\n    var currentTitleBrand = this.$container.find('.navbar-brand').clone();\n    var brandListItem = $('<li class=\"_generated-nav-brand\">').append(currentTitleBrand);\n    this.$element.find('.nav').append(brandListItem);\n  }\n\n  function _whichAnimationEndEvent(){\n    /* similar to Modernizr */\n    var a;\n    var el = document.createElement('fakeelement');\n    var animationEndEvents = {\n      'animation':'animationend',\n      'OAnimation':'oAnimationEnd',\n      'MozAnimation':'animationend',\n      'WebkitAnimation':'webkitAnimationEnd'\n    }\n\n    for(a in animationEndEvents){\n      if(el.style[a] !== undefined){\n        return animationEndEvents[a];\n      }\n    }\n  }\n\n  function _isTouchDevice() {\n    return 'ontouchstart' in window // works on most browsers \n        || 'onmsgesturechange' in window; // works on ie10\n  };\n\n  // SIDEPANEL PLUGIN DEFINITION\n  // ============================\n\n  function Plugin(option) {\n    return this.each(function() {\n      var $this = $(this);\n      var data = $this.data('sp.sidepanel');\n      var options = $.extend({}, SidePanel.DEFAULTS, $this.data(), typeof option == 'object' && option);\n\n      if (!data && options.toggle && /show|hide/.test(option)) options.toggle = false;\n      if (!data) $this.data('sp.sidepanel', (data = new SidePanel(this, options)));\n      if (typeof option == 'string') data[option]();\n    });\n  }\n\n  var old = $.fn.spSidepanel;\n\n  $.fn.spSidepanel = Plugin;\n  $.fn.spSidepanel.Constructor = SidePanel;\n\n  // SIDEPANEL NO CONFLICT\n  // ======================\n\n  $.fn.spSidepanel.noConflict = function () {\n    $.fn.spSidepanel = old;\n    return this;\n  }\n\n  // SIDEPANEL DATA-API\n  // ===================\n\n  $(document).off('click.sp.sidepanel').on('click.sp.sidepanel', '[data-toggle=sidepanel]', function(e) {\n    var $this = $(this);\n\n    if(!$this.attr('data-target')) {\n      e.preventDefault();\n    }\n\n    var $target = $($this.attr('data-target'));\n    var data = $target.data('sp.sidepanel');\n    var option = data ? 'toggle' : $this.data();\n\n    Plugin.call($target, option);\n  });\n\n}(jQuery);\n\n+function ($) {\n  'use strict';\n\n  // BUTTONSCROLL PUBLIC CLASS DEFINITION\n  // ==================================\n\n  var ButtonScroll = function(element, options) {\n    this.options = $.extend({}, ButtonScroll.DEFAULTS, options);\n    this.$element = $(element);\n\n    this.scroll();\n  }\n\n  // CONSTANTS AND DEFAULTS\n  // ============================\n\n  ButtonScroll.ANIMATION_DURATION = 500;\n  ButtonScroll.BODY = $('html, body');\n\n  ButtonScroll.DEFAULTS = {\n    'body': ButtonScroll.BODY,\n    'animationDuration': ButtonScroll.ANIMATION_DURATION\n  };\n\n  ButtonScroll.prototype.scroll = function() {\n    var target = $('[name=\"' + $.attr(this.$element[0], 'href').substr(1) + '\"]');\n    this.options.body.animate({\n      scrollTop: target.offset().top\n    }, this.options.animationDuration);\n  }\n\n  // BUTTONSCROLL PLUGIN DEFINITION\n  // ============================\n\n  function Plugin(option) {\n    return this.each(function() {\n      var $this = $(this);\n      var data = $this.data('sp.buttonscroll');\n      var options = $.extend({}, ButtonScroll.DEFAULTS, $this.data(), typeof option == 'object' && option);\n\n      if (!data) $this.data('sp.buttonscroll', (data = new ButtonScroll(this, options)));\n      if (typeof option == 'string') data[option]();\n    });\n  }\n\n  var oldFn = $.fn.spButtonScroll;\n\n  $.fn.spButtonScroll = Plugin;\n  $.fn.spButtonScroll.Constructor = ButtonScroll;\n\n  // BUTTONSCROLL NO CONFLICT\n  // ======================\n\n  $.fn.spButtonScroll.noConflict = function () {\n    $.fn.spButtonScroll = oldFn;\n    return this;\n  }\n\n  // BUTTONSCROLL DATA-API\n  // ===================\n\n  $(document).off('click.sp.buttonscroll').on('click.sp.buttonscroll', 'a.btn-scroll', function(e) {\n    var $this = $(this);\n\n    e.preventDefault();\n    var data = $this.data('sp.buttonscroll');\n\n    var options = data ? 'scroll' : $this.data();\n    Plugin.call($this, options);\n  });\n\n}(jQuery);\n\n"
    },
    303: function(n, e, t) {
        "use strict";
        t(0)(t(304))
    },
    304: function(n, e) {
        n.exports = "/** Globals PubSub */\n\nspweb.modal = (function ($, utils, pubSub) {\n  /**\n   * @deprecated - We will transition to bootstrap modal as soon as possible.\n   *\n   * This module is responsible for modal display -- this is strictly iframed youtube embeds right now.\n   * It adds a click handler to elements with the specified\n   * css hook. The handler will open the modal on click of the element.\n   *\n   * @module spweb/modal\n   * @requires jQuery\n   * @requires spweb.utils\n   * @requires PubSub\n   */\n\n  'use strict';\n\n  var exports = {};\n\n  exports.init = function () {\n\n    $(document).on('click.modal', '[data-open=\"modal\"]', function(e) {\n      var youtubeId = $(this).data('youtube-id'),\n        modalYouttube;\n\n      e.preventDefault();\n\n      modalYouttube = $(\n        '<div class=\"modal\">' +\n          '<div class=\"modal-dialog modal-lg\">' +\n            '<div class=\"modal-content\">' +\n              '<div class=\"embed-responsive embed-responsive-16by9\">' +\n                '<iframe class=\"embed-responsive-item\" src=\"//www.youtube.com/embed/' + youtubeId + '?modestbranding=1&rel=0&autoplay=1&controls=1\" frameborder=\"0\" allowfullscreen></iframe>' +\n              '</div>' +\n            '</div>' +\n          '</div>' +\n        '</div>'\n      );\n\n      $('body').append(modalYouttube);\n\n      // We publish the foreground_video_play event. Any background videos - e.g. the hero video\n      // can subscribe to this. It is indended that a background video will pause when a foreground\n      // video starts playing.\n      pubSub.publish('foreground_video_play');\n\n      modalYouttube.click(function() {\n\n        // When we click the background to hide the modal video, we raise the foreground_video_stop\n        // event. Any background videos - e.g. the hero video can subscribe to this. It is indended\n        // that a background video will start playing when a foreground video stops playing.\n        pubSub.publish('foreground_video_stop');\n\n        modalYouttube.remove();\n      });\n\n      // This is the bootstrap event that should fire when the modal is hidden. However, it doesn't\n      // fire when we click the modal background (above). This is because we short-cut the modal\n      // close behaviour by just removing it from the DOM. I don't know if there is another method\n      // of closing the modal (the escape key doesn't seem to work), but I've left this in in case\n      // there's a edge-case method I don't know about.\n      modalYouttube.on('hidden.bs.modal', function() {\n        pubSub.publish('foreground_video_stop');\n      });\n\n    });\n\n    // If we have the autoplay=1 querystring parameter set, we select the first modal on the page,\n    // and automatically pop it up. I don't think there are currently any pages where we have more\n    // than one modal, so this will do for now. I the future this could be extended to allow the\n    // correct autoplay modal to be specified in the url.\n    if (utils.getQueryParameter('autoplay') === '1') {\n      var firstModal = $('[data-open=\"modal\"]').first();\n      if (firstModal.length > 0) {\n        firstModal.click();\n      }\n    }\n\n  };\n\n  return exports;\n\n}(jQuery, spweb.utils, PubSub));\n"
    },
    322: function(n, e, t) {
        "use strict";
        t(0)(t(323))
    },
    323: function(n, e) {
        n.exports = '/*!\n * jQuery Validation Plugin 1.11.1\n *\n * http://bassistance.de/jquery-plugins/jquery-plugin-validation/\n * http://docs.jquery.com/Plugins/Validation\n *\n * Copyright 2013 Jrn Zaefferer\n * Released under the MIT license:\n *   http://www.opensource.org/licenses/mit-license.php\n */\n\n(function($) {\n\n  $.extend($.fn, {\n    // http://docs.jquery.com/Plugins/Validation/validate\n    validate: function( options ) {\n\n      // if nothing is selected, return nothing; can\'t chain anyway\n      if ( !this.length ) {\n        if ( options && options.debug && window.console ) {\n          console.warn( "Nothing selected, can\'t validate, returning nothing." );\n        }\n        return;\n      }\n\n      // check if a validator for this form was already created\n      var validator = $.data( this[0], "validator" );\n      if ( validator ) {\n        return validator;\n      }\n\n      // Add novalidate tag if HTML5.\n      this.attr( "novalidate", "novalidate" );\n\n      validator = new $.validator( options, this[0] );\n      $.data( this[0], "validator", validator );\n\n      if ( validator.settings.onsubmit ) {\n\n        this.validateDelegate( ":submit", "click", function( event ) {\n          if ( validator.settings.submitHandler ) {\n            validator.submitButton = event.target;\n          }\n          // allow suppressing validation by adding a cancel class to the submit button\n          if ( $(event.target).hasClass("cancel") ) {\n            validator.cancelSubmit = true;\n          }\n\n          // allow suppressing validation by adding the html5 formnovalidate attribute to the submit button\n          if ( $(event.target).attr("formnovalidate") !== undefined ) {\n            validator.cancelSubmit = true;\n          }\n        });\n\n        // validate the form on submit\n        this.submit( function( event ) {\n          if ( validator.settings.debug ) {\n            // prevent form submit to be able to see console output\n            event.preventDefault();\n          }\n          function handle() {\n            var hidden;\n            if ( validator.settings.submitHandler ) {\n              if ( validator.submitButton ) {\n                // insert a hidden input as a replacement for the missing submit button\n                hidden = $("<input type=\'hidden\'/>").attr("name", validator.submitButton.name).val( $(validator.submitButton).val() ).appendTo(validator.currentForm);\n              }\n              validator.settings.submitHandler.call( validator, validator.currentForm, event );\n              if ( validator.submitButton ) {\n                // and clean up afterwards; thanks to no-block-scope, hidden can be referenced\n                hidden.remove();\n              }\n              return false;\n            }\n            return true;\n          }\n\n          // prevent submit for invalid forms or custom submit handlers\n          if ( validator.cancelSubmit ) {\n            validator.cancelSubmit = false;\n            return handle();\n          }\n          if ( validator.form() ) {\n            if ( validator.pendingRequest ) {\n              validator.formSubmitted = true;\n              return false;\n            }\n            return handle();\n          } else {\n            validator.focusInvalid();\n            return false;\n          }\n        });\n      }\n\n      return validator;\n    },\n    // http://docs.jquery.com/Plugins/Validation/valid\n    valid: function() {\n      if ( $(this[0]).is("form")) {\n        return this.validate().form();\n      } else {\n        var valid = true;\n        var validator = $(this[0].form).validate();\n        this.each(function() {\n          valid = valid && validator.element(this);\n        });\n        return valid;\n      }\n    },\n    // attributes: space seperated list of attributes to retrieve and remove\n    removeAttrs: function( attributes ) {\n      var result = {},\n        $element = this;\n      $.each(attributes.split(/\\s/), function( index, value ) {\n        result[value] = $element.attr(value);\n        $element.removeAttr(value);\n      });\n      return result;\n    },\n    // http://docs.jquery.com/Plugins/Validation/rules\n    rules: function( command, argument ) {\n      var element = this[0];\n\n      if ( command ) {\n        var settings = $.data(element.form, "validator").settings;\n        var staticRules = settings.rules;\n        var existingRules = $.validator.staticRules(element);\n        switch(command) {\n          case "add":\n            $.extend(existingRules, $.validator.normalizeRule(argument));\n            // remove messages from rules, but allow them to be set separetely\n            delete existingRules.messages;\n            staticRules[element.name] = existingRules;\n            if ( argument.messages ) {\n              settings.messages[element.name] = $.extend( settings.messages[element.name], argument.messages );\n            }\n            break;\n          case "remove":\n            if ( !argument ) {\n              delete staticRules[element.name];\n              return existingRules;\n            }\n            var filtered = {};\n            $.each(argument.split(/\\s/), function( index, method ) {\n              filtered[method] = existingRules[method];\n              delete existingRules[method];\n            });\n            return filtered;\n        }\n      }\n\n      var data = $.validator.normalizeRules(\n        $.extend(\n          {},\n          $.validator.classRules(element),\n          $.validator.attributeRules(element),\n          $.validator.dataRules(element),\n          $.validator.staticRules(element)\n        ), element);\n\n      // make sure required is at front\n      if ( data.required ) {\n        var param = data.required;\n        delete data.required;\n        data = $.extend({required: param}, data);\n      }\n\n      return data;\n    }\n  });\n\n// Custom selectors\n  $.extend($.expr[":"], {\n    // http://docs.jquery.com/Plugins/Validation/blank\n    blank: function( a ) { return !$.trim("" + $(a).val()); },\n    // http://docs.jquery.com/Plugins/Validation/filled\n    filled: function( a ) { return !!$.trim("" + $(a).val()); },\n    // http://docs.jquery.com/Plugins/Validation/unchecked\n    unchecked: function( a ) { return !$(a).prop("checked"); }\n  });\n\n// constructor for validator\n  $.validator = function( options, form ) {\n    this.settings = $.extend( true, {}, $.validator.defaults, options );\n    this.currentForm = form;\n    this.init();\n  };\n\n  $.validator.format = function( source, params ) {\n    if ( arguments.length === 1 ) {\n      return function() {\n        var args = $.makeArray(arguments);\n        args.unshift(source);\n        return $.validator.format.apply( this, args );\n      };\n    }\n    if ( arguments.length > 2 && params.constructor !== Array  ) {\n      params = $.makeArray(arguments).slice(1);\n    }\n    if ( params.constructor !== Array ) {\n      params = [ params ];\n    }\n    $.each(params, function( i, n ) {\n      source = source.replace( new RegExp("\\\\{" + i + "\\\\}", "g"), function() {\n        return n;\n      });\n    });\n    return source;\n  };\n\n  $.extend($.validator, {\n\n    defaults: {\n      messages: {},\n      groups: {},\n      rules: {},\n      errorClass: "error",\n      validClass: "valid",\n      errorElement: "label",\n      focusInvalid: true,\n      errorContainer: $([]),\n      errorLabelContainer: $([]),\n      onsubmit: true,\n      ignore: ":hidden",\n      ignoreTitle: false,\n      onfocusin: function( element, event ) {\n        this.lastActive = element;\n\n        // hide error label and remove error class on focus if enabled\n        if ( this.settings.focusCleanup && !this.blockFocusCleanup ) {\n          if ( this.settings.unhighlight ) {\n            this.settings.unhighlight.call( this, element, this.settings.errorClass, this.settings.validClass );\n          }\n          this.addWrapper(this.errorsFor(element)).hide();\n        }\n      },\n      onfocusout: function( element, event ) {\n        if ( !this.checkable(element) && (element.name in this.submitted || !this.optional(element)) ) {\n          this.element(element);\n        }\n      },\n      onkeyup: function( element, event ) {\n        if ( event.which === 9 && this.elementValue(element) === "" ) {\n          return;\n        } else if ( element.name in this.submitted || element === this.lastElement ) {\n          this.element(element);\n        }\n      },\n      onclick: function( element, event ) {\n        // click on selects, radiobuttons and checkboxes\n        if ( element.name in this.submitted ) {\n          this.element(element);\n        }\n        // or option elements, check parent select in that case\n        else if ( element.parentNode.name in this.submitted ) {\n          this.element(element.parentNode);\n        }\n      },\n      highlight: function( element, errorClass, validClass ) {\n        if ( element.type === "radio" ) {\n          this.findByName(element.name).addClass(errorClass).removeClass(validClass);\n        } else {\n          $(element).addClass(errorClass).removeClass(validClass);\n        }\n      },\n      unhighlight: function( element, errorClass, validClass ) {\n        if ( element.type === "radio" ) {\n          this.findByName(element.name).removeClass(errorClass).addClass(validClass);\n        } else {\n          $(element).removeClass(errorClass).addClass(validClass);\n        }\n      }\n    },\n\n    // http://docs.jquery.com/Plugins/Validation/Validator/setDefaults\n    setDefaults: function( settings ) {\n      $.extend( $.validator.defaults, settings );\n    },\n\n    messages: {\n      required: "This field is required.",\n      remote: "Please fix this field.",\n      email: "Please enter a valid email address.",\n      url: "Please enter a valid URL.",\n      date: "Please enter a valid date.",\n      dateISO: "Please enter a valid date (ISO).",\n      number: "Please enter a valid number.",\n      digits: "Please enter only digits.",\n      creditcard: "Please enter a valid credit card number.",\n      equalTo: "Please enter the same value again.",\n      maxlength: $.validator.format("Please enter no more than {0} characters."),\n      minlength: $.validator.format("Please enter at least {0} characters."),\n      rangelength: $.validator.format("Please enter a value between {0} and {1} characters long."),\n      range: $.validator.format("Please enter a value between {0} and {1}."),\n      max: $.validator.format("Please enter a value less than or equal to {0}."),\n      min: $.validator.format("Please enter a value greater than or equal to {0}.")\n    },\n\n    autoCreateRanges: false,\n\n    prototype: {\n\n      init: function() {\n        this.labelContainer = $(this.settings.errorLabelContainer);\n        this.errorContext = this.labelContainer.length && this.labelContainer || $(this.currentForm);\n        this.containers = $(this.settings.errorContainer).add( this.settings.errorLabelContainer );\n        this.submitted = {};\n        this.valueCache = {};\n        this.pendingRequest = 0;\n        this.pending = {};\n        this.invalid = {};\n        this.reset();\n\n        var groups = (this.groups = {});\n        $.each(this.settings.groups, function( key, value ) {\n          if ( typeof value === "string" ) {\n            value = value.split(/\\s/);\n          }\n          $.each(value, function( index, name ) {\n            groups[name] = key;\n          });\n        });\n        var rules = this.settings.rules;\n        $.each(rules, function( key, value ) {\n          rules[key] = $.validator.normalizeRule(value);\n        });\n\n        function delegate(event) {\n          var validator = $.data(this[0].form, "validator"),\n            eventType = "on" + event.type.replace(/^validate/, "");\n          if ( validator.settings[eventType] ) {\n            validator.settings[eventType].call(validator, this[0], event);\n          }\n        }\n        $(this.currentForm)\n          .validateDelegate(":text, [type=\'password\'], [type=\'file\'], select, textarea, " +\n            "[type=\'number\'], [type=\'search\'] ,[type=\'tel\'], [type=\'url\'], " +\n            "[type=\'email\'], [type=\'datetime\'], [type=\'date\'], [type=\'month\'], " +\n            "[type=\'week\'], [type=\'time\'], [type=\'datetime-local\'], " +\n            "[type=\'range\'], [type=\'color\'] ",\n            "focusin focusout keyup", delegate)\n          .validateDelegate("[type=\'radio\'], [type=\'checkbox\'], select, option", "click", delegate);\n\n        if ( this.settings.invalidHandler ) {\n          $(this.currentForm).bind("invalid-form.validate", this.settings.invalidHandler);\n        }\n      },\n\n      // http://docs.jquery.com/Plugins/Validation/Validator/form\n      form: function() {\n        this.checkForm();\n        $.extend(this.submitted, this.errorMap);\n        this.invalid = $.extend({}, this.errorMap);\n        if ( !this.valid() ) {\n          $(this.currentForm).triggerHandler("invalid-form", [this]);\n        }\n        this.showErrors();\n        return this.valid();\n      },\n\n      checkForm: function() {\n        this.prepareForm();\n        for ( var i = 0, elements = (this.currentElements = this.elements()); elements[i]; i++ ) {\n          this.check( elements[i] );\n        }\n        return this.valid();\n      },\n\n      // http://docs.jquery.com/Plugins/Validation/Validator/element\n      element: function( element ) {\n        element = this.validationTargetFor( this.clean( element ) );\n        this.lastElement = element;\n        this.prepareElement( element );\n        this.currentElements = $(element);\n        var result = this.check( element ) !== false;\n        if ( result ) {\n          delete this.invalid[element.name];\n        } else {\n          this.invalid[element.name] = true;\n        }\n        if ( !this.numberOfInvalids() ) {\n          // Hide error containers on last error\n          this.toHide = this.toHide.add( this.containers );\n        }\n        this.showErrors();\n        return result;\n      },\n\n      // http://docs.jquery.com/Plugins/Validation/Validator/showErrors\n      showErrors: function( errors ) {\n        if ( errors ) {\n          // add items to error list and map\n          $.extend( this.errorMap, errors );\n          this.errorList = [];\n          for ( var name in errors ) {\n            this.errorList.push({\n              message: errors[name],\n              element: this.findByName(name)[0]\n            });\n          }\n          // remove items from success list\n          this.successList = $.grep( this.successList, function( element ) {\n            return !(element.name in errors);\n          });\n        }\n        if ( this.settings.showErrors ) {\n          this.settings.showErrors.call( this, this.errorMap, this.errorList );\n        } else {\n          this.defaultShowErrors();\n        }\n      },\n\n      // http://docs.jquery.com/Plugins/Validation/Validator/resetForm\n      resetForm: function() {\n        if ( $.fn.resetForm ) {\n          $(this.currentForm).resetForm();\n        }\n        this.submitted = {};\n        this.lastElement = null;\n        this.prepareForm();\n        this.hideErrors();\n        this.elements().removeClass( this.settings.errorClass ).removeData( "previousValue" );\n      },\n\n      numberOfInvalids: function() {\n        return this.objectLength(this.invalid);\n      },\n\n      objectLength: function( obj ) {\n        var count = 0;\n        for ( var i in obj ) {\n          count++;\n        }\n        return count;\n      },\n\n      hideErrors: function() {\n        this.addWrapper( this.toHide ).hide();\n      },\n\n      valid: function() {\n        return this.size() === 0;\n      },\n\n      size: function() {\n        return this.errorList.length;\n      },\n\n      focusInvalid: function() {\n        if ( this.settings.focusInvalid ) {\n          try {\n            $(this.findLastActive() || this.errorList.length && this.errorList[0].element || [])\n              .filter(":visible")\n              .focus()\n              // manually trigger focusin event; without it, focusin handler isn\'t called, findLastActive won\'t have anything to find\n              .trigger("focusin");\n          } catch(e) {\n            // ignore IE throwing errors when focusing hidden elements\n          }\n        }\n      },\n\n      findLastActive: function() {\n        var lastActive = this.lastActive;\n        return lastActive && $.grep(this.errorList, function( n ) {\n          return n.element.name === lastActive.name;\n        }).length === 1 && lastActive;\n      },\n\n      elements: function() {\n        var validator = this,\n          rulesCache = {};\n\n        // select all valid inputs inside the form (no submit or reset buttons)\n        return $(this.currentForm)\n          .find("input, select, textarea")\n          .not(":submit, :reset, :image, [disabled]")\n          .not( this.settings.ignore )\n          .filter(function() {\n            if ( !this.name && validator.settings.debug && window.console ) {\n              console.error( "%o has no name assigned", this);\n            }\n\n            // select only the first element for each name, and only those with rules specified\n            if ( this.name in rulesCache || !validator.objectLength($(this).rules()) ) {\n              return false;\n            }\n\n            rulesCache[this.name] = true;\n            return true;\n          });\n      },\n\n      clean: function( selector ) {\n        return $(selector)[0];\n      },\n\n      errors: function() {\n        var errorClass = this.settings.errorClass.replace(" ", ".");\n        return $(this.settings.errorElement + "." + errorClass, this.errorContext);\n      },\n\n      reset: function() {\n        this.successList = [];\n        this.errorList = [];\n        this.errorMap = {};\n        this.toShow = $([]);\n        this.toHide = $([]);\n        this.currentElements = $([]);\n      },\n\n      prepareForm: function() {\n        this.reset();\n        this.toHide = this.errors().add( this.containers );\n      },\n\n      prepareElement: function( element ) {\n        this.reset();\n        this.toHide = this.errorsFor(element);\n      },\n\n      elementValue: function( element ) {\n        var type = $(element).attr("type"),\n          val = $(element).val();\n\n        if ( type === "radio" || type === "checkbox" ) {\n          return $("input[name=\'" + $(element).attr("name") + "\']:checked").val();\n        }\n\n        if ( typeof val === "string" ) {\n          return val.replace(/\\r/g, "");\n        }\n        return val;\n      },\n\n      check: function( element ) {\n        element = this.validationTargetFor( this.clean( element ) );\n\n        var rules = $(element).rules();\n        var dependencyMismatch = false;\n        var val = this.elementValue(element);\n        var result;\n\n        for (var method in rules ) {\n          var rule = { method: method, parameters: rules[method] };\n          try {\n\n            result = $.validator.methods[method].call( this, val, element, rule.parameters );\n\n            // if a method indicates that the field is optional and therefore valid,\n            // don\'t mark it as valid when there are no other rules\n            if ( result === "dependency-mismatch" ) {\n              dependencyMismatch = true;\n              continue;\n            }\n            dependencyMismatch = false;\n\n            if ( result === "pending" ) {\n              this.toHide = this.toHide.not( this.errorsFor(element) );\n              return;\n            }\n\n            if ( !result ) {\n              this.formatAndAdd( element, rule );\n              return false;\n            }\n          } catch(e) {\n            if ( this.settings.debug && window.console ) {\n              console.log( "Exception occurred when checking element " + element.id + ", check the \'" + rule.method + "\' method.", e );\n            }\n            throw e;\n          }\n        }\n        if ( dependencyMismatch ) {\n          return;\n        }\n        if ( this.objectLength(rules) ) {\n          this.successList.push(element);\n        }\n        return true;\n      },\n\n      // return the custom message for the given element and validation method\n      // specified in the element\'s HTML5 data attribute\n      customDataMessage: function( element, method ) {\n        return $(element).data("msg-" + method.toLowerCase()) || (element.attributes && $(element).attr("data-msg-" + method.toLowerCase()));\n      },\n\n      // return the custom message for the given element name and validation method\n      customMessage: function( name, method ) {\n        var m = this.settings.messages[name];\n        return m && (m.constructor === String ? m : m[method]);\n      },\n\n      // return the first defined argument, allowing empty strings\n      findDefined: function() {\n        for(var i = 0; i < arguments.length; i++) {\n          if ( arguments[i] !== undefined ) {\n            return arguments[i];\n          }\n        }\n        return undefined;\n      },\n\n      defaultMessage: function( element, method ) {\n        return this.findDefined(\n          this.customMessage( element.name, method ),\n          this.customDataMessage( element, method ),\n          // title is never undefined, so handle empty string as undefined\n          !this.settings.ignoreTitle && element.title || undefined,\n          $.validator.messages[method],\n          "<strong>Warning: No message defined for " + element.name + "</strong>"\n        );\n      },\n\n      formatAndAdd: function( element, rule ) {\n        var message = this.defaultMessage( element, rule.method ),\n          theregex = /\\$?\\{(\\d+)\\}/g;\n        if ( typeof message === "function" ) {\n          message = message.call(this, rule.parameters, element);\n        } else if (theregex.test(message)) {\n          message = $.validator.format(message.replace(theregex, "{$1}"), rule.parameters);\n        }\n        this.errorList.push({\n          message: message,\n          element: element\n        });\n\n        this.errorMap[element.name] = message;\n        this.submitted[element.name] = message;\n      },\n\n      addWrapper: function( toToggle ) {\n        if ( this.settings.wrapper ) {\n          toToggle = toToggle.add( toToggle.parent( this.settings.wrapper ) );\n        }\n        return toToggle;\n      },\n\n      defaultShowErrors: function() {\n        var i, elements;\n        for ( i = 0; this.errorList[i]; i++ ) {\n          var error = this.errorList[i];\n          if ( this.settings.highlight ) {\n            this.settings.highlight.call( this, error.element, this.settings.errorClass, this.settings.validClass );\n          }\n          this.showLabel( error.element, error.message );\n        }\n        if ( this.errorList.length ) {\n          this.toShow = this.toShow.add( this.containers );\n        }\n        if ( this.settings.success ) {\n          for ( i = 0; this.successList[i]; i++ ) {\n            this.showLabel( this.successList[i] );\n          }\n        }\n        if ( this.settings.unhighlight ) {\n          for ( i = 0, elements = this.validElements(); elements[i]; i++ ) {\n            this.settings.unhighlight.call( this, elements[i], this.settings.errorClass, this.settings.validClass );\n          }\n        }\n        this.toHide = this.toHide.not( this.toShow );\n        this.hideErrors();\n        this.addWrapper( this.toShow ).show();\n      },\n\n      validElements: function() {\n        return this.currentElements.not(this.invalidElements());\n      },\n\n      invalidElements: function() {\n        return $(this.errorList).map(function() {\n          return this.element;\n        });\n      },\n\n      showLabel: function( element, message ) {\n        var label = this.errorsFor( element );\n        if ( label.length ) {\n          // refresh error/success class\n          label.removeClass( this.settings.validClass ).addClass( this.settings.errorClass );\n          // replace message on existing label\n          label.html(message);\n        } else {\n          // create label\n          label = $("<" + this.settings.errorElement + ">")\n            .attr("for", this.idOrName(element))\n            .addClass(this.settings.errorClass)\n            .html(message || "");\n          if ( this.settings.wrapper ) {\n            // make sure the element is visible, even in IE\n            // actually showing the wrapped element is handled elsewhere\n            label = label.hide().show().wrap("<" + this.settings.wrapper + "/>").parent();\n          }\n          if ( !this.labelContainer.append(label).length ) {\n            if ( this.settings.errorPlacement ) {\n              this.settings.errorPlacement(label, $(element) );\n            } else {\n              label.insertAfter(element);\n            }\n          }\n        }\n        if ( !message && this.settings.success ) {\n          label.text("");\n          if ( typeof this.settings.success === "string" ) {\n            label.addClass( this.settings.success );\n          } else {\n            this.settings.success( label, element );\n          }\n        }\n        this.toShow = this.toShow.add(label);\n      },\n\n      errorsFor: function( element ) {\n        var name = this.idOrName(element);\n        return this.errors().filter(function() {\n          return $(this).attr("for") === name;\n        });\n      },\n\n      idOrName: function( element ) {\n        return this.groups[element.name] || (this.checkable(element) ? element.name : element.id || element.name);\n      },\n\n      validationTargetFor: function( element ) {\n        // if radio/checkbox, validate first element in group instead\n        if ( this.checkable(element) ) {\n          element = this.findByName( element.name ).not(this.settings.ignore)[0];\n        }\n        return element;\n      },\n\n      checkable: function( element ) {\n        return (/radio|checkbox/i).test(element.type);\n      },\n\n      findByName: function( name ) {\n        return $(this.currentForm).find("[name=\'" + name + "\']");\n      },\n\n      getLength: function( value, element ) {\n        switch( element.nodeName.toLowerCase() ) {\n          case "select":\n            return $("option:selected", element).length;\n          case "input":\n            if ( this.checkable( element) ) {\n              return this.findByName(element.name).filter(":checked").length;\n            }\n        }\n        return value.length;\n      },\n\n      depend: function( param, element ) {\n        return this.dependTypes[typeof param] ? this.dependTypes[typeof param](param, element) : true;\n      },\n\n      dependTypes: {\n        "boolean": function( param, element ) {\n          return param;\n        },\n        "string": function( param, element ) {\n          return !!$(param, element.form).length;\n        },\n        "function": function( param, element ) {\n          return param(element);\n        }\n      },\n\n      optional: function( element ) {\n        var val = this.elementValue(element);\n        return !$.validator.methods.required.call(this, val, element) && "dependency-mismatch";\n      },\n\n      startRequest: function( element ) {\n        if ( !this.pending[element.name] ) {\n          this.pendingRequest++;\n          this.pending[element.name] = true;\n        }\n      },\n\n      stopRequest: function( element, valid ) {\n        this.pendingRequest--;\n        // sometimes synchronization fails, make sure pendingRequest is never < 0\n        if ( this.pendingRequest < 0 ) {\n          this.pendingRequest = 0;\n        }\n        delete this.pending[element.name];\n        if ( valid && this.pendingRequest === 0 && this.formSubmitted && this.form() ) {\n          $(this.currentForm).submit();\n          this.formSubmitted = false;\n        } else if (!valid && this.pendingRequest === 0 && this.formSubmitted) {\n          $(this.currentForm).triggerHandler("invalid-form", [this]);\n          this.formSubmitted = false;\n        }\n      },\n\n      previousValue: function( element ) {\n        return $.data(element, "previousValue") || $.data(element, "previousValue", {\n          old: null,\n          valid: true,\n          message: this.defaultMessage( element, "remote" )\n        });\n      }\n\n    },\n\n    classRuleSettings: {\n      required: {required: true},\n      email: {email: true},\n      url: {url: true},\n      date: {date: true},\n      dateISO: {dateISO: true},\n      number: {number: true},\n      digits: {digits: true},\n      creditcard: {creditcard: true}\n    },\n\n    addClassRules: function( className, rules ) {\n      if ( className.constructor === String ) {\n        this.classRuleSettings[className] = rules;\n      } else {\n        $.extend(this.classRuleSettings, className);\n      }\n    },\n\n    classRules: function( element ) {\n      var rules = {};\n      var classes = $(element).attr("class");\n      if ( classes ) {\n        $.each(classes.split(" "), function() {\n          if ( this in $.validator.classRuleSettings ) {\n            $.extend(rules, $.validator.classRuleSettings[this]);\n          }\n        });\n      }\n      return rules;\n    },\n\n    attributeRules: function( element ) {\n      var rules = {};\n      var $element = $(element);\n      var type = $element[0].getAttribute("type");\n\n      for (var method in $.validator.methods) {\n        var value;\n\n        // support for <input required> in both html5 and older browsers\n        if ( method === "required" ) {\n          value = $element.get(0).getAttribute(method);\n          // Some browsers return an empty string for the required attribute\n          // and non-HTML5 browsers might have required="" markup\n          if ( value === "" ) {\n            value = true;\n          }\n          // force non-HTML5 browsers to return bool\n          value = !!value;\n        } else {\n          value = $element.attr(method);\n        }\n\n        // convert the value to a number for number inputs, and for text for backwards compability\n        // allows type="date" and others to be compared as strings\n        if ( /min|max/.test( method ) && ( type === null || /number|range|text/.test( type ) ) ) {\n          value = Number(value);\n        }\n\n        if ( value ) {\n          rules[method] = value;\n        } else if ( type === method && type !== \'range\' ) {\n          // exception: the jquery validate \'range\' method\n          // does not test for the html5 \'range\' type\n          rules[method] = true;\n        }\n      }\n\n      // maxlength may be returned as -1, 2147483647 (IE) and 524288 (safari) for text inputs\n      if ( rules.maxlength && /-1|2147483647|524288/.test(rules.maxlength) ) {\n        delete rules.maxlength;\n      }\n\n      return rules;\n    },\n\n    dataRules: function( element ) {\n      var method, value,\n        rules = {}, $element = $(element);\n      for (method in $.validator.methods) {\n        value = $element.data("rule-" + method.toLowerCase());\n        if ( value !== undefined ) {\n          rules[method] = value;\n        }\n      }\n      return rules;\n    },\n\n    staticRules: function( element ) {\n      var rules = {};\n      var validator = $.data(element.form, "validator");\n      if ( validator.settings.rules ) {\n        rules = $.validator.normalizeRule(validator.settings.rules[element.name]) || {};\n      }\n      return rules;\n    },\n\n    normalizeRules: function( rules, element ) {\n      // handle dependency check\n      $.each(rules, function( prop, val ) {\n        // ignore rule when param is explicitly false, eg. required:false\n        if ( val === false ) {\n          delete rules[prop];\n          return;\n        }\n        if ( val.param || val.depends ) {\n          var keepRule = true;\n          switch (typeof val.depends) {\n            case "string":\n              keepRule = !!$(val.depends, element.form).length;\n              break;\n            case "function":\n              keepRule = val.depends.call(element, element);\n              break;\n          }\n          if ( keepRule ) {\n            rules[prop] = val.param !== undefined ? val.param : true;\n          } else {\n            delete rules[prop];\n          }\n        }\n      });\n\n      // evaluate parameters\n      $.each(rules, function( rule, parameter ) {\n        rules[rule] = $.isFunction(parameter) ? parameter(element) : parameter;\n      });\n\n      // clean number parameters\n      $.each([\'minlength\', \'maxlength\'], function() {\n        if ( rules[this] ) {\n          rules[this] = Number(rules[this]);\n        }\n      });\n      $.each([\'rangelength\', \'range\'], function() {\n        var parts;\n        if ( rules[this] ) {\n          if ( $.isArray(rules[this]) ) {\n            rules[this] = [Number(rules[this][0]), Number(rules[this][1])];\n          } else if ( typeof rules[this] === "string" ) {\n            parts = rules[this].split(/[\\s,]+/);\n            rules[this] = [Number(parts[0]), Number(parts[1])];\n          }\n        }\n      });\n\n      if ( $.validator.autoCreateRanges ) {\n        // auto-create ranges\n        if ( rules.min && rules.max ) {\n          rules.range = [rules.min, rules.max];\n          delete rules.min;\n          delete rules.max;\n        }\n        if ( rules.minlength && rules.maxlength ) {\n          rules.rangelength = [rules.minlength, rules.maxlength];\n          delete rules.minlength;\n          delete rules.maxlength;\n        }\n      }\n\n      return rules;\n    },\n\n    // Converts a simple string to a {string: true} rule, e.g., "required" to {required:true}\n    normalizeRule: function( data ) {\n      if ( typeof data === "string" ) {\n        var transformed = {};\n        $.each(data.split(/\\s/), function() {\n          transformed[this] = true;\n        });\n        data = transformed;\n      }\n      return data;\n    },\n\n    // http://docs.jquery.com/Plugins/Validation/Validator/addMethod\n    addMethod: function( name, method, message ) {\n      $.validator.methods[name] = method;\n      $.validator.messages[name] = message !== undefined ? message : $.validator.messages[name];\n      if ( method.length < 3 ) {\n        $.validator.addClassRules(name, $.validator.normalizeRule(name));\n      }\n    },\n\n    methods: {\n\n      // http://docs.jquery.com/Plugins/Validation/Methods/required\n      required: function( value, element, param ) {\n        // check if dependency is met\n        if ( !this.depend(param, element) ) {\n          return "dependency-mismatch";\n        }\n        if ( element.nodeName.toLowerCase() === "select" ) {\n          // could be an array for select-multiple or a string, both are fine this way\n          var val = $(element).val();\n          return val && val.length > 0;\n        }\n        if ( this.checkable(element) ) {\n          return this.getLength(value, element) > 0;\n        }\n        return $.trim(value).length > 0;\n      },\n\n      // http://docs.jquery.com/Plugins/Validation/Methods/email\n      email: function( value, element ) {\n        // contributed by Scott Gonzalez: http://projects.scottsplayground.com/email_address_validation/\n        return this.optional(element) || /^((([a-z]|\\d|[!#\\$%&\'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&\'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i.test(value);\n      },\n\n      // http://docs.jquery.com/Plugins/Validation/Methods/url\n      url: function( value, element ) {\n        // contributed by Scott Gonzalez: http://projects.scottsplayground.com/iri/\n        return this.optional(element) || /^(https?|s?ftp):\\/\\/(((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&\'\\(\\)\\*\\+,;=]|:)*@)?(((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5]))|((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.?)(:\\d*)?)(\\/((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&\'\\(\\)\\*\\+,;=]|:|@)+(\\/(([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&\'\\(\\)\\*\\+,;=]|:|@)*)*)?)?(\\?((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&\'\\(\\)\\*\\+,;=]|:|@)|[\\uE000-\\uF8FF]|\\/|\\?)*)?(#((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&\'\\(\\)\\*\\+,;=]|:|@)|\\/|\\?)*)?$/i.test(value);\n      },\n\n      // http://docs.jquery.com/Plugins/Validation/Methods/date\n      date: function( value, element ) {\n        return this.optional(element) || !/Invalid|NaN/.test(new Date(value).toString());\n      },\n\n      // http://docs.jquery.com/Plugins/Validation/Methods/dateISO\n      dateISO: function( value, element ) {\n        return this.optional(element) || /^\\d{4}[\\/\\-]\\d{1,2}[\\/\\-]\\d{1,2}$/.test(value);\n      },\n\n      // http://docs.jquery.com/Plugins/Validation/Methods/number\n      number: function( value, element ) {\n        return this.optional(element) || /^-?(?:\\d+|\\d{1,3}(?:,\\d{3})+)?(?:\\.\\d+)?$/.test(value);\n      },\n\n      // http://docs.jquery.com/Plugins/Validation/Methods/digits\n      digits: function( value, element ) {\n        return this.optional(element) || /^\\d+$/.test(value);\n      },\n\n      // http://docs.jquery.com/Plugins/Validation/Methods/creditcard\n      // based on http://en.wikipedia.org/wiki/Luhn\n      creditcard: function( value, element ) {\n        if ( this.optional(element) ) {\n          return "dependency-mismatch";\n        }\n        // accept only spaces, digits and dashes\n        if ( /[^0-9 \\-]+/.test(value) ) {\n          return false;\n        }\n        var nCheck = 0,\n          nDigit = 0,\n          bEven = false;\n\n        value = value.replace(/\\D/g, "");\n\n        for (var n = value.length - 1; n >= 0; n--) {\n          var cDigit = value.charAt(n);\n          nDigit = parseInt(cDigit, 10);\n          if ( bEven ) {\n            if ( (nDigit *= 2) > 9 ) {\n              nDigit -= 9;\n            }\n          }\n          nCheck += nDigit;\n          bEven = !bEven;\n        }\n\n        return (nCheck % 10) === 0;\n      },\n\n      // http://docs.jquery.com/Plugins/Validation/Methods/minlength\n      minlength: function( value, element, param ) {\n        var length = $.isArray( value ) ? value.length : this.getLength($.trim(value), element);\n        return this.optional(element) || length >= param;\n      },\n\n      // http://docs.jquery.com/Plugins/Validation/Methods/maxlength\n      maxlength: function( value, element, param ) {\n        var length = $.isArray( value ) ? value.length : this.getLength($.trim(value), element);\n        return this.optional(element) || length <= param;\n      },\n\n      // http://docs.jquery.com/Plugins/Validation/Methods/rangelength\n      rangelength: function( value, element, param ) {\n        var length = $.isArray( value ) ? value.length : this.getLength($.trim(value), element);\n        return this.optional(element) || ( length >= param[0] && length <= param[1] );\n      },\n\n      // http://docs.jquery.com/Plugins/Validation/Methods/min\n      min: function( value, element, param ) {\n        return this.optional(element) || value >= param;\n      },\n\n      // http://docs.jquery.com/Plugins/Validation/Methods/max\n      max: function( value, element, param ) {\n        return this.optional(element) || value <= param;\n      },\n\n      // http://docs.jquery.com/Plugins/Validation/Methods/range\n      range: function( value, element, param ) {\n        return this.optional(element) || ( value >= param[0] && value <= param[1] );\n      },\n\n      // http://docs.jquery.com/Plugins/Validation/Methods/equalTo\n      equalTo: function( value, element, param ) {\n        // bind to the blur event of the target in order to revalidate whenever the target field is updated\n        // TODO find a way to bind the event just once, avoiding the unbind-rebind overhead\n        var target = $(param);\n        if ( this.settings.onfocusout ) {\n          target.unbind(".validate-equalTo").bind("blur.validate-equalTo", function() {\n            $(element).valid();\n          });\n        }\n        return value === target.val();\n      },\n\n      // http://docs.jquery.com/Plugins/Validation/Methods/remote\n      remote: function( value, element, param ) {\n        if ( this.optional(element) ) {\n          return "dependency-mismatch";\n        }\n\n        var previous = this.previousValue(element);\n        if (!this.settings.messages[element.name] ) {\n          this.settings.messages[element.name] = {};\n        }\n        previous.originalMessage = this.settings.messages[element.name].remote;\n        this.settings.messages[element.name].remote = previous.message;\n\n        param = typeof param === "string" && {url:param} || param;\n\n        if ( previous.old === value ) {\n          return previous.valid;\n        }\n\n        previous.old = value;\n        var validator = this;\n        this.startRequest(element);\n        var data = {};\n        data[element.name] = value;\n        $.ajax($.extend(true, {\n          url: param,\n          mode: "abort",\n          port: "validate" + element.name,\n          dataType: "json",\n          data: data,\n          success: function( response ) {\n            validator.settings.messages[element.name].remote = previous.originalMessage;\n            var valid = response === true || response === "true";\n            if ( valid ) {\n              var submitted = validator.formSubmitted;\n              validator.prepareElement(element);\n              validator.formSubmitted = submitted;\n              validator.successList.push(element);\n              delete validator.invalid[element.name];\n              validator.showErrors();\n            } else {\n              var errors = {};\n              var message = response || validator.defaultMessage( element, "remote" );\n              errors[element.name] = previous.message = $.isFunction(message) ? message(value) : message;\n              validator.invalid[element.name] = true;\n              validator.showErrors(errors);\n            }\n            previous.valid = valid;\n            validator.stopRequest(element, valid);\n          }\n        }, param));\n        return "pending";\n      }\n\n    }\n\n  });\n\n// deprecated, use $.validator.format instead\n  $.format = $.validator.format;\n\n}(jQuery));\n\n// ajax mode: abort\n// usage: $.ajax({ mode: "abort"[, port: "uniqueport"]});\n// if mode:"abort" is used, the previous request on that port (port can be undefined) is aborted via XMLHttpRequest.abort()\n(function($) {\n  var pendingRequests = {};\n  // Use a prefilter if available (1.5+)\n  if ( $.ajaxPrefilter ) {\n    $.ajaxPrefilter(function( settings, _, xhr ) {\n      var port = settings.port;\n      if ( settings.mode === "abort" ) {\n        if ( pendingRequests[port] ) {\n          pendingRequests[port].abort();\n        }\n        pendingRequests[port] = xhr;\n      }\n    });\n  } else {\n    // Proxy ajax\n    var ajax = $.ajax;\n    $.ajax = function( settings ) {\n      var mode = ( "mode" in settings ? settings : $.ajaxSettings ).mode,\n        port = ( "port" in settings ? settings : $.ajaxSettings ).port;\n      if ( mode === "abort" ) {\n        if ( pendingRequests[port] ) {\n          pendingRequests[port].abort();\n        }\n        pendingRequests[port] = ajax.apply(this, arguments);\n        return pendingRequests[port];\n      }\n      return ajax.apply(this, arguments);\n    };\n  }\n}(jQuery));\n\n// provides delegate(type: String, delegate: Selector, handler: Callback) plugin for easier event delegation\n// handler is only called when $(event.target).is(delegate), in the scope of the jquery-object for event.target\n(function($) {\n  $.extend($.fn, {\n    validateDelegate: function( delegate, type, handler ) {\n      return this.bind(type, function( event ) {\n        var target = $(event.target);\n        if ( target.is(delegate) ) {\n          return handler.apply(target, arguments);\n        }\n      });\n    }\n  });\n}(jQuery));\n'
    },
    324: function(n, e, t) {
        "use strict";
        t(0)(t(325))
    },
    325: function(n, e) {
        n.exports = "/** Globals PubSub */\n\nspweb.Form = (function($, utils, config, pubSub) {\n\n  /**\n   * Binds javascript behaviors to an html form\n   * @requires jQuery\n   * @requires spweb.utils\n   * @requires spweb.config\n   * @requires PubSub\n   *\n   */\n \n   'use strict';\n \n   /**\n    * @constructor\n    * @param {Object} form jQuery object corresponding to an html form element\n    */\n   function Form(form) {\n     this.form = form;\n \n     /**\n      * @private\n      * Keep track of form submission state\n      */\n     this._isSubmitting = false;\n   }\n \n   /**\n    * Attaches the jQuery validation plugin to the form\n    * @param {Object} [options] Options to pass to the validation plugin. Merges with, and potentially\n    *    overrides, the default settings we have chosen for form validation.\n    */\n   Form.prototype.init = function(options) {\n     var self = this,\n       validationOptions = {\n         submitHandler: function() {\n           var form = self.form;\n           if(!self._isSubmitting) {\n             self._isSubmitting = true;\n             self.showAjaxSpinner();\n             pubSub.publish('form_submit.' + self.form.attr('id'));\n             jQuery.ajax({\n               data: form.serialize(),\n               dataType: 'json',\n               success: function(data) {\n                 if (data.errors && data.errors.length && data.errors[0].field === 'password') {\n                   var passwordEl = jQuery('#register-password');\n                   passwordEl.addClass('has-error');\n                   passwordEl.next().text(data.errors[0].translatedMessage);\n \n                 } else {\n                   pubSub.publish('form_success.' + self.form.attr('id'), data);\n                 }\n                 // Must reset the reCaptcha or it won't be able to post again.\n                 self._resetCaptcha();\n               },\n               error: function() {\n                 pubSub.publish('form_error.' + self.form.attr('id'));\n                 // Must reset the reCaptcha or it won't be able to post again.\n                 self._resetCaptcha();\n               },\n               complete: function() {\n                 self.hideAjaxSpinner();\n                 self._isSubmitting = false;\n               },\n               type: form.attr('method'),\n               url: form.attr('action')\n             });\n           }\n         },\n         errorClass: 'has-error',\n \n         errorPlacement: function(error, element) {\n           //sp-bootstrap pattern\n           var formGroup = element.parents('.form-group');\n           if (formGroup.length > 0) {\n             formGroup.addClass('has-error');\n             error.addClass('control-label-validation');\n           }\n \n           element.after(error);\n         },\n \n         success: function(label) {\n           //sp-bootstrap pattern\n           var formGroup = label.parents('.form-group');\n           if (formGroup.length > 0) {\n             // Remove all error labels\n             formGroup.removeClass('has-error');\n \n             // We must remove the has-error class on the children too. This\n             // fixes https://ghe.spotify.net/morpheus/website/pull/4558#issuecomment-1033304\n             formGroup.children('.has-error').removeClass('has-error');\n \n             label.remove();\n           }\n         }\n       };\n \n     this.validationOptions = jQuery.extend(validationOptions, options);\n     this._setupCaptcha();\n     this._setupValidation();\n \n     if (this.validationOptions.submitHandler !== null) {\n       this._insertAjaxSpinner();\n     }\n   };\n \n   Form.prototype.scrollToFirstError = function() {\n \n     var errorTops = [];\n \n     var e = this.form.find('.js-general-error');\n     if (!e.hasClass(\"hidden\")) {\n       errorTops.push(e.offset().top);\n     }\n \n     if (this.validator) {\n       $.each(this.validator.errorList, function (i, val) {\n         if (val.element) {\n           errorTops.push($(val.element).offset().top);\n         }\n       });\n     }\n \n     if (errorTops.length === 0) {\n       return;\n     }\n \n     var isOffsetVisible = function (offset) {\n       var viewportHeight = $(window).height(),\n         documentScrollTop = $(document).scrollTop();\n       return offset > documentScrollTop && offset < (documentScrollTop + viewportHeight);\n     };\n \n     var scrollDestination = Math.min.apply(null, errorTops); // minimum value from the array.\n \n     // Don't scroll if the element is already visible\n     if (isOffsetVisible(scrollDestination)) {\n       return;\n     }\n \n     $('html,body').animate({\n       scrollTop: scrollDestination\n     }, 500);\n \n   };\n \n   /**\n    * Implicitly called by the init method, this does the actual calling of the validation plugin.\n    * @private\n    */\n   Form.prototype._setupValidation = function() {\n     this.validator = this.form.validate(this.validationOptions);\n   };\n \n   /**\n    * Resets the form\n    */\n   Form.prototype.resetForm = function() {\n     this.validator.resetForm();\n   };\n \n   /**\n    * Prepends ajax spinner element to this.form\n    * @private\n    */\n   Form.prototype._insertAjaxSpinner = function() {\n     var spinner = jQuery('<div></div>');\n \n     spinner.addClass('hidden ajax-spinner');\n \n     this.form.prepend(spinner);\n     this.ajaxSpinner = spinner;\n   };\n \n   /**\n    * Shows ajax spinner animated GIF.\n    */\n   Form.prototype.showAjaxSpinner = function() {\n     this.ajaxSpinner.removeClass('hidden');\n   };\n \n   /**\n    * Hides ajax spinner animated GIF.\n    */\n   Form.prototype.hideAjaxSpinner = function() {\n     this.ajaxSpinner.addClass('hidden');\n   };\n \n   /**\n    * This is a default showGeneralError. If it finds an element with class=\"js-general-error\" and data-error=\"...\",\n    * it will show this error. Calling this function with a string parameter shows the error with that message.\n    * @param {String} message\n    */\n   Form.prototype.showGeneralError = function(message) {\n     var e = this.form.find('.js-general-error');\n     if(e.length && (message || e.data('error'))) {\n       e.html(message ? message : e.data('error')).removeClass('hidden');\n     }\n     this.scrollToFirstError();\n   };\n \n   /**\n    * This is a default hideGeneralError. If it finds an element with class=\"js-general-error\" it will hide it.\n    */\n   Form.prototype.hideGeneralError = function() {\n     var e = this.form.find('.js-general-error');\n     if(e.length) {\n       e.addClass('hidden');\n     }\n   };\n \n   Form.prototype._resetCaptcha = function() {\n     // We should reset the recapture after every ajax post because or the\n     // captcha will fail on a second post.\n     if (document.getElementById(\"captcha-div\") !== null) {\n       grecaptcha.reset();\n     }\n   };\n \n   Form.prototype._setupCaptcha = function() {\n     var div = document.getElementById(\"captcha-div\");\n     if (div === null) {\n       return;\n     }\n \n     var _this = this;\n     window.captchaSuccessCallback = function (response) {\n       // This initiates validation on the hidden form element when the captcha succeeds.\n       // This ensures the validation error is cleared as soon as the captcha is passed.\n       _this.validator.element(\"#captcha-hidden\");\n \n     };\n \n     // This configures validation on the captcha hidden form element.\n     this.validationOptions = this.validationOptions || {};\n     this.validationOptions.ignore = '.ignore';\n     this.validationOptions.messages = this.validationOptions.messages || {};\n     this.validationOptions.rules = this.validationOptions.rules || {};\n \n     $.extend(this.validationOptions.messages, {\n       captcha_hidden: {\n         required: div.getAttribute(\"data-error\")\n       }\n     });\n \n     $.extend(this.validationOptions.rules, {\n       captcha_hidden: {\n         required: function () {\n           return grecaptcha.getResponse() === \"\";\n         }\n       }\n     });\n   };\n \n   return Form;\n \n }(jQuery, spweb.utils, spweb.config, PubSub));\n"
    },
    393: function(n, e, t) {
        "use strict";
        t(0)(t(394))
    },
    394: function(n, e) {
        n.exports = "spweb.utils = (function() {\n    /**\n     * Utility methods\n     * @module spweb/utils\n     */\n\n    'use strict';\n\n    var exports = {\n\n        /**\n         * Counts the items in an object\n         * @param {Object} obj\n         * @returns {Number}\n         */\n        objectLength: function(obj) {\n            var size = 0, key;\n            for (key in obj) {\n                if (obj.hasOwnProperty(key)) {\n                    size++;\n                }\n            }\n            return size;\n        },\n\n        /**\n         * Query string based off:\n         * http://stackoverflow.com/questions/901115/how-can-i-get-query-string-values\n         * @param {String} name query string key\n         * @param {String} [qs] A query string to search through instead of the default current url\n         * @return {String} value of the queried key in the query string. Returns an empty string of the\n         *  key does not exist\n         */\n        getQueryParameter: function(name, qs) {\n            qs = qs || window.location.search;\n            name = name.replace(/[\\[]/, '\\\\\\[').replace(/[\\]]/, '\\\\\\]');\n            var regex = new RegExp('[\\\\?&]' + name + '=([^&#]*)'),\n                results = regex.exec(qs);\n            return results == null ? '' : decodeURIComponent(results[1].replace(/\\+/g, ' '));\n        },\n\n        /**\n         * Redirect the browser\n         * @param {String} url New browser location\n         */\n        redirect: function(url) {\n            window.location.href = url;\n        },\n\n        /**\n         * @description Returns a random integer between min and max\n         * @param {Number} min The lower range of integers to select\n         *  a random integer from.\n         * @param {Number} max The upper range of integers to select\n         *  a random integer from.\n         * @returns {Number} A random integer.\n         */\n        getRandomInt: function (min, max) {\n            return Math.floor(Math.random() * (max - min + 1)) + min;\n        },\n\n        /**\n         * @description Loads a JS script into the DOM asynchronously\n         * @param {String} src URI of the JS script\n         * @param {Function} [callback] Function to call once script has loaded\n         */\n        asyncLoadJs: function (src, callback) {\n            var cb = (typeof callback === 'function') ? callback : false,\n                document = document || window.document,\n                script = document.createElement('script'),\n                s = document.getElementsByTagName('script')[0];\n\n            script.async = 'async';\n            script.src = src;\n\n            script.onload = script.onreadystatechange = function() {\n                if (script.readyState) {\n                    if (script.readyState === 'loaded' || script.readyState === 'complete') {\n                        script.onreadystatechange = null;\n                        if (cb) {\n                            cb();\n                        }\n                    }\n                } else {\n                    if (cb) {\n                        cb();\n                    }\n                }\n            };\n            s.parentNode.insertBefore(script, s);\n        },\n\n        /**\n         * Helper for Javascript inheritance from https://wiki.spotify.net/wiki/Architecture/Client/Stitch/Classes_and_inheritance\n         * @param {Function} cls\n         * @param {Function} superclass\n         */\n        inherit: function(cls, superclass) {\n            function F() {}\n            F.prototype = superclass.prototype;\n            cls.prototype = new F();\n            cls.prototype.constructor = cls;\n        },\n\n        /**\n         * Shuffle an array\n         *\n         * @param {Array} array\n         * @returns {Array}\n         */\n        shuffle: function (array) {\n            var i, j, tmp;\n\n            // Randomize the array\n            for (i = array.length - 1; i > 0; i--) {\n                j = Math.floor(Math.random() * (i + 1));\n                tmp = array[i];\n                array[i] = array[j];\n                array[j] = tmp;\n            }\n\n            return array;\n        },\n\n        /**\n         * Function that updates a div's lazy load image source depending on screen width\n         * Works in conjunction with http://www.appelsiini.net/projects/lazyload\n         */\n        updateLazyLoadImages: function() {\n            var isMobileView = !('matchMedia' in window) || !window.matchMedia(\"(min-width: 768px)\").matches;\n\n            // NOTE: we are only looping over div tags\n            $('div.lazy').each(function(index) {\n                var newOriginal,\n                    $this = $(this);\n\n                // Skip elements with \"lazy-no-small\" CSS class\n                if ($this.hasClass('lazy-no-small')) {\n                    return;\n                }\n\n                if (isMobileView && $this.attr('data-original').indexOf('-sm') < 0) {\n                    newOriginal = $this.attr('data-original').replace('.jpg', '-sm.jpg').replace('.png', '-sm.png');\n                    $this.attr('data-original', newOriginal);\n                }\n\n                if (!isMobileView && $this.attr('data-original').indexOf('-sm') > 0) {\n                    newOriginal = $this.attr('data-original').replace('-sm.jpg', '.jpg').replace('-sm.png', '.png');\n                    $this.attr('data-original', newOriginal);\n                }\n\n                // Only update if we have a new original to update with,\n                //   and only if the background-image was already set.\n                if ($this.css('background-image') !== 'none' && newOriginal !== undefined) {\n                    $this.css('background-image', 'url(' + newOriginal + ')');\n                }\n            });\n        },\n\n        /**\n         * Redirect user to /signup/ and append forward_url query param to url\n         * Works as a click event handler bound to an anchor with an href attribute.\n         * The href attribute will be encoded and set as the forward_url query parameter's value\n         * @param {object} e the generated jQuery event object\n         */\n\n        goToSignup: function(e) {\n            var forwardUrl;\n            e.preventDefault();\n\n            forwardUrl = $(this).attr('href');\n            if (forwardUrl[0] !== '/') {\n                forwardUrl = '/' + forwardUrl;\n            }\n            window.location = '/' + spweb.user.getMarket() + '/signup/?forward_url=' + window.encodeURIComponent(window.location.origin + forwardUrl);\n        },\n  };\n\n    return exports;\n\n}());\n"
    },
    395: function(n, e, t) {
        "use strict";
        t(0)(t(396))
    },
    396: function(n, e) {
        n.exports = "spweb.user = (function($) {\n  /**\n   * The user module describes characteristics about the user such as\n   * preferred language, market, logged in state.\n   *\n   * @module spweb/user\n   * @requires jQuery\n   */\n\n  'use strict';\n\n  var exports = {};\n\n  /**\n   * @returns {String} language\n   */\n  exports.getLang = function() {\n    return spweb.config.language;\n  };\n\n  /**\n   * @returns {String} market\n   */\n  exports.getMarket = function() {\n    return spweb.config.market;\n  };\n\n  /**\n   * @returns {Boolean} is the user logged in?\n   */\n  exports.isLoggedIn = function() {\n    return $('body').hasClass('is-loggedin');\n  };\n\n  return exports;\n\n}(jQuery));\n"
    },
    397: function(n, e, t) {
        "use strict";
        t(0)(t(398))
    },
    398: function(n, e) {
        n.exports = 'spweb.detect = (function () {\n  /**\n   * REMEMBER, this library is also exists in PHP in the php/web-core\n   * project. Please remember to keep them in sync:\n   *\n   * https://ghe.spotify.net/php/web-core/blob/master/lib/Spotify/Core/Detect.php\n   */\n\n  /**\n   * Detects the OS of the device by sniffing the user agent.\n   *\n   * @module spweb/detect\n   */\n\n  \'use strict\';\n\n  var exports = {};\n\n  exports.OS_WPHONE = \'wphone\';\n  exports.OS_ANDROID = \'android\';\n  exports.OS_IOS = \'ios\';\n  exports.OS_MAC = \'mac\';\n  exports.OS_LINUX = \'linux\';\n  exports.OS_CHROMEOS = \'chromeos\';\n  exports.OS_WINDOWS = \'windows\';\n  exports.OS_BLACKBERRY = \'blackberry\';\n  exports.OS_KINDLE = \'kindle\';\n  exports.OS_SYMBIAN = \'symbian\';\n  exports.OS_UNKNOWN = \'unknown\';\n\n  /**\n   *\n   * The detect function provides a best-guess of the OS based on the\n   * provided User Agent string. Returned is an array:\n   *\n   * "os"     => string - wphone, android, ios, mac, unknown, linux, chromeos,\n   *                      windows, blackberry, kindle, symbian\n   * "mobile" => bool   - is this a mobile OS?\n   *\n   * It is important to remember that the "mobile" part of the response is\n   * not trying to work out the form-factor of the device. We don\'t\n   * differentiate between mobiles and tablets, and there are plenty of edge\n   * case devices (e.g. Android laptops) that run a mobile OS on a desktop\n   * style platform.\n   *\n   * As time goes on, there will probably be more and more of these\n   * cross-over devices, so be careful.\n   *\n   * mobile == true: android, ios, wphone, blackberry, kindle, symbian\n   * mobile == false: mac, windows, chromeos, linux\n   *\n   * The "unknown" OS is a catch-all for several types of device. Some e.g.\n   * smart tv\'s are mobile == false. Some e.g. Samsung Tizen mobiles are\n   * mobile == true.\n   *\n   * @param [ua]\n   * @returns {*}\n   */\n  exports.detect = function (ua) {\n    var i, spec, reg, data, test;\n\n    if (ua === null) {\n      ua = window.navigator.userAgent;\n    }\n\n    data = getData();\n\n    // Build the string to match - note we add a space either end so we can\n    // match \\b at the start and end of the string\n    test = " " + ua + " ";\n\n    for (i = 0; i < data.length; i++) {\n      spec = data[i];\n\n      // Build a regex by concatinating the matches with \\b (word boundry)\n      // either side.\n      reg = new RegExp("\\\\b" + spec["matches"].join("\\\\b|\\\\b") + "\\\\b");\n\n      if (reg.test(test)) {\n        return {"os": spec["os"], "mobile": spec["mobile"]};\n      }\n    }\n    return {"os": exports.OS_UNKNOWN, "mobile": false};\n  };\n\n  /**\n   * Gets data for mobile detection. This data is used by the web-core\n   * Detect::detect function, and also the javascript spweb.detect class.\n   *\n   * @return array\n   */\n  function getData() {\n    return [\n      {\n        "note": "Windows Phone: pretends to be iPhone and Android, so it has to stay first in the list",\n        "os": exports.OS_WPHONE,\n        "mobile": true,\n        "matches": ["Windows Phone", "Windows CE", "Window Mobile", "XBLWP7", "ZuneWP7", "Windows NT \\\\d{1,2}\\\\.\\\\d{1,2}; ARM", "IEMobile"]\n      },\n      {\n        "note": "Google Android",\n        "os": exports.OS_ANDROID,\n        "mobile": true,\n        "matches": ["Android"]\n      },\n      {\n        "note": "Apple iOS",\n        "os": exports.OS_IOS,\n        "mobile": true,\n        "matches": ["iPhone", "iPod", "iPad", "MobileSafari", "CriOS"]\n      },\n      {\n        "note": "Apple Mac OS X",\n        "os": exports.OS_MAC,\n        "mobile": false,\n        "matches": ["Mac OS X"]\n      },\n      {\n        "note": "Mobile games consoles",\n        "os": exports.OS_UNKNOWN,\n        "mobile": true,\n        "matches": ["PlayStation Vita", "Nintendo WiiU", "Nintendo 3DS"]\n      },\n      {\n        "note": "TV games consoles",\n        "os": exports.OS_UNKNOWN,\n        "mobile": false,\n        "matches": ["PlayStation 4", "PLAYSTATION 3"]\n      },\n      {\n        "note": "Smart TVs",\n        "os": exports.OS_UNKNOWN,\n        "mobile": false,\n        "matches": ["SMART-TV", "SmartTV", "NETTV", "PhilipsTV", "GoogleTV", "HbbTV", "AQUOSBrowser", "BRAVIA", "SonyBDP", "Viera"]\n      },\n      {\n        "note": "Linux Desktop: Firefox is not very clear on Linux/FirefoxOS, but we assume Intel platform is desktop Linux, and ARM is mobile.",\n        "os": exports.OS_LINUX,\n        "mobile": false,\n        "matches": ["Linux i686"]\n      },\n      {\n        "note": "Firefox OS (mobile): Firefox is not very clear on Linux/FirefoxOS, but we assume Intel platform is desktop Linux, and ARM is mobile.",\n        "os": exports.OS_UNKNOWN,\n        "mobile": true,\n        "matches": ["Linux armv7l"]\n      },\n      {\n        "note": "Google Chrome OS",\n        "os": exports.OS_CHROMEOS,\n        "mobile": false,\n        "matches": ["CrOS"]\n      },\n      {\n        "note": "Microsoft Windows",\n        "os": exports.OS_WINDOWS,\n        "mobile": false,\n        "matches": ["Windows", "Win64"]\n      },\n      {\n        "note": "BlackBerry",\n        "os": exports.OS_BLACKBERRY,\n        "mobile": true,\n        "matches": ["PlayBook", "RIM Tablet", "blackberry", "BlackBerry", "BB10", "rim tablet os"]\n      },\n      {\n        "note": "Samsung Mobile OS variants",\n        "os": exports.OS_UNKNOWN,\n        "mobile": true,\n        "matches": ["Bada", "Tizen", "SpreadTrum"]\n      },\n      {\n        "note": "Amazon Kindle (forked Android that needs a separate app store link)",\n        "os": exports.OS_KINDLE,\n        "mobile": true,\n        "matches": ["Kindle", "Silk"]\n      },\n      {\n        "note": "Nokia Symbian",\n        "os": exports.OS_SYMBIAN,\n        "mobile": true,\n        "matches": ["nokian73", "S60V3", "Series 60", "SymbOS", "SymbianOS"]\n      },\n      {\n        "note": "Java Mobile: Various low-cost smart phones",\n        "os": exports.OS_UNKNOWN,\n        "mobile": true,\n        "matches": ["J2ME", "MIDP", "CLDC"]\n      },\n      {\n        "note": "UCBrowser: this seems to be quite popular on several platforms, but its impossible to tell them apart. We should probably assume Android?",\n        "os": exports.OS_ANDROID,\n        "mobile": true,\n        "matches": ["UCBrowser", "UCWEB", "UCWEB\\\\d"]\n      },\n      {\n        "note": "If we havent detected anything by this point, we should look for some generic indications that we have a mobile device.",\n        "os": exports.OS_UNKNOWN,\n        "mobile": true,\n        "matches": ["Mobile", "Tablet", "Opera Mini"]\n      },\n      {\n        "note": "Final match for linux desktop",\n        "os": exports.OS_LINUX,\n        "mobile": false,\n        "matches": ["Linux"]\n      }\n    ];\n  }\n\n  return exports;\n\n}());'
    },
    399: function(n, e, t) {
        "use strict";
        t(0)(t(400))
    },
    400: function(n, e) {
        n.exports = "/** Globals PubSub */\n\nspweb.tracking = (function(globals, $, detect, pubSub) {\n  /**\n   * @module spweb/tracking\n   * @requires this (the global context, eg, window)\n   * @requires jQuery\n   * @requires spweb.detect\n   * @requires PubSub\n   */\n\n  'use strict';\n\n  var exports = {};\n\n  /**\n   * Forward \"interesting\" events on to our tracking systems - eg Google Tag Manager,\n   * backend logging, etc.\n   * @param {String} eventName\n   */\n  exports.pushGTMEvent = function(eventName) {\n    globals.dataLayer.push({event: eventName});\n  };\n\n  /**\n   * Subscribe to custom events\n   */\n  pubSub.subscribe('registration_success', function() {\n    exports.pushGTMEvent('registration_success');\n  });\n\n  /**\n   * Module set up\n   */\n  exports.init = function() {\n    // check if GTM is present and functions are available before\n    // calling them.\n    if (globals.hasOwnProperty('dataLayer')) {\n      this._setGTMDeviceData();\n      this._bindEventHandlers();\n    }\n  };\n\n  /**\n   * Pushes device key/value to Google Tag Manager (GTM) dataLayer array\n   */\n  exports._setGTMDeviceData = function() {\n    globals.dataLayer.push({device: detect.detect().mobile ? 'mobile' : 'desktop'});\n  };\n\n  /**\n   * @private\n   */\n  exports._bindEventHandlers = function() {\n    var self = this;\n\n    $('.js-gtm-event').on('click', function() {\n      var jqEl = $(this);\n      self._handleGTMClick(jqEl);\n    });\n  };\n\n  /**\n   * Handle click events on elements related to Google Tag Manager (GTM)\n   * @private\n   * @param {Object} el the clicked element as a jQuery object\n   */\n  exports._handleGTMClick = function(el) {\n    var name = el.data('gtm-event-name');\n    if (name !== undefined) {\n      exports.pushGTMEvent(name);\n    }\n  };\n\n  return exports;\n\n}(typeof global !== 'undefined' ? global : window, jQuery, spweb.detect, PubSub));\n"
    },
    401: function(n, e, t) {
        "use strict";
        t(0)(t(402))
    },
    402: function(n, e) {
        n.exports = "spweb.download = (function ($, cookie) {\n  /**\n   * Behavior related to the downloads page.\n   * @module spweb/download\n   * @requires jQuery\n   * @requires spweb.cookie\n   */\n\n  'use strict';\n\n  var exports = {};\n\n  /**\n   * Trigger download; remove tracking pixel\n   * @param {String} url\n   * @param {Number} delay (ms)\n   */\n  exports.download = function(url, delay) {\n    $(document).ready(function(){\n      setTimeout(function() {\n        window.location.href = url;\n      }, delay);\n    });\n    // Remove the tracking pixel\n    cookie.remove('pxt');\n  };\n\n  return exports;\n\n}(jQuery, spweb.cookie));\n"
    },
    403: function(n, e, t) {
        "use strict";
        t(0)(t(404))
    },
    404: function(n, e) {
        n.exports = "/** Globals PubSub */\n\nspweb.navbar = (function ($, pubSub) {\n  /**\n   * navbar disables / enables the sticky navbar when we add / remove message bars.\n   *\n   * @module spweb/navbar\n   * @requires jQuery\n   * @requires pubSub\n   */\n\n  'use strict';\n\n  var exports = {},\n    fixedClass = 'navbar-fixed-top',\n    staticClass = 'navbar-static-top',\n    dataTag = 'navbar-fixed-top-disabled';\n\n  /**\n   * Fires when message_bars_shown is published\n   * @private\n   */\n  exports._shown = function() {\n    var navbar = $('#js-navbar');\n    if (navbar.length === 0) {\n      return;\n    }\n\n    // We use a data attribute to record if the navbar wants to be in fixed mode, so\n    // we can put it back in fixed mode in the message_bars_hidden event.\n    if (navbar.hasClass(fixedClass)) {\n      navbar\n        .removeClass(fixedClass)\n        .addClass(staticClass)\n        .data(dataTag, true);\n    }\n  };\n\n  /**\n   * Fires when message_bars_hidden is published\n   * @private\n   */\n  exports._hidden = function() {\n    var navbar = $('#js-navbar');\n    if (navbar.length === 0) {\n      return;\n    }\n\n    // We only make it fixed if we've set the data attribute in the message_bars_shown\n    // event.\n    if (navbar.data(dataTag) === true) {\n      navbar\n        .addClass(fixedClass)\n        .removeClass(staticClass)\n        .data(dataTag, false);\n    }\n  };\n\n  /**\n   * Initialise - note this must run before spweb.messageBars.init().\n   */\n  exports.init = function() {\n    // If we have shown the message bars, and if the navbar wants to be\n    // fixed, we disable the fixed.\n\n    pubSub.subscribe('message_bars_shown', function(){\n      exports._shown();\n    });\n\n    // If we have hidden the message bars, and if the navbar wants to be\n    // fixed, we make it fixed.\n    pubSub.subscribe('message_bars_hidden', function(){\n      exports._hidden();\n    });\n  };\n\n  return exports;\n\n}(jQuery, PubSub));\n"
    },
    405: function(n, e, t) {
        "use strict";
        t(0)(t(406))
    },
    406: function(n, e) {
        n.exports = "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n  (function() {\n    /**\n     * @file\n     * Introduces a function called \"defer\" that allows functions to be\n     * executed in the next available tick.\n     *\n     * Unlike \"setTimeout\", \"defer\" executes the function at the nearest\n     * possible time without clamping.\n     *\n     * @see Spotify.defer\n     */\n    'use strict';\n\n    var hasWindow = typeof window != 'undefined';\n    var hasDefineProperty = typeof Object.defineProperty == 'function';\n\n    if (hasWindow && window.__modDefFn) {\n      // If deferred has been attached to the global scope\n      module.exports = window.__modDefFn;\n      return;\n    }\n\n    /**\n     * Storage for deferred functions to be executed.\n     *\n     * @type {Array.<function()>}\n     * @private\n     */\n    var deferred = [];\n\n\n    /**\n     * A bound version of the postMessage routine used to trigger deferred\n     * execution.\n     *\n     * @type {function()}\n     * @private\n     */\n    var send;\n    var origin;\n\n    if (hasWindow && window.postMessage) {\n      origin = (window.location.origin ||\n        window.location.protocol + '//' + window.location.hostname);\n      send = window.postMessage.bind(window, '@execute_deferreds', origin);\n      if (!window.__hasDeferredHandler) {\n        if (hasDefineProperty) {\n          Object.defineProperty(window, '__hasDeferredHandler', {value: 1});\n        } else {\n          window.__hasDeferredHandler = 1;\n        }\n        var handler = function(e) {\n          if (e.origin != origin && e.data != '@execute_deferreds') {\n            return;\n          }\n          executeDeferreds();\n        };\n        if (window.addEventListener) {\n          window.addEventListener('message', handler);\n        } else {\n          window.attachEvent('onmessage', handler);\n        }\n      }\n    } else if (typeof setImmediate != 'undefined') {\n      send = setImmediate.bind(null, executeDeferreds);\n    } else {\n      send = setTimeout.bind(null, executeDeferreds, 10);\n    }\n\n\n    /**\n     * Executes the deferred functions when the window\n     * receives an 'execute_deferreds' message.\n     *\n     * @private\n     */\n    function executeDeferreds() {\n      var fns = deferred.splice(0);\n      if (!fns.length) return;\n      for (var i = 0, l = fns.length; i < l; i++) {\n        try {\n          fns[i]();\n        } finally {\n          // Do nothing.\n          null;\n        }\n      }\n    }\n\n\n    /**\n     * Executes the function applied at the nearest possible time without\n     * clamping.\n     *\n     * @param {function()} fn The function to execute.\n     */\n    var defer = function(fn) {\n      var trigger = !deferred.length;\n      deferred.push(fn);\n      if (trigger) send();\n    };\n\n    if (hasWindow && !window.__modDefFn) {\n      if (hasDefineProperty) {\n        Object.defineProperty(window, '__modDefFn', {value: defer});\n      } else {\n        window.__modDefFn = defer;\n      }\n    }\n\n    /**\n     * Export public interface\n     */\n    module.exports = defer;\n\n  })();\n\n},{}],2:[function(require,module,exports){\n  /**\n   * @module spotify-eventemitter\n   */\n  'use strict';\n\n  /**\n   * @private\n   */\n  var _defer = require('spotify-deferred');\n\n  /**\n   * The event handlers.\n   *\n   * @typedef {Array.<function>}\n   * @private\n   */\n  var EventHandlers;\n\n  /**\n   * Represents an Event.\n   *\n   * **NOTE**: The Event class is an internal class: you cannot instantiate it\n   * directly. Instead, you should use the provided\n   * {@link module:spotify-eventemitter.createEvent} function.\n   *\n   * @constructor\n   * @param {string} type The type name of the event object.\n   * @param {Object} props An object that will be added as properties of the\n   *     event object.\n   * @see {@link module:spotify-eventemitter.createEvent}\n   */\n  function Event(type, props) {\n    /**\n     * The type of the event.\n     *\n     * @type {string}\n     */\n    this.type = type;\n\n    /**\n     * A flag for whether preventDefault was called.\n     *\n     * @type {boolean}\n     * @private\n     */\n    this._prevented = false;\n\n    /**\n     * A flag for whether stopPropagation was called\n     *\n     * @type {boolean}\n     * @private\n     */\n    this._stopped = false;\n\n    /**\n     * A flag for whether stopImmediatePropagation was called.\n     *\n     * @type {boolean}\n     * @private\n     */\n    this._immediateStopped = false;\n\n    if (props) {\n      for (var key in props) {\n        if (key == 'type') {\n          continue;\n        }\n        this[key] = props[key];\n      }\n    }\n  }\n\n  /**\n   * Prevents the default operation for the event.\n   */\n  Event.prototype.preventDefault = function() {\n    this._prevented = true;\n  };\n\n  /**\n   * Returns whether preventDefault was called on the event.\n   *\n   * @return {boolean} True if preventDefault was called, false otherwise.\n   */\n  Event.prototype.isDefaultPrevented = function() {\n    return this._prevented;\n  };\n\n  /**\n   * Stops the propagation of the event.\n   */\n  Event.prototype.stopPropagation = function() {\n    this._stopped = true;\n  };\n\n  /**\n   * Returns whether stopPropagation was called on the event.\n   *\n   * @return {boolean} True if stopPropagation was called, false otherwise.\n   */\n  Event.prototype.isPropagationStopped = function() {\n    return this._stopped;\n  };\n\n  /**\n   * Stops the immediate propagation of the event.\n   *\n   * Handlers added after any event handler calling this method will not receive\n   * the event.\n   */\n  Event.prototype.stopImmediatePropagation = function() {\n    this._immediateStopped = true;\n  };\n\n  /**\n   * Returns whether stopImmediatePropagation was called on the event.\n   *\n   * @return {boolean} True if stopImmediatePropagation was called, false\n   *     otherwise.\n   */\n  Event.prototype.isImmediatePropagationStopped = function() {\n    return this._immediateStopped;\n  };\n\n  /**\n   * An EventEmitter is an object that can be listened to for events.\n   *\n   * Instances of this class are not usually used directly; instead, a class that\n   * needs EventEmitter functionality would inherit from the EventEmitter class\n   * so that it's instances can use events.\n   *\n   * @constructor\n   * @alias module:spotify-eventemitter\n   *\n   * @example <caption>Direct usage</caption>\n   * var EventEmitter = require('spotify-eventemitter');\n   * var emitter = new EventEmitter();\n   * emitter.addListener('someEvent', function() {\n *     console.log('someEvent fired!');\n * });\n   * emitter.emit('someEvent');\n   * @example <caption>Inheritance</caption>\n   * var EventEmitter = require('spotify-eventemitter');\n   * var inherit = require('spotify-inherit/inherit');\n   *\n   * function MyClass() {\n *   EventEmitter.call(this);\n * }\n   * inherit(MyClass, EventEmitter);\n   *\n   * var instance = new MyClass();\n   * instance.addListener('someEvent', function() {\n *     console.log('someEvent fired!');\n * });\n   * instance.emit('someEvent');\n   */\n  function EventEmitter() {\n    /**\n     * A map of event names to event handlers.\n     *\n     * @type {Object.<string, module:spotify-eventemitter~EventHandlers>}\n     * @private\n     */\n    this._listenerMap;\n  }\n\n  /**\n   * Creates a new Event object.\n   *\n   * @param {string} type The type name of the event.\n   * @param {Object=} opt_params An object containing properties for the new event\n   *     object.\n   * @return {module:spotify-eventemitter~Event} The new event object.\n   */\n  EventEmitter.createEvent = function(type, opt_params) {\n    return new Event(type, opt_params);\n  };\n\n  /**\n   * Adds an event listener to the emitter.\n   *\n   * This method is idempotent: calling it multiple times using the same type\n   * and listener arguments will only set the listener once. This behaviour is\n   * done to prevent accidental additions of the same event listener.\n   *\n   * @param {string} type The type of event to listen to.\n   * @param {function} listener A function to be called when the emitter fires\n   *     the event specified in the type.\n   * @return {module:spotify-eventemitter} The event emitter.\n   */\n  EventEmitter.prototype.addListener = function(type, listener) {\n    var _listenerMap = this._listenerMap || (this._listenerMap = {});\n    var listeners = _listenerMap[type] || (_listenerMap[type] = []);\n    if (listeners.indexOf(listener) != -1) {\n      // Handler already added, return quickly.\n      return this;\n    }\n    listeners.push(listener);\n    return this;\n  };\n\n  /**\n   * Adds multiple event listeners to the emitter.\n   *\n   * @param {Object.<string, function>} eventListeners An object, the keys of\n   *     which correspond to the name of events to listen to, and the value of\n   *     each of these keys should be a function that would be added as the\n   *     listener for that event.\n   * @return {module:spotify-eventemitter} The event emitter.\n   */\n  EventEmitter.prototype.addListeners = function(eventListeners) {\n    for (var type in eventListeners) {\n      this.addListener(type, eventListeners[type]);\n    }\n    return this;\n  };\n\n  /**\n   * Adds a \"once\" event listener to the emitter, which will be removed right\n   * after it has been fired.\n   *\n   * In order to achieve the \"once\" behaviour, the listener argument passed to\n   * this method is wrapped in a function, which is then returned by the method.\n   *\n   * Because of this wrapping, this method is not idempotent: calling it multiple\n   * times with the same type and listener arguments will result to multiple\n   * event listeners attached.\n   *\n   * @param {string} type The type of event to listen to.\n   * @param {function} listener A function to be called when the emitter fires\n   *     the event specified in the type and then automatically removed.\n   * @return {function} The function used to wrap the listener function argument.\n   *     This function can be used as an argument to removeEvent.\n   */\n  EventEmitter.prototype.addOnceListener = function(type, listener) {\n    var wrapper = function() {\n      this.removeListener(type, wrapper);\n      return listener.apply(this, arguments);\n    };\n    this.addListener(type, wrapper);\n    return wrapper;\n  };\n\n  /**\n   * Removes an event listener from the emitter.\n   *\n   * @param {string} type The type of event to remove.\n   * @param {function} listener The listener function to remove. This must be a\n   *     function that was added previously using addEvent.\n   * @return {module:spotify-eventemitter} The event emitter.\n   */\n  EventEmitter.prototype.removeListener = function(type, listener) {\n    var _listenerMap = this._listenerMap;\n    var listeners = _listenerMap && _listenerMap[type];\n    if (!listeners) {\n      return this;\n    }\n    var index = listeners.indexOf(listener);\n    if (index == -1) {\n      return this;\n    }\n    listeners.splice(index, 1);\n    if (!listeners.length) {\n      _listenerMap[type] = null;\n    }\n    return this;\n  };\n\n  /**\n   * Removes all event listeners from the emitter for a particular type.\n   *\n   * @param {string} type The event type to remove.\n   * @return {module:spotify-eventemitter} The event emitter.\n   */\n  EventEmitter.prototype.removeAllListeners = function(type) {\n    var _listenerMap = this._listenerMap;\n    if (!_listenerMap) {\n      return this;\n    }\n    _listenerMap[type] = null;\n    return this;\n  };\n\n  /**\n   * Removes multiple event listeners from the emitter.\n   *\n   * @param {Object.<string, function>} eventListeners An object, the keys of\n   *     which correspond to the name of events to listen to, and the value of\n   *     each of these keys should be a function that would be added as the\n   *     listener for that event.\n   * @return {module:spotify-eventemitter} The event emitter.\n   */\n  EventEmitter.prototype.removeListeners = function(eventListeners) {\n    for (var type in eventListeners) {\n      this.removeListener(type, eventListeners[type]);\n    }\n    return this;\n  };\n\n  /**\n   * Creates and emits an event on the emitter.\n   *\n   * This method invokes all the added event listeners of the `type` provided in\n   * the order they were added, passing in a new Event object created using the\n   * provided `type` and `opt_params` arguments.\n   *\n   * This method emits events asynchronously: the listeners are not called until\n   * the next run loop.\n   *\n   * @param {string} type The type name of the event to emit.\n   * @param {Object=} opt_params An object containing parameters for the Event\n   *     object.\n   * @return {module:spotify-eventemitter~Event} The Event object that was\n   *     created.\n   */\n  EventEmitter.prototype.emit = function(type, opt_params) {\n    var event = new Event(type, opt_params);\n    _defer(function() {\n      this.emitEventSync(event);\n    }.bind(this));\n    return event;\n  };\n\n  /**\n   * Emits an event on the emitter.\n   *\n   * This method invokes all the added event listeners of the `type` of the\n   * `event` provided in the order they were added, passing in the `event` as an\n   * argument.\n   *\n   * This method emits events asynchronously: the listeners are not called until\n   * the next run loop.\n   *\n   * @param {module:spotify-eventemitter~Event} event The Event object.\n   * @return {module:spotify-eventemitter~Event} The Event object that was passed.\n   */\n  EventEmitter.prototype.emitEvent = function(event) {\n    _defer(function() {\n      this.emitEventSync(event);\n    }.bind(this));\n    return event;\n  };\n\n  /**\n   * Creates and synchronously emits an event on the emitter.\n   *\n   * This method invokes all the added event listeners of the `type` provided in\n   * the order they were added, passing in a new Event object created using the\n   * provided `type` and `opt_params` arguments.\n   *\n   * @param {string} type The type name of event to emit.\n   * @param {Object=} opt_params An object containing parameters for the event\n   *     object.\n   * @return {module:spotify-eventemitter~Event} The Event object that was\n   *     created.\n   */\n  EventEmitter.prototype.emitSync = function(type, opt_params) {\n    var event = new Event(type, opt_params);\n    this.emitEventSync(event);\n    return event;\n  };\n\n  /**\n   * Synchronously emits an event on the emitter.\n   *\n   * This method invokes all the added event listeners of the `type` of the\n   * `event` provided in the order they were added, passing in the `event` as an\n   * argument.\n   *\n   * @param {module:spotify-eventemitter~Event} event The Event object.\n   * @return {module:spotify-eventemitter~Event} The Event object that was passed.\n   */\n  EventEmitter.prototype.emitEventSync = function(event) {\n    var type = event.type;\n    var _listenerMap = this._listenerMap;\n    var listeners = _listenerMap && _listenerMap[type];\n    if (!listeners || !listeners.length) {\n      return event;\n    }\n    listeners = listeners.slice(0);\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i].call(this, event);\n      if (event.isImmediatePropagationStopped()) {\n        break;\n      }\n    }\n    return event;\n  };\n\n// DEPRECATED METHODS:\n\n  /**\n   * Adds an event listener to the emitter.\n   *\n   * **NOTE**: This method has been deprecated in favor of\n   * {@link module:spotify-eventemitter#addListener}.\n   *\n   * This method is idempotent: calling it multiple times using the same type\n   * and listener arguments will only set the listener once. This behaviour is\n   * done to prevent accidental additions of the same event listener.\n   *\n   * @deprecated since v2.0.0.\n   * @param {string} type The type of event to listen to.\n   * @param {function} listener A function to be called when the emitter fires\n   *     the event specified in the type.\n   * @return {module:spotify-eventemitter} The event emitter.\n   * @see {@link module:spotify-eventemitter#addListener}\n   */\n  EventEmitter.prototype.addEvent = function(type, listener) {\n    return this.addListener(type, listener);\n  };\n\n  /**\n   * Adds multiple event listeners to the emitter.\n   *\n   * **NOTE**: This method has been deprecated in favor of\n   * {@link module:spotify-eventemitter#addListeners}.\n   *\n   * @deprecated since v2.0.0.\n   * @param {Object.<string, function>} eventListeners An object, the keys of\n   *     which correspond to the name of events to listen to, and the value of\n   *     each of these keys should be a function that would be added as the\n   *     listener for that event.\n   * @return {module:spotify-eventemitter} The event emitter.\n   * @see {@link module:spotify-eventemitter#addListeners}\n   */\n  EventEmitter.prototype.addEvents = function(eventListeners) {\n    return this.addListeners(eventListeners);\n  };\n\n  /**\n   * Adds a \"once\" event listener to the emitter, which will be removed right\n   * after it has been fired.\n   *\n   * **NOTE**: This method has been deprecated in favor of\n   * {@link module:spotify-eventemitter#addOnceListener}.\n   *\n   * In order to achieve the \"once\" behaviour, the listener argument passed to\n   * this method is wrapped in a function, which is then returned by the method.\n   *\n   * Because of this wrapping, this method is not idempotent: calling it multiple\n   * times with the same type and listener arguments will result to multiple\n   * event listeners attached.\n   *\n   * @deprecated since v2.0.0.\n   * @param {string} type The type of event to listen to.\n   * @param {function} listener A function to be called when the emitter fires\n   *     the event specified in the type and then automatically removed.\n   * @return {function} The function used to wrap the listener function argument.\n   *     This function can be used as an argument to removeEvent.\n   * @see {@link module:spotify-eventemitter#addOnceListener}\n   */\n  EventEmitter.prototype.addOnceEvent = function(type, listener) {\n    return this.addOnceListener(type, listener);\n  };\n\n  /**\n   * Removes an event listener from the emitter.\n   *\n   * **NOTE**: This method has been deprecated in favor of\n   * {@link module:spotify-eventemitter#removeListener}.\n   *\n   * @deprecated since v2.0.0.\n   * @param {string} type The type of event to remove.\n   * @param {function} listener The listener function to remove. This must be a\n   *     function that was added previously using addEvent.\n   * @return {module:spotify-eventemitter} The event emitter.\n   * @see {@link module:spotify-eventemitter#removeListener}\n   */\n  EventEmitter.prototype.removeEvent = function(type, listener) {\n    return this.removeListener(type, listener);\n  };\n\n  /**\n   * Removes multiple event listeners from the emitter.\n   *\n   * **NOTE**: This method has been deprecated in favor of\n   * {@link module:spotify-eventemitter#removeListeners}.\n   *\n   * @deprecated since v2.0.0.\n   * @param {Object.<string, function>} events An object, the keys of which\n   *     correspond to the name of events to remove, and the value of each of\n   *     these keys should be a function that would be removed as a listener.\n   * @return {module:spotify-eventemitter} The event emitter.\n   * @see {@link module:spotify-eventemitter#removeListeners}\n   */\n  EventEmitter.prototype.removeEvents = function(eventListeners) {\n    return this.removeListeners(eventListeners);\n  };\n\n  /**\n   * Fires an event on the emitter, optionally passing arguments to the listeners.\n   *\n   * **NOTE**: This method has been deprecated in favor of\n   * {@link module:spotify-eventemitter#emit}.\n   *\n   * This method fire events asynchronously: the listeners are not called until\n   * the next run loop. A third boolean parameter can be passed to change this\n   * behaviour.\n   *\n   * @deprecated since v2.0.0.\n   * @param {string} type The type of event to fire.\n   * @param {Array.<*>=} opt_args A set of objects that would be passed to the\n   *     event listeners as arguments.\n   * @param {boolean=} opt_priority Passing true will fire the event synchronously.\n   * @return {module:spotify-eventemitter} The event emitter.\n   * @see {@link module:spotify-eventemitter#emit}\n   */\n  EventEmitter.prototype.fireEvent = function(type, opt_args, opt_priority) {\n    if (opt_priority) {\n      this.fireEventSync(type, opt_args);\n    } else {\n      var self = this;\n      _defer(function() { self.fireEventSync(type, opt_args); });\n    }\n    return this;\n  };\n\n  /**\n   * Fires an event on the emitter synchronously, optionally passing arguments to\n   * the listeners.\n   *\n   * **NOTE**: This method has been deprecated in favor of\n   * {@link module:spotify-eventemitter#emitSync}.\n   *\n   * @deprecated since v2.0.0.\n   * @param {string} type The type of event to fire.\n   * @param {Array.<*>=} opt_args A set of objects that would be passed to the\n   *     event listeners as arguments.\n   * @return {module:spotify-eventemitter} The event emitter.\n   * @see {@link module:spotify-eventemitter#emitSync}\n   */\n  EventEmitter.prototype.fireEventSync = function(type, opt_args) {\n    var self = this;\n    var events = this._listenerMap && this._listenerMap[type];\n    if (!events || !events.length) return this;\n    events = events.slice(0);\n    var i, l;\n    if (!opt_args) {\n      for (i = 0, l = events.length; i < l; i++) {\n        events[i].call(self);\n      }\n    } else {\n      if (!Array.isArray(opt_args)) {\n        opt_args = [opt_args];\n      }\n      for (i = 0, l = events.length; i < l; i++) {\n        events[i].apply(self, opt_args);\n      }\n    }\n    return this;\n  };\n\n  /**\n   * Adds an event listener to the emitter.\n   *\n   * **NOTE**: This method has been deprecated in favor of\n   * {@link module:spotify-eventemitter#addListener}.\n   *\n   * This method is idempotent: calling it multiple times using the same type\n   * and listener arguments will only set the listener once. This behaviour is\n   * done to prevent accidental additions of the same event listener.\n   *\n   * @deprecated since v2.0.0.\n   * @param {string} type The type of event to listen to.\n   * @param {function} listener A function to be called when the emitter fires\n   *     the event specified in the type.\n   * @return {module:spotify-eventemitter} The event emitter.\n   * @see {@link module:spotify-eventemitter#addListener}\n   */\n  EventEmitter.prototype.on = function(type, listener) {\n    return this.addEvent(type, listener);\n  };\n\n  /**\n   * Adds a \"once\" event listener to the emitter, which will be removed right\n   * after it has been fired.\n   *\n   * **NOTE**: This method has been deprecated in favor of\n   * {@link module:spotify-eventemitter#addOnceListener}.\n   *\n   * In order to achieve the \"once\" behaviour, the listener argument passed to\n   * this method is wrapped in a function, which is then returned by the method.\n   *\n   * Because of this wrapping, this method is not idempotent: calling it multiple\n   * times with the same type and listener arguments will result to multiple\n   * event listeners attached.\n   *\n   * @deprecated since v2.0.0.\n   * @param {string} type The type of event to listen to.\n   * @param {function} listener A function to be called when the emitter fires\n   *     the event specified in the type and then automatically removed.\n   * @return {function} The function used to wrap the listener function argument.\n   *     This function can be used as an argument to removeEvent.\n   * @see {@link module:spotify-eventemitter#addOnceListener}\n   */\n  EventEmitter.prototype.once = function(type, listener) {\n    return this.addOnceEvent(type, listener);\n  };\n\n  /**\n   * Removes an event listener or all event listeners from the emitter.\n   *\n   * **NOTE**: This method has been deprecated in favor of\n   * {@link module:spotify-eventemitter#removeListener}.\n   *\n   * @deprecated since v2.0.0.\n   * @param {string} type The type of event to remove.\n   * @param {function=} opt_listener The listener function to remove. This must be\n   *     a function that was added previously using addEvent. If this parameter is\n   *     not given, all event listeners of the corresponding `type` argument will\n   *     be removed.\n   * @return {module:spotify-eventemitter} The event emitter.\n   * @see {@link module:spotify-eventemitter#removeListener}\n   * @see {@link module:spotify-eventemitter#removeListeners}\n   */\n  EventEmitter.prototype.off = function(type, opt_listener) {\n    if (typeof opt_listener === 'function') {\n      return this.removeEvent(type, opt_listener);\n    }\n    // if no listener set, remove all the listeners from the event\n    this._listenerMap[type] = null;\n    return this;\n  };\n\n  /**\n   * Exporting\n   */\n  module.exports = EventEmitter;\n\n},{\"spotify-deferred\":1}],3:[function(require,module,exports){\n  'use strict';\n\n  /**\n   * Makes a class inherit from a superclass' prototype indirectly.\n   *\n   * @param {Spotify.ClassLike} Sub The class that will inherit.\n   * @param {Spotify.ClassLike} Super The class to inherit from.\n   */\n  var inherit = function(Sub, Super) {\n    var superProto = Super.prototype;\n    function Superclass() {}\n    Superclass.prototype = Sub._super = superProto;\n    Superclass.prototype.constructor = Super;\n    Sub.prototype = new Superclass();\n  };\n\n\n  /**\n   * Export public interface\n   */\n  module.exports = inherit;\n\n},{}],4:[function(require,module,exports){\n  arguments[4][1][0].apply(exports,arguments)\n},{\"dup\":1}],5:[function(require,module,exports){\n  /**\n   * @file\n   * Implements a Promise class that represents an eventually resolved value.\n   */\n  'use strict';\n\n\n  /**\n   * @type {function(number, number)}\n   * @private\n   */\n  var slice = Array.prototype.slice;\n\n  var defer = require('spotify-deferred');\n\n\n  /**\n   * A utility function for piping the values of a promise to another promise.\n   *\n   * Used internally to avoid having to use bind.\n   *\n   * @param {Spotify.Promise} promiseA The first promise.\n   * @param {Spotify.Promise} promiseB The second promise.\n   * @private\n   */\n  function pipe(promiseA, promiseB) {\n    promiseA.then(function(object) {\n      promiseB.fulfill(object);\n    }, function(error) {\n      promiseB.fail(error);\n    });\n  }\n\n\n  /**\n   * The state of the the promise.\n   *\n   * @enum {number}\n   * @private\n   */\n  var states = {\n    UNFULFILLED: 0,\n    FULFILLED: 1,\n    FAILED: 2\n  };\n\n\n  /**\n   * A promise object.\n   *\n   * @constructs Spotify.Promise\n   */\n  function Promise() {\n    this._state = states.UNFULFILLED;\n    this._value = null;\n    this._handlers = [];\n    this._deferred = false;\n  }\n\n\n  /**\n   * Defers a promise.\n   *\n   * @private\n   */\n  Promise.defer = typeof setImmediate == 'function' ?\n    // We wrap setImmediate (which is used in node) in a function because IE10\n    // exports its own non-standard setImmediate function. This IE function\n    // depends on being called from a global scope (most likely because of a\n    // binding within the native implementation).\n    function(fn) { setImmediate(fn); } :\n    defer;\n\n\n  /**\n   * Check whether the promise is unfulfilled.\n   *\n   * @return {boolean} True if the promise hasn't been fulfilled.\n   */\n  Promise.prototype.isUnfulfilled = function() {\n\n    return this._state == states.UNFULFILLED;\n  };\n\n\n  /**\n   * Check whether the promise has been fulfilled.\n   *\n   * @return {boolean} True if the promise has been fulfilled and\n   *     didn't fail.\n   */\n  Promise.prototype.isFulfilled = function() {\n    return this._state == states.FULFILLED;\n  };\n\n\n  /**\n   * Check whether the promise has failed.\n   *\n   * @return {boolean} True if the promise has failed.\n   */\n  Promise.prototype.isFailed = function() {\n    return this._state == states.FAILED;\n  };\n\n\n  /**\n   * Fulfills the promise.\n   *\n   * @param {*} value The fulfilled value of the promise.\n   */\n  Promise.prototype.fulfill = function(value) {\n    var self = this;\n    if (this._state !== states.UNFULFILLED) return;\n    this._value = value;\n    this._state = states.FULFILLED;\n    if (!this._deferred) {\n      Promise.defer(function() { self._runHandlers(); });\n      this._deferred = true;\n    }\n    return;\n  };\n\n\n  /**\n   * Fails the promise.\n   *\n   * @param {*} error The failed value of the promise.\n   */\n  Promise.prototype.fail = function(error) {\n    var self = this;\n    if (this._state !== states.UNFULFILLED) return;\n    this._value = error;\n    this._state = states.FAILED;\n    if (!this._deferred) {\n      Promise.defer(function() { self._runHandlers(); });\n      this._deferred = true;\n    }\n    return;\n  };\n\n\n  /**\n   * Adds fulfillment and failure handlers to the promise.\n   *\n   * @param {function(*)} fulfilledHandler The function to be called when a\n   *     promise is fulfilled.\n   * @param {function(*)} failedHandler The function to be called when a\n   *     promise failed.\n   * @return {Spotify.Promise} A new promise that could be used to chain handlers.\n   */\n  Promise.prototype.then = function(fulfilledHandler, failedHandler) {\n    var self = this;\n    var promise = new Promise();\n    this._handlers.push({\n      fulfilled: fulfilledHandler,\n      failed: failedHandler,\n      promise: promise\n    });\n    if (this._state !== states.UNFULFILLED && !this._deferred) {\n      Promise.defer(function() { self._runHandlers(); });\n      this._deferred = true;\n    }\n    return promise;\n  };\n\n\n  /**\n   * Passes the fulfillment or failure values of one promise to another.\n   *\n   * @param {Spotify.Promise} promise The promise to which the values will be passed.\n   */\n  Promise.prototype.pipe = function(promise) {\n    this.then(function(value) {\n      promise.fulfill(value);\n    }, function(error) {\n      promise.fail(error);\n    });\n    return;\n  };\n\n\n  /**\n   * Executes the handlers after a promise has been resolved.\n   *\n   * @private\n   */\n  Promise.prototype._runHandlers = function() {\n    this._deferred = false;\n    var value = this._value;\n    if (this._state == states.UNFULFILLED) return;\n    var fulfilled = this._state === states.FULFILLED;\n    var handlers = this._handlers.splice(0);\n    var callbackType = fulfilled ? 'fulfilled' : 'failed';\n    for (var i = 0, l = handlers.length; i < l; i++) {\n      var handler = handlers[i];\n      var callback = handler[callbackType];\n      var promise = handler.promise;\n      if (!callback || typeof callback != 'function') {\n        if (value && typeof value.then == 'function') {\n          pipe(value, promise);\n          continue;\n        } else {\n          if (fulfilled) {\n            promise.fulfill(value);\n          } else {\n            promise.fail(value);\n          }\n          continue;\n        }\n      }\n      try {\n        var returnValue = callback(value);\n      } catch (e) {\n        promise.fail(e);\n        continue;\n      }\n      if (returnValue && typeof returnValue.then == 'function') {\n        pipe(returnValue, promise);\n      } else {\n        promise.fulfill(returnValue);\n      }\n    }\n  };\n\n\n// Convenience Methods\n\n\n  /**\n   * A convenience method for adding a failedHandler to a promise\n   * without adding a fulfillmentHandler.\n   *\n   * @param {function(*)} failedHandler A function that will be called\n   *     when a promise fails.\n   * @return {Spotify.Promise} A new promise that could be used to chain\n   *     other handlers.\n   */\n  Promise.prototype.catchError = function(failedHandler) {\n    return this.then(null, failedHandler);\n  };\n\n\n  /**\n   * A convenience method that will return a promise that resolves\n   * to a named property of the fulfillment value of the current\n   * promise.\n   *\n   * @param {string} property The property to resolve.\n   * @return {Spotify.Promise} A promise that will be resolved to the value\n   *     of the current promises' named property.\n   */\n  Promise.prototype.get = function(property) {\n    var promise = new Promise();\n    this.then(function(object) {\n      if (property in object) {\n        promise.fulfill(object[property]);\n      } else {\n        promise.fail(\n          new TypeError('No property \"' + property + '\" in object.')\n        );\n      }\n    }, function(error) {\n      promise.fail(error);\n    });\n    return promise;\n  };\n\n\n  /**\n   * A convenience method that will return a promise that resolves to a set of\n   * named-properties of the fulfillment values of the promise.\n   *\n   * @param {...string} var_args A set of property names.\n   * @return {Spotify.Promise} A promise that will be fulfilled with the proper\n   *     value or a TypeError.\n   */\n  Promise.prototype.access = function(var_args) {\n    var_args = Array.isArray(var_args) ? var_args : slice.call(arguments);\n    var promise = this;\n    for (var i = 0, l = var_args.length; i < l; i++) {\n      promise = promise.get(var_args[i]);\n    }\n    return promise;\n  };\n\n\n  /**\n   * A convenience method that will execute a method of the current\n   * promise's fulfillment value.\n   *\n   * @param {string} method The method to execute.\n   * @param {...*} var_args The arguments to apply for the method.\n   * @return {Spotify.Promise} A promise that will be resolved to the return\n   *     value of the current promises' method after execution.\n   */\n  Promise.prototype.call = function(method, var_args) {\n    var args = slice.call(arguments, 1);\n    var promise = new Promise();\n    this.then(function(object) {\n      try { promise.fulfill(object[method].apply(object, args)); }\n      catch (e) { promise.fail(e); }\n    }, function(error) {\n      promise.fail(error);\n    });\n    return promise;\n  };\n\n\n  /**\n   * Works similar to the then() method, but spread an array fulfillment\n   * value as parameters to the fulfilledHandler.\n   *\n   * @param {function(...*)} fulfilledHandler The function to be called when a\n   *     promise is fulfilled.\n   * @param {function(*)} failedHandler The function to be called when a\n   *     promise failed.\n   * @return {Spotify.Promise} A new promise that could be used to chain handlers.\n   */\n  Promise.prototype.thenSpread = function(fulfilledHandler, failedHandler) {\n    return this.then(function(value) {\n      return Array.isArray(value) ? fulfilledHandler.apply(this, value) : fulfilledHandler.call(this, value);\n    }, failedHandler);\n  };\n\n\n  /**\n   * Creates a joined promise, which will be fulfilled with the values\n   * of all the promises passed to the function.\n   *\n   * The returned promise is failed immediately if one of the promises fails.\n   *\n   * @param {Array.<Spotify.Promise>|...Spotify.Promise} promises\n   *     The promises to join.\n   * @return {Spotify.Promise} The promise that will be fulfilled\n   *     with the values of all promises passed.\n   */\n  Promise.join = function(promises) {\n    promises = Array.isArray(promises) ? promises : slice.call(arguments);\n    var promise = new Promise();\n    var length = promises.length;\n    var result = [];\n    var failed = false;\n    var aggregator = function(index, obj) {\n      if (failed) return;\n      result[index] = obj;\n      length--;\n      if (!length) promise.fulfill(result);\n    };\n    var failure = function(error) {\n      if (failed) return;\n      failed = true;\n      promise.fail(error);\n    };\n    for (var i = 0, l = length; i < l; i++) {\n      var p = promises[i];\n      if (!p || !p.then) {\n        aggregator(i, p);\n      } else {\n        p.then(aggregator.bind(null, i), failure);\n      }\n    }\n    return promise;\n  };\n\n\n  /**\n   * Creates a grouping promise, which can be used to fullfill all the\n   * promises passed.\n   *\n   * @param {Array.<Spotify.Promise>|...Spotify.Promise} promises\n   *     The promises to group.\n   * @return {Spotify.Promise} A promise that can be used to fulfill\n   *     all the promises passed.\n   */\n  Promise.group = function(promises) {\n    promises = Array.isArray(promises) ? promises : slice.call(arguments);\n    var promise = new Promise();\n    for (var i = 0, l = promises.length; i < l; i++) {\n      promise.pipe(promises[i]);\n    }\n    return promise;\n  };\n\n\n  /**\n   * Export public interface\n   */\n  module.exports = Promise;\n\n},{\"spotify-deferred\":4}],6:[function(require,module,exports){\n  'use strict';\n\n  var inherit = require('spotify-inheritance/inherit');\n  var EventEmitter = require('spotify-eventemitter');\n  var Promise = require('spotify-promise');\n\n  /**\n   * The Spotify Remote Control (WebHelper) JS wrapper constructor.\n   *\n   * @param {Object} settings   The settings object\n   * @params {?Object} win   The mocked window object. Only used for testing purposes.\n   */\n  function RemoteControl(settings, win) {\n    if (!this instanceof RemoteControl) {\n      return new RemoteControl(options);\n    }\n    EventEmitter.call(this);\n\n    settings = settings || {};\n\n    this._win = win || window;\n    this._protocol = settings.protocol || this._win.location.protocol;\n\n    this._csrf = '';\n    if (settings.debug) {\n      this._startPort = this._endPort = settings.port;\n    } else {\n      this._startPort = 'https:' === this._protocol ? 4370 : 4380;\n      this._endPort = 'https:' === this._protocol ? 4379 : 4389;\n    }\n    this._currentPort = this._startPort;\n    this._runningPort = 0;\n    this._subdomain = '';\n    this._clientOpen = false;\n    this._clientRunning = false;\n    this._connected = false;\n    this._backoffIndex = 0;\n    this.state = null;\n    if (settings.hasOwnProperty('autoOpen')) {\n      this._autoOpen = settings.autoOpen;\n    } else {\n      this._autoOpen = false;\n    }\n    this._retryConnect = settings.retryConnect || false;\n    this._reconnectOnLogout = settings.reconnectOnLogout || false;\n    this._reopenOnReconnect = settings.reopenOnReconnect || false;\n    this._localhost = settings.debug || settings.localhost || false;\n    this._pollClient = settings.pollClient || false;\n    this._pollBackoff = settings.pollBackoff || [1, 1, 1, 1, 3, 3, 5];\n    this._longPollingTime = settings.longPollingTime || 60000;\n    this._token = settings.token || '';\n    this._referrer = settings.referrer || this._win.location.href;\n  }\n  inherit(RemoteControl, EventEmitter);\n  module.exports = RemoteControl;\n\n  /**\n   * @var {Object}   Events that are fired by the remoteControl.\n   */\n  var Event = {\n    'STATUS_CHANGE': 'STATUS_CHANGE',\n    'CONNECTION_ESTABLISHED': 'CONNECTION_ESTABLISHED',\n    'CONNECTION_FAILED': 'CONNECTION_FAILED'\n  };\n  RemoteControl.Event = Event;\n\n  /**\n   * @var {Object}   Error types that can be returned in an event\n   */\n  var Error = {\n    'INVALID_OAUTH_TOKEN': '4102',\n    'EXPIRED_OAUTH_TOKEN': '4103',\n    'INVALID_CSRF_TOKEN': '4107',\n    'OAUTH_TOKEN_INVALID_FOR_USER': '4108',\n    'NO_USER_LOGGED_IN': '4110',\n    'COULD_NOT_DETECT_PORT': '6000',\n    'COULD_NOT_OPEN_CLIENT': '6010',\n    'COULD_NOT_FETCH_CSRF_TOKEN': '6020',\n    'COULD_NOT_FETCH_STATUS': '6030',\n    'COULD_NOT_PLAY_TRACK': '6040',\n    'NO_TRACK_LOADED': '6050',\n    'CORS_REQUESTS_DISABLED': '6060',\n    'REQUEST_TIMED_OUT': '6061'\n  };\n  RemoteControl.Error = Error;\n\n  /**\n   * Check if the submitted uri is the track currently playing\n   *\n   * @param {String} uri   The trackUri to check for\n   * @return {bool}   true if the specified track uri is the\n   *                  one currently playing, else false.\n   */\n  RemoteControl.prototype.isCurrent = function(uri) {\n    var state = this.state;\n    return state !== null && state.track && state.track.track_resource &&\n      state.track.track_resource.uri == uri;\n  };\n\n  /**\n   * Check if remote control API is enabled\n   * This will return false until the port has been detected.\n   *\n   * @return {bool}   true if remote control enabled, else false.\n   */\n  RemoteControl.prototype.enabled = function() {\n    return this._runningPort > 0;\n  }\n\n  /**\n   * Detect what port the webHelper is running on.\n   *\n   * In case this._pollClient == true, it will continue to\n   * poll for the port until it finds it according to the\n   * poll backoff schema specified in this._pollBackoff\n   *\n   * @param {?Promise} promise   The promise to fulfill if found.\n   *                             Only used by the funtion itself.\n   * @return {Promise}\n   * @private\n   */\n  RemoteControl.prototype._detectPort = function(promise) {\n\n    promise = promise || new Promise();\n    if (0 < this._runningPort) {\n      promise.fulfill(this._runningPort);\n    } else {\n      var self = this;\n      var url = this._buildUrl('service/version.json', {service: 'remote'});\n\n      self._request(url, function(err, result) {\n        if (err) {\n          if (self._currentPort < self._endPort) {\n            self._currentPort++;\n            self._detectPort(promise);\n          } else if (self._pollClient) {\n            self._currentPort = self._startPort;\n            setTimeout(function() {\n              self._detectPort(promise);\n            }, self._nextPollInterval() * 1000);\n          } else {\n            promise.fail({type: Error.COULD_NOT_DETECT_PORT, message: 'Could not detect any port'});\n          }\n        } else {\n          self._resetBackoffCounter();\n          self._runningPort = self._currentPort;\n          self._clientRunning = true;\n          self._clientOpen = result.running !== false;\n          promise.fulfill(self._currentPort);\n        }\n      });\n    }\n\n    return promise;\n  };\n\n  /**\n   * Open the client if it is not already running\n   *\n   * @return {Promise}\n   * @private\n   */\n  RemoteControl.prototype._openClient = function() {\n    var self = this;\n\n    var promise = new Promise();\n    if (self._clientOpen) {\n      promise.fulfill();\n    } else if (self._autoOpen){\n      var url = self._buildUrl('remote/open.json');\n\n      self._request(url, function(err, result) {\n        if (err) {\n          promise.fail({type: Error.COULD_NOT_OPEN_CLIENT, message: 'Could not open client'});\n        } else {\n          if (!result.running) {\n            promise.fail({type: Error.COULD_NOT_OPEN_CLIENT, message: 'Could not open client'});\n          } else {\n            self._clientOpen = true;\n            promise.fulfill();\n          }\n        }\n      }, 10000);\n    } else {\n      promise.fulfill();\n    }\n\n    return promise;\n\n  };\n\n  /**\n   * Fetch the csrf token to use with the web helper.\n   *\n   * @return {Promise}\n   * @private\n   */\n  RemoteControl.prototype._csrfToken = function() {\n    var self = this;\n\n    var promise = new Promise();\n\n    if ('' !== self._csrf) {\n      promise.fulfill(self._csrf);\n    } else {\n      var url = self._buildUrl('simplecsrf/token.json');\n\n      self._request(url, function(err, result) {\n        if (err) {\n          promise.fail({type: Error.COULD_NOT_FETCH_CSRF_TOKEN, message: 'Could not fetch csrf token'});\n        } else {\n          if (!result.token) {\n            promise.fail({type: Error.COULD_NOT_FETCH_CSRF_TOKEN, message: 'Could not fetch csrf token'});\n          } else {\n            self._csrf = result.token;\n            promise.fulfill(result.token);\n          }\n        }\n      });\n    }\n\n    return promise;\n  };\n\n  /**\n   * Fetch the current status from the client\n   *\n   * If this function is used for longPolling the status, it will not\n   * return until the status changes.\n   *\n   * @param {bool} longPolling   Pass true to not return until status changes\n   * @param {int} timeout   The timeout to use for the request\n   * @return {Promise}\n   * @private\n   */\n  RemoteControl.prototype._status = function(longPolling, callback, timeout) {\n    var self = this;\n\n    var params = {\n      'csrf': self._csrf,\n      'oauth': self._token\n    };\n    timeout = timeout || 500;\n    if (longPolling) {\n      params['returnon'] = 'login,logout,play,pause,error,ap';\n      params['returnafter'] = timeout / 1000;\n    }\n\n    var url = self._buildUrl('remote/status.json', params);\n\n    this._request(url, function(err, result) {\n      if (err) {\n        var type = err.type || Error.COULD_NOT_FETCH_STATUS;\n        callback({type: type, message: 'Could not fetch status'});\n      } else {\n        if (result.error) {\n          if (result.running === false) {\n            self._clientOpen = false;\n          }\n          callback(result.error);\n        } else {\n          callback(null, result);\n        }\n      }\n    }, timeout + 1000); // To let the long polling function return\n  };\n\n  /**\n   * The event loop runner that opens a long polling connection to\n   * listen for status changes. The event loop will be restarted every\n   * time it gets a response or times out.\n   *\n   * This function is the one dispatching events that the user of this\n   * class can listen for.\n   *\n   * @private\n   */\n  RemoteControl.prototype._statusChange = function() {\n    var self = this;\n    this._status(true, function(err, status) {\n      if (err) {\n        err.code = err.code || err.type;\n        switch(err.code) {\n          case Error.NO_USER_LOGGED_IN:\n            // Login user if possible\n            self._connected = false;\n            self._connection = null;\n            if (self._reconnectOnLogout) {\n              self._reconnect();\n            }\n            self.emit(Event.CONNECTION_FAILED, err);\n            break;\n          case Error.INVALID_OAUTH_TOKEN:\n          case Error.EXPIRED_OAUTH_TOKEN:\n          case Error.OAUTH_TOKEN_INVALID_FOR_USER:\n            self._token = '';\n            self._connected = false;\n            self._connection = null;\n            self.emit(Event.CONNECTION_FAILED, err);\n            break;\n          case Error.INVALID_CSRF_TOKEN:\n            self._csrf = '';\n            self._csrfToken()\n              .then(function() {\n                self._statusChange();\n                return;\n              });\n            break;\n          default:\n            self._connected = false;\n            self._connection = null;\n            self.emit(Event.CONNECTION_FAILED, err);\n            break;\n        }\n      } else {\n        self._statusChange();\n        self.state = status;\n        self.emit(Event.STATUS_CHANGE, status);\n      }\n    }, self._longPollingTime);\n  };\n\n  /**\n   * Connect to the web helper by fetching status\n   * and starting the event loop handler\n   *\n   * @return {Promise}   The current status of the client\n   * @private\n   */\n  RemoteControl.prototype._connect = function() {\n    var self = this;\n    var promise = new Promise();\n    if (self._connected) {\n      promise.fulfill(self.state);\n    } else {\n      self._status(false, function(err, status) {\n        if (err) {\n          switch (err.type) {\n            case Error.NO_USER_LOGGED_IN:\n              if (self._retryConnect) {\n                setTimeout(function() {\n                  self._reconnect()\n                    .then(function(status) {\n                      promise.fulfill(status);\n                    });\n                }, self._nextPollInterval() * 1000);\n              } else {\n                promise.fail(err);\n              }\n              break;\n            default:\n              promise.fail(err);\n              break;\n          }\n        } else {\n          self._resetBackoffCounter();\n          self._connected = true;\n          self.state = status;\n          self._statusChange();\n          promise.fulfill(status);\n        }\n      });\n    }\n    return promise;\n  }\n\n  /**\n   * Connect to the web helper to be able to control the client\n   *\n   * This function starts the event loop and returns a promise\n   * with the current status.\n   *\n   * @return {Promise}   A promise with the current status\n   */\n  RemoteControl.prototype.connect = function() {\n    var self = this;\n    if (!this._connection) {\n      this._connection = this._detectPort()\n        .then(function() {\n          return self._openClient();\n        })\n        .then(function() {\n          return self._csrfToken();\n        })\n        .then(function() {\n          return self._connect();\n        });\n    }\n    return this._connection\n      .then(function(status) {\n        return self.state || status;\n      });\n  };\n\n  /**\n   * Start a reconnection loop to detect when client has been started\n   *\n   * @return {Promise}   A promise with the current status\n   */\n  RemoteControl.prototype._reconnect = function() {\n    var self = this;\n    return this._detectPort()\n      .then(function() {\n        if (self._reopenOnReconnect) {\n          return self._openClient()\n        } else {\n          return self;\n        }\n      })\n      .then(function() {\n        return self._csrfToken();\n      })\n      .then(function() {\n        return self._connect();\n      });\n  }\n\n  /**\n   * Set the oauth token to use when connecting.\n   *\n   * This can be used when the oauth token needs to be update,\n   * for example when it has expired.\n   *\n   * @param {String} token   The new oauth token.\n   */\n  RemoteControl.prototype.setToken = function(token) {\n    this._token = token;\n  };\n\n  /**\n   * Play a specified context or track\n   *\n   * If the trackUri is omitted, the first playable track of the\n   * context is being played instead.\n   *\n   * @param {String} context   The context URI\n   * @param {?String} trackUri   The track URI to play.\n   * @return {Promise}   A promise with the updated status\n   */\n  RemoteControl.prototype.play = function(context, trackUri) {\n\n    var self = this;\n    var playPromise = (this._playPromise && this._connection) ? this._playPromise : this.connect();\n    return this._playPromise = playPromise\n      .then(function(status) {\n        var params = {\n          'csrf': self._csrf,\n          'oauth': self._token,\n          'context': context\n        };\n        params['uri'] = trackUri || context;\n\n        var promise = new Promise();\n\n        var url = self._buildUrl('remote/play.json', params);\n        self._request(url, function(err, result) {\n          if (err) {\n            var type = err.type || Error.COULD_NOT_PLAY_TRACK;\n            //throw {type: type, message: 'Could not play track'};\n            promise.fulfill();\n          } else {\n            if (result.error) {\n              //throw result.error;\n              promise.fulfill();\n            } else {\n              self.state = result;\n              self.emit(Event.STATUS_CHANGE, result);\n              promise.fulfill(result);\n            }\n          }\n        });\n\n        return promise;\n      },\n      function(error) {\n        self._playPromise = null;\n        throw error;\n      });\n  };\n\n  /**\n   * Pause or resume any current loaded track depending\n   * on what is specified.\n   *\n   * @param {bool} pause   Set to true to pause the track\n   *                       and to false to resume it.\n   * @return {Promise}   A promise with the updated state after operation.\n   * @private\n   */\n  RemoteControl.prototype._pause = function(pause) {\n    var promise = new Promise();\n\n    var params = {\n      'csrf': this._csrf,\n      'oauth': this._token,\n      'pause': pause === true ? 'true' : 'false'\n    };\n\n    var url = this._buildUrl('remote/pause.json', params);\n    this._request(url, function(err, result) {\n      if (err) {\n        var type = err.type || Error.COULD_NOT_TOGGLE_PLAYBACK;\n        promise.fail({type: type, message: 'Could not toggle playback'});\n      } else {\n        if (result.error) {\n          promise.fail(result.error);\n        } else {\n          promise.fulfill(result);\n        }\n      }\n    });\n\n    return promise;\n  };\n\n  /**\n   * Pauses any loaded and playing track\n   *\n   * @return {Promise}   A promise with the paused status\n   */\n  RemoteControl.prototype.pause = function() {\n    var self = this;\n    return this.connect()\n      .then(function(status) {\n        var promise = new Promise();\n        if (!status.track || !status.track.track_resource || !status.track.track_resource.uri) {\n          promise.fail({\n            type: Error.NO_TRACK_LOADED,\n            message: 'Could not pause non existing track'\n          });\n        } else {\n          self._pause(true)\n            .then(function(pauseStatus) {\n              promise.fulfill(pauseStatus);\n            });\n        }\n        return promise;\n      });\n  };\n\n  /**\n   * Toggle play pause for a loaded track\n   *\n   * @return {Promise}   A promise with the status after toggle\n   */\n  RemoteControl.prototype.toggle = function() {\n    var self = this;\n    return this.connect()\n      .then(function(status) {\n        var promise = new Promise();\n        if (!status.track || !status.track.track_resource || !status.track.track_resource.uri) {\n          promise.fail({\n            type: Error.NO_TRACK_LOADED,\n            message: 'Could not toggle playback for non existing track'\n          });\n        } else {\n          self._pause(status.playing)\n            .then(function(pauseStatus) {\n              promise.fulfill(pauseStatus);\n            });\n        }\n        return promise;\n      });\n  };\n\n  /**\n   * Get a web token if there is a logged in user in the desktop client\n   *\n   * @return {Promise}   A promise with the web token\n   */\n  RemoteControl.prototype.getWebToken = function() {\n    var self = this;\n    return this.connect()\n      .then(function(status) {\n        var params = {\n          'csrf': self._csrf,\n          'oauth': self._token,\n        };\n\n        var promise = new Promise();\n\n        var url = self._buildUrl('remote/webtoken.json', params);\n        self._request(url, function(err, result) {\n          if (err) {\n            promise.fail({\n              type: Error.COULD_NOT_BROWSE_TO_CONTEXT,\n              message: 'Could not get web token'\n            });\n          } else {\n            if (result.error) {\n              promise.fail(result.error);\n            } else {\n              promise.fulfill(result);\n            }\n          }\n        });\n\n        return promise;\n      },\n      function(error) {\n        throw error;\n      });\n  };\n\n  /**\n   * Generate the base connection url\n   *\n   * @return {String}   The base connection url\n   * @private\n   */\n  RemoteControl.prototype._baseUrl = function() {\n    if (this._localhost) {\n      return '//localhost';\n    }\n\n    var min = 97;\n    var max = 122;\n    if ('' === this._subdomain) {\n      for (var i=0; i < 10; ++i) {\n        this._subdomain += String.fromCharCode(Math.floor(Math.random() * (max - min + 1)) + min);\n      }\n    }\n    return '//' + this._subdomain + '.spotilocal.com';\n  };\n\n  /**\n   * Make an XHR request\n   *\n   * @param {String} url   The requested url\n   * @param {?int} timeout   The timeout for this request. Defaults to 5000 ms.\n   * @return {Promise}   A promise with the response body JSON decoded\n   * @private\n   */\n  RemoteControl.prototype._request = function(url, callback, timeout) {\n\n    var self = this;\n\n    function getXdr() {\n      if ('undefined' !== typeof self._win.XDomainRequest) {\n        return new self._win.XDomainRequest();\n      } else if ('undefined' !== typeof self._win.XMLHttpRequest) {\n        return new self._win.XMLHttpRequest();\n      } else {\n        try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}\n        try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}\n        try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}\n        try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}\n      }\n      return null;\n    };\n\n    var xdr = getXdr();\n    if (xdr) {\n      xdr.onload = function() {\n        var data = xdr.responseText;\n        data = JSON.parse(data);\n        callback(null, data);\n      };\n\n      xdr.onerror = function() {\n        callback({type: xdr.status, message: 'Request error'});\n      };\n\n      xdr.ontimeout = function() {\n        callback({type: Error.REQUEST_TIMED_OUT, message: 'Request timed out'});\n      };\n\n      xdr.onprogress = function() {};\n\n      xdr.open('GET', url);\n      xdr.timeout = timeout ? timeout : 5000;\n      xdr.send();\n    } else {\n      callback({\n        type: Error.CORS_REQUESTS_DISABLED,\n        message: 'CORS Requests are not enabled'\n      });\n    }\n  };\n\n  /**\n   * Builds a url for use with the remote control\n   *\n   * @param {String} endpoint   The API endpoint\n   * @param {Object} params   The query parameters to be added\n   * @return {String}   The full URL\n   */\n  RemoteControl.prototype._buildUrl = function(endpoint, params) {\n    params = params || {};\n    params.cors = '';\n    params.ref = params.ref || this._referrer;\n    var queryParams = this._buildQuery(params);\n    return this._baseUrl() + ':' + this._currentPort + '/' + endpoint + '?' + queryParams;\n  };\n\n  /**\n   * Build the query parameter string\n   * This function url encodes all keys and all values.\n   *\n   * @param {Object} params   The query params to join\n   * @return {String}   The generated query string\n   */\n  RemoteControl.prototype._buildQuery = function(params) {\n    var query = [];\n    for (var key in params) {\n      query.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(params[key]));\n    }\n    return query.join(\"&\");\n  };\n\n  /**\n   * Get the next poll interval timeout based on the backoff strategy\n   *\n   * @return {int}   The next poll interval to use\n   */\n  RemoteControl.prototype._nextPollInterval = function() {\n    var interval = this._pollBackoff[this._backoffIndex];\n    if (this._pollBackoff[this._backoffIndex + 1]) {\n      this._backoffIndex++;\n    }\n    return interval;\n  };\n\n  /**\n   * Reset the index for fetching backoff interval\n   */\n  RemoteControl.prototype._resetBackoffCounter = function() {\n    this._backoffIndex = 0;\n  };\n\n},{\"spotify-eventemitter\":2,\"spotify-inheritance/inherit\":3,\"spotify-promise\":5}],7:[function(require,module,exports){\n  spweb.remotecontrol = require('spotify-remote');\n\n},{\"spotify-remote\":6}]},{},[7]);\n"
    },
    407: function(n, e, t) {
        "use strict";
        t(0)(t(408))
    },
    408: function(n, e) {
        n.exports = "jQuery(function ($, spweb) {\n\n  'use strict';\n\n  var body = $('body');\n\n  spweb.navbar.init(); // must run before spweb.messageBars.init()\n  spweb.messageBars.init();\n  spweb.analytics.init();\n  spweb.tracking.init();\n\n  if (window.navigator.appVersion.indexOf(\"MSIE 8\") > -1) {\n    $('html').addClass('ie8');\n  }\n  /**\n   * Direct logged out user to signup/login page on click of anchor elements\n   * with js-goto-signup or js-goto-login hooks. The anchor's href value will be set\n   * as the encoded value of the forward_url query parameter.\n   *\n   * Example:\n   *\n   *  A user clicks an anchor that is marked up as:\n   *    <a href=\"/us/download/\" class=\"js-goto-signup\">Download Spotify</a>\n   *\n   *  will be redirected to:\n   *    http://www.spotify.com/signup/?forward_url=%2Fus%2Fdownload%2Fmac%2F\n   *\n   * Also, ensure the user is in a launched market and not on a mobile device\n   */\n  if (spweb.user.getMarket() !== 'int' && !spweb.detect.detect().mobile && $('.reboot.is-loggedout').length > 0) {\n    $('.js-goto-signup').on('click.register', spweb.utils.goToSignup);\n  }\n}(jQuery, spweb));\n"
    },
    808: function(n, e, t) {
        t(297), t(226), t(393), t(203), t(395), t(397), t(158), t(133), t(399), t(401), t(293), t(303), t(403), t(322), t(324), t(809), t(405), n.exports = t(407)
    },
    809: function(n, e, t) {
        "use strict";
        t(0)(t(810))
    },
    810: function(n, e) {
        n.exports = "/** Globals PubSub */\n\nspweb.recaptcha = (function($) {\n\n  /**\n   * Execute RecaptchaV3 assessment as a response to emitted PubSub events\n   * @module spweb/recaptcha\n   * @requires jQuery\n   */\n\n  'use strict';\n\n  var exports = {};\n\n  /**\n   * Create a Recaptchav3 token and post it to Google's API\n   * Currently this is 'fire and forget', because we do\n   * not act on the outcome (yet).\n   *\n   * @private\n   * @param {String} action to be reported in RecaptchaV3\n   */\n  exports.assess = function(action) {\n    // This function depends on a twig template being loaded.\n    if (typeof window.getRecaptchaV3Token === 'undefined') {\n      return;\n    }\n\n    // Get ReCaptcha token via Google's SDK\n    window.getRecaptchaV3Token(action, function(token) {\n      // POST result to RecaptchaController\n      $.post('/recaptcha/assess/', JSON.stringify({\n        token: token,\n        action: action\n      }));\n    });\n  };\n\n  return exports;\n}(jQuery));\n"
    }
});
//# sourceMappingURL=spweb-site.min.5233d9e9cec666c8fe12.js.map