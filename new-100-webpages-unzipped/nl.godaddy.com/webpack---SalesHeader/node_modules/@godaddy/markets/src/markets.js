import request from '@godaddy/request';
import Cache from './cache';

const vatInclusion = ['ALL', 'NONE', 'TAXES', 'ICANN'];

const languageAliases = {
    sg: {
        alias: 'zh:s'
    },
    cn: {
        alias: 'zh:s'
    },
    hk: {
        alias: 'zh:t',
        overridePrimary: true
    },
    tw: {
        alias: 'zh:t',
        overridePrimary: true
    }
};

const countryLanguageOverrides = {
    zh: languageName => ({
        'zh:s': languageName,
        'zh:t': languageName
    })
};

const prefixedDescription = /^(QA|Test)\s*(.*)$/;

const plCurrencyBlacklist = ['EGP'];

const defaults = require(`../config/${process.env.NODE_ENV || 'development'}.json`); // eslint-disable-line no-process-env

/**
 * This is a temporary mapping of market ID to display code.
 * It is used in the compact display of the market selector.
 * Eventually, the Markets API will return this data, but for now, we'll handle it here.
 * @private
 */
const TempMarketDisplayCodeMap = {
    'da-DK': 'DK',
    'hi-IN': 'हिंदी',
    'ja-JP': '日本語',
    'ko-KR': '한국어',
    'mr-IN': 'मरा',
    'nb-NO': 'NO',
    'pt-BR': 'BR',
    'ru-RU': 'РУ',
    'ta-IN': 'தமி',
    'th-TH': 'ไทย',
    'uk-UA': 'Укр.',
    'zh-HK': '繁體中文',
    'zh-SG': '简体中文',
    'zh-TW': '繁體中文'
};

/**
 * Utility class to get market information
 *
 * @export
 * @class Markets
 */
export default class Markets {
    constructor(config) {
        this.config = {
            ...defaults,
            ...config
        };

        this.cache = new Cache();
    }

    /**
     * Parse country code out from market/locale string. If no country code is
     * found, defaults to `us`. E.g., `en-US` returns `us`
     *
     * @readonly
     * @static
     * @param {String} market Market name
     * @returns {String} Lowercase country code
     * @memberOf Markets
     * @api private
     */
    static countryFromMarket(market) {
        // Return the second component of the market as the country
        return ((typeof market === 'string' && market.split('-')[1]) || 'us').toLowerCase();
    }

    /**
     * Parse language out from market / locale string. E.g., `en-US` returns `en`.
     *
     * @readonly
     * @static
     * @param {String} market Market name
     * @returns {String} Lowercase language
     * @memberOf Markets
     * @api private
     */
    static languageFromMarket(market) {
        // Return the first component of the market as the language
        return (typeof market === 'string' ? market.split('-')[0] : 'en').toLowerCase();
    }

    /**
     * Callback type for getCountries
     *
     * @callback getCountriesCallback
     * @param {Object} err Error object
     * @param {Object} countries All countries, keyed by two-letter country code
     */
    /**
     * Get all countries.
     *
     * @param {Number} privateLabelId Private Label ID for which to get countries
     * @param {getCountriesCallback} callback Callback to run after countries are retrieved
     *
     * @readonly
     * @memberOf Markets
     * @api public
     */
    getCountries(privateLabelId, callback) {
        this.getMarkets(privateLabelId, (error, markets) => {
            if (error) {
                return callback(error);
            }

            const countries = this.getCountriesFromData(markets);

            callback(null, countries);
        });
    }

    /**
     * Get all countries given pre-loaded markets data
     *
     * @param {Object} markets Market data loaded with `getMarkets`
     * @returns {Object} Data pivoted to describe countries
     * @memberof Markets
     * @public
     */
    getCountriesFromData(markets) {
        // Group markets by country code with rollup of `languages`. Assumes all
        // languages for country have same `currency` and `countrySite` and that
        // at most one language is flagged as `primaryLanguageForCountry`.

        const countries = {};

        Object.keys(markets).forEach(marketId => {
            const market = markets[marketId];
            const languageAlias = languageAliases[market.countryCode];

            const country = countries[market.countryCode] = countries[market.countryCode] || {
                currency: market.currency,
                languages: {},
                countrySite: market.countrySite,
                primaryLanguage: languageAlias && languageAlias.overridePrimary && languageAlias.alias
            };

            if (languageAlias) {
                country.languageAlias = languageAlias.alias;
            }

            if (!country.primaryLanguage && market.primaryLanguageForCountry) {
                country.primaryLanguage = market.languageCode;
            }

            const countryLanguageOverride = countryLanguageOverrides[market.languageCode];

            country.languages[market.languageCode] = countryLanguageOverride ?
                countryLanguageOverride(market.languageName) :
                market.languageName;
        });

        // For any countries that have `languages` but no `primaryLanguage`, use
        // their first language. (The only non-QA country that this is currently
        // the case for is IL, which has a single language: en.)
        Object.keys(countries).forEach(countryCode => {
            const country = countries[countryCode];
            const languageKeys = Object.keys(country.languages);

            if (!country.primaryLanguage && languageKeys.length) {
                country.primaryLanguage = languageKeys[0];
            }
        });

        return countries;
    }

    /**
     * Callback type for getCountry
     *
     * @callback getCountryCallback
     * @param {Object} err Error object
     * @param {Object} country Country
     */
    /**
     * Get a single country.
     *
     * @param {Number} privateLabelId Private Label ID for which to get country
     * @param {String} countryCode Two-letter country code; e.g., `us`
     * @param {getCountryCallback} callback Callback to run after country is retrieved
     *
     * @readonly
     * @memberOf Markets
     * @api public
     */
    getCountry(privateLabelId, countryCode, callback) {
        this.getCountries(privateLabelId, (error, countries) => {
            if (error) {
                return callback(error);
            }

            const country = countries[countryCode];

            if (!country) {
                return callback(new Error(`no such country: ${countryCode}`));
            }

            callback(null, country);
        });
    }

    /**
     * Callback type for getMarketNames
     *
     * @callback getMarketNamesCallback
     * @param {Object} err Error object
     * @param {Array} marketNames A list of market names
     */
    /**
     * Get all market names.
     *
     * @param {Number} privateLabelId Private Label ID for which to get market names
     * @param {getMarketNamesCallback} callback Callback to run after market names are retrieved
     *
     * @readonly
     * @memberOf Markets
     * @api public
     */
    getMarketNames(privateLabelId, callback) {
        this.getMarkets(privateLabelId, (error, markets) => {
            if (error) {
                return callback(error);
            }

            callback(null, Object.keys(markets));
        });
    }

    /**
     * Callback type for getMarkets
     *
     * @callback getMarketsCallback
     * @param {Object} err Error object
     * @param {Object} markets All markets, keyed by market ID
     */
    /**
     * Get all markets.
     *
     * @param {Number} privateLabelId Private Label ID for which to get markets
     * @param {getMarketsCallback} callback Callback to run after markets are retrieved
     *
     * @readonly
     * @memberOf Markets
     * @api public
     */
    getMarkets(privateLabelId, callback) {
        this.cache.wrap(privateLabelId, cacheCallback => {
            const url = `http://market.api.int.${this.config.envPrefix}godaddy.com/v1/markets/?privateLabelId=${privateLabelId}`;

            request.get(url, {}, (error, markets) => {
                if (error) {
                    return cacheCallback(error);
                }

                const result = markets.reduce((_result, market) => {
                    const {
                        marketId,
                        description
                    } = market;
                    const countryCode = Markets.countryFromMarket(marketId);
                    const languageCode = Markets.languageFromMarket(marketId);
                    let [countryName, languageName] = description.split('-').map(s => s.trim());

                    // Fallback for unhyphenated `description`s.
                    if (!languageName) {
                        const match = prefixedDescription.exec(description);

                        if (match) {
                            countryName = match[1];
                            languageName = match[2];
                        } else {
                            languageName = countryName;
                            countryName = countryCode.toUpperCase();
                        }
                    }

                    const _market = {
                        market: marketId,
                        internal: market.internal,
                        countryCode,
                        languageCode,
                        description,
                        countryName,
                        languageName,
                        currency: market.defaultCurrency,
                        countrySite: market.seoSubDomain,
                        primaryLanguageForCountry: market.seoIsPrimaryForSubdomain,
                        displayTaxesAndFees: market.displayTaxesAndFees,
                        vatIncluded: vatInclusion.indexOf(market.displayTaxesAndFees) > -1
                    };

                    const languageAlias = languageAliases[_market.countryCode];

                    if (languageAlias && languageAlias.alias.indexOf(_market.languageCode) === 0) {
                        _market.languageAlias = languageAlias.alias;
                    }

                    const displayCode = market.displayCode || TempMarketDisplayCodeMap[marketId];
                    if (displayCode) {
                        _market.displayCode = displayCode;
                    }

                    _result[marketId] = _market;

                    return _result;
                }, {});

                cacheCallback(null, result);
            });
        }, callback);
    }

    /**
     * Callback type for getMarket
     *
     * @callback getMarketCallback
     * @param {Object} err Error object
     * @param {Object} market Market
     */
    /**
     * Get a single market.
     *
     * @param {Number} privateLabelId Private Label ID for which to get market
     * @param {String} marketId ID of market to get
     * @param {getMarketCallback} callback Callback to run after market is retrieved
     *
     * @readonly
     * @memberOf Markets
     * @api public
     */
    getMarket(privateLabelId, marketId, callback) {
        this.getMarkets(privateLabelId, (error, markets) => {
            if (error) {
                return callback(error);
            }

            const market = markets[marketId];

            if (!market) {
                return callback(new Error(`no such market: ${marketId}`));
            }

            callback(null, market);
        });
    }

    /**
     * Callback type for isVATIncluded
     *
     * @callback isVATIncludedCallback
     * @param {Object} err Error object
     * @param {Boolean} vatIncluded Whether VAT is included in prices for the specified market
     */
    /**
     * Get whether VAT is included in prices for the specified market.
     *
     * @param {Number} privateLabelId Private Label ID
     * @param {String} marketId Market ID
     * @param {isVATIncludedCallback} callback Callback to run after VAT-inclusion is retrieved
     *
     * @readonly
     * @memberOf Markets
     * @api public
     */
    isVATIncluded(privateLabelId, marketId, callback) {
        this.getMarket(privateLabelId, marketId, (error, market) => {
            if (error) {
                return callback(error);
            }

            return callback(null, market.vatIncluded);
        });
    }

    /**
     * Callback type for getCurrencies
     *
     * @callback getCurrenciesCallback
     * @param {Object} err Error object
     * @param {Array} currencies An array of currencies
     */
    /**
     * Gets a list of currencies asynchronously
     *
     * @param {String} guiUrl URL to the Presentation Central GUI endpoint
     * @param {String} [marketId='en-US'] The currently selected market
     * @param {Number} [privateLabelId=1] Private Label ID
     * @param {getCurrenciesCallback} done Callback to run after currencies are retrieved
     *
     * @readonly
     * @memberOf Markets
     * @api public
     */
    getCurrencies(guiUrl, marketId, privateLabelId, done) {
        if (typeof marketId === 'function') {
            done = marketId;
            privateLabelId = 1;
            marketId = 'en-US';
        } else if (typeof privateLabelId === 'function') {
            done = privateLabelId;
            privateLabelId = 1;
        }

        const url = `${encodeURI(guiUrl)}pcjson/currency/display?marketId=${encodeURIComponent(marketId)}&pl_id=${privateLabelId}`;

        request.get(url, {
            jsonp: true
        }, (error, currencies) => {
            if (error) {
                return done(error);
            }

            if (privateLabelId === 1) {
                return done(null, currencies);
            }

            done(null, currencies.filter(currency => plCurrencyBlacklist.indexOf(currency.currencytype) === -1));
        });
    }
}