import fetch, {
    AbortController,
    Request
} from '@godaddy/fetch';
import diagnostics from 'diagnostics';
import qs from 'querystringify';
import jsonp from 'jsonp';
import rip from 'rip-out';

const log = diagnostics('request');

/**
 * Safely stringify an object into JSON and log on error
 *
 * @param {Object} obj An object to stringify into JSON.
 * @returns {String} A JSON string representing obj.
 * @private
 */
function jsonstringify(obj) {
    try {
        return JSON.stringify(obj);
    } catch (error) {
        log(error.message);
    }
}

/**
 * @callback RequestCallback
 * @param {Error} [err] Error, if any
 * @param {any} [data] Data returned
 */
/**
 * Send the request and process response.
 *
 * @param {String} url URI to request.
 * @param {Object} [options] Configuration.
 * @param {RequestCallback} done Completion callback.
 * @returns {Request} Request instance.
 * @private
 */
function send(url, options, done) { // eslint-disable-line max-statements
    if (typeof options === 'function') {
        done = options;
        options = {};
    }

    const controller = options.controller || new AbortController();

    // Provide backwards compatibility for internal configuration of requests,
    // see https://github.com/unshiftio/requests/blob/master/index.js#L102.
    options.mode = options.mode || 'cors';
    options.credentials = options.credentials || 'include';
    options.timeout = options.timeout || 30000;
    url = url + qs.stringify(options.query || {}, true);

    if (options.jsonp) {
        return jsonp(url, options, done);
    }

    if (options.body && typeof options.body !== 'string') {
        options.body = jsonstringify(options.body);
    }

    if (typeof options.timeout === 'number') {
        setTimeout(controller.abort.bind(controller), options.timeout);
        options.signal = controller.signal;
    }

    //
    // Delete properties that should not be passed to the `window.Request` constructor.
    //
    options = rip(options, 'timeout', 'query', 'controller');

    const request = new Request(url, options);
    fetch(request)
        .then(handleResponse)
        .then(content => {
            done(null, content);
        })
        .catch(done);

    return {
        controller,
        request
    };
}

/**
 * Extract the method that should be used for reading content from the content-type.
 *
 * @param {string} type Content type
 * @returns {string} method
 * @private
 */
function getMethod(type) {
    if (type && ~type.indexOf('application/json')) return 'json';
    if (type && ~type.indexOf('text/')) return 'text';

    return 'blob';
}

/**
 * Handles the response of the fetch request
 *
 * @param {Response} response Response from the request
 * @returns {Promise} Content or Error from the response
 * @private
 */
function handleResponse(response) {
    const method = getMethod(response.headers.get('content-type'));

    if (response.status >= 400) {
        const error = new Error(response.statusText);
        error.status = response.status;

        return Promise.reject(error);
    }

    return response[method]();
}

/**
 * Execute DELETE request
 *
 * @param {String} url URI to request.
 * @param {Object} [options] Configuration.
 * @param {RequestCallback} done Completion callback.
 * @returns {requests} Requests instance.
 * @public
 */
export function del(url, options, done) {
    return send(url, {
        ...options,
        method: 'DELETE'
    }, done);
}

/**
 * Execute GET request
 *
 * @param {String} url URI to request.
 * @param {Object} [options] Configuration.
 * @param {RequestCallback} done Completion callback.
 * @returns {requests} Requests instance.
 * @public
 */
export function get(url, options, done) {
    return send(url, options, done);
}

/**
 * Execute PATCH request
 *
 * @param {String} url URI to request.
 * @param {Object} data Data to send with request.
 * @param {Object} [options] Configuration.
 * @param {RequestCallback} done Completion callback.
 * @returns {requests} Requests instance.
 * @public
 */
export function patch(url, data, options, done) {
    if (typeof options === 'function') {
        done = options;
        options = {};
    }

    return send(url, {
        ...options,
        method: 'PATCH',
        body: data
    }, done);
}

/**
 * Execute POST request
 *
 * @param {String} url URI to request.
 * @param {Object} data Data to send with request.
 * @param {Object} [options] Configuration.
 * @param {RequestCallback} done Completion callback.
 * @returns {requests} Requests instance.
 * @public
 */
export function post(url, data, options, done) {
    if (typeof options === 'function') {
        done = options;
        options = {};
    }

    return send(url, {
        ...options,
        method: 'POST',
        body: data
    }, done);
}

/**
 * Execute PUT request
 *
 * @param {String} url URI to request.
 * @param {Object} data Data to send with request.
 * @param {Object} [options] Configuration.
 * @param {RequestCallback} done Completion callback.
 * @returns {requests} Requests instance.
 * @public
 */
export function put(url, data, options, done) {
    if (typeof options === 'function') {
        done = options;
        options = {};
    }

    return send(url, {
        ...options,
        method: 'PUT',
        body: data
    }, done);
}

export default {
    del,
    get,
    patch,
    post,
    put
};



// WEBPACK FOOTER //
// ./node_modules/@godaddy/request/index.js