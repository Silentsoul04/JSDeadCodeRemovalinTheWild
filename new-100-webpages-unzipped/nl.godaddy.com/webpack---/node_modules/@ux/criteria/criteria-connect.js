import React from 'react';
import PropTypes from 'prop-types';
import Component from '@ux/component';
import Criteria from './criteria';
import {
    isElementOfComponentType,
    combineFunctions
} from './util';

/**
 * Names of FormElement events to wire up.
 *
 * @type {string[]}
 * @private
 */
const EVENT_PROPS = ['onChange', 'onFocus', 'onBlur', 'onValidation'];

/**
 * Component used to wire up Criteria to components which inherit from FormElement.
 *
 * @displayName Connect
 *
 * @class Connect
 * @public
 */
export default class Connect extends Component {
    constructor() {
        super(...arguments);

        this.state = this.assign(this.state, {
            value: '',
            visible: false,
            isValid: false,
            hadInput: false
        });

        this._setupInput = this._setupInput.bind(this);
        this._setupCriteria = this._setupCriteria.bind(this);
        this._onValidChangeHandler = this._onValidChangeHandler.bind(this);
        this._onChangeHandler = this._onChangeHandler.bind(this);
        this._onValidationHandler = this._onValidationHandler.bind(this);
        this._onFocusHandler = this._onFocusHandler.bind(this);
        this._onBlurHandler = this._onBlurHandler.bind(this);
    }

    /**
     * React lifecycle hook invoked when component is about to mount.
     *
     * @private
     */
    componentDidMount() {
        if ('value' in this.props.children[0].props) {
            this.setState({
                value: this.props.children[0].props.value
            });
        }

        if (this.props.forceValidation) {
            this.setState({
                hadInput: this.props.forceValidation
            });
        }
    }

    /**
     * Callback used when FormElement input value is updated.
     *
     * @param {any} value Value to validate against.
     * @private
     */
    _onValidationHandler(value) {
        this.setState({
            value: value,
            hadInput: true
        });
    }

    /**
     * Callback used when FormElement input value changes.
     *
     * @param {Object} evt Change event.
     * @private
     */
    _onChangeHandler(evt) {
        this.setState({
            value: evt.target.value,
            hadInput: true
        });
    }

    /**
     * Callback used when FormElement gains focus.
     *
     * @private
     */
    _onFocusHandler() {
        this.setState({
            visible: true
        });
    }

    /**
     * Callback used when FormElement loses focus.
     *
     * @private
     */
    _onBlurHandler() {
        setTimeout(() => {
            this.setState({
                visible: false
            });
        }, 250);
    }

    /**
     * Callback used when Criteria changes valid state.
     *
     * @param {Boolean} name Name of the Criteria.
     * @param {Boolean} isValid Valid state of Criteria.
     * @private
     */
    _onValidChangeHandler(name, isValid) {
        this.setState({
            isValid
        });
    }

    /**
     * Wires up callbacks to the FormElement.
     *
     * @param {ReactElement} element FormElement.
     * @returns {ReactElement} wired up FormElement.
     * @private
     */
    _setupInput(element) {
        const self = this;
        const state = self.state;
        const {
            validate
        } = element.props;
        const props = {};

        //
        // If this component has ever had focus then validation
        // should be run. Otherwise, if it has never had user interaction
        // it should be displayed as valid even if it is invalid.
        //
        if (state.hadInput) {
            let valid = state.isValid;

            if (typeof validate === 'function') {
                valid = valid && validate(state.value);
            }

            props.validates = valid;
        }

        //
        // If we are visible then pass alone the `open` class to the form
        // element associated with this instance.
        //

        if (state.visible && (!self.props.enableModern || !state.isValid)) {
            props.className = 'open';
        }

        EVENT_PROPS.forEach(method => {
            if (typeof element.props[method] === 'function') {
                props[method] = combineFunctions(element.props[method], self[`_${method}Handler`]);
            } else {
                props[method] = self[`_${method}Handler`];
            }
        });

        return React.cloneElement(element, props);
    }

    /**
     * Wires up callbacks to the Criteria component.
     *
     * @param {ReactElement} element Criteria element.
     * @returns {ReactElement} wired up Criteria.
     * @private
     */
    _setupCriteria(element) {
        const props = this.props;
        const state = this.state;

        return React.cloneElement(element, {
            standalone: false,
            value: state.value,
            visible: state.visible,
            enableModern: props.enableModern,
            onValidChange: typeof element.props.onValidChange === 'function' ?
                combineFunctions(element.props.onValidChange, this._onValidChangeHandler) : this._onValidChangeHandler
        });
    }

    /**
     * Renders the component.
     *
     * @returns {React.DOM} Rendered form element.
     * @private
     */
    render() {
        return ( <
            div className = 'ux-criteria-connect' > {
                this._setupInput(this.props.children[0])
            } {
                this._setupCriteria(this.props.children[1])
            } <
            /div>
        );
    }

    /**
     * PropType check that make sure child components are correct type and order.
     *
     * @param {Array} props Props
     * @param {String} propName Name of prop
     * @param {String} componentName Name of component
     * @returns {*} null or Error if invalid children
     * @private
     */
    static childrenPropTypes(props, propName, componentName) {
        const _children = React.Children.toArray(props[propName]);
        if (_children.length !== 2) {
            return new Error(
                `${componentName} may only have 2 child components`
            );
        }

        const input = _children[0];
        const criteria = _children[1];
        if (!input.props.label && !input.props.placeholder) {
            return new Error(
                `${componentName} must have a FormElement component as the first child`
            );
        }

        if (!isElementOfComponentType(criteria, Criteria)) {
            return new Error(
                `${componentName} must have a Criteria component as second child`
            );
        }

        return null;
    }
}

/**
 * PropType validation.
 *
 * @type {Object}
 * @private
 */
Connect.propTypes = {
    /** The child elements */
    children: Connect.childrenPropTypes,
    /** Whether validation should be performed on initial mount */
    forceValidation: PropTypes.bool,
    /** Enable control animations and absolute positioning.
     * This should be avoided unless your app/site is experiencing
     * major issues as this will be removed shortly.  */
    enableModern: PropTypes.bool
};

Connect.defaultProps = {
    enableModern: true
};



// WEBPACK FOOTER //
// ./node_modules/@ux/criteria/criteria-connect.js