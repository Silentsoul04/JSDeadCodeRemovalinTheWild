(function webpackUniversalModuleDefinition(root, factory) {
    if (typeof exports === 'object' && typeof module === 'object')
        module.exports = factory();
    else if (typeof define === 'function' && define.amd)
        define([], factory);
    else if (typeof exports === 'object')
        exports["FbsCarousel"] = factory();
    else
        root["FbsCarousel"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
    return /******/ (function(modules) { // webpackBootstrap
        /******/ // The module cache
        /******/
        var installedModules = {};
        /******/
        /******/ // The require function
        /******/
        function __webpack_require__(moduleId) {
            /******/
            /******/ // Check if module is in cache
            /******/
            if (installedModules[moduleId]) {
                /******/
                return installedModules[moduleId].exports;
                /******/
            }
            /******/ // Create a new module (and put it into the cache)
            /******/
            var module = installedModules[moduleId] = {
                /******/
                i: moduleId,
                /******/
                l: false,
                /******/
                exports: {}
                /******/
            };
            /******/
            /******/ // Execute the module function
            /******/
            modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
            /******/
            /******/ // Flag the module as loaded
            /******/
            module.l = true;
            /******/
            /******/ // Return the exports of the module
            /******/
            return module.exports;
            /******/
        }
        /******/
        /******/
        /******/ // expose the modules object (__webpack_modules__)
        /******/
        __webpack_require__.m = modules;
        /******/
        /******/ // expose the module cache
        /******/
        __webpack_require__.c = installedModules;
        /******/
        /******/ // define getter function for harmony exports
        /******/
        __webpack_require__.d = function(exports, name, getter) {
            /******/
            if (!__webpack_require__.o(exports, name)) {
                /******/
                Object.defineProperty(exports, name, {
                    /******/
                    configurable: false,
                    /******/
                    enumerable: true,
                    /******/
                    get: getter
                    /******/
                });
                /******/
            }
            /******/
        };
        /******/
        /******/ // getDefaultExport function for compatibility with non-harmony modules
        /******/
        __webpack_require__.n = function(module) {
            /******/
            var getter = module && module.__esModule ?
                /******/
                function getDefault() {
                    return module['default'];
                } :
                /******/
                function getModuleExports() {
                    return module;
                };
            /******/
            __webpack_require__.d(getter, 'a', getter);
            /******/
            return getter;
            /******/
        };
        /******/
        /******/ // Object.prototype.hasOwnProperty.call
        /******/
        __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
        };
        /******/
        /******/ // __webpack_public_path__
        /******/
        __webpack_require__.p = "";
        /******/
        /******/ // Load entry module and return exports
        /******/
        return __webpack_require__(__webpack_require__.s = 20);
        /******/
    })
    /************************************************************************/
    /******/
    ([
        /* 0 */
        /***/
        (function(module, __webpack_exports__, __webpack_require__) {

            "use strict";
            /* unused harmony export hasWindow */
            /* harmony export (binding) */
            __webpack_require__.d(__webpack_exports__, "e", function() {
                return hasDocument;
            });
            /* harmony export (binding) */
            __webpack_require__.d(__webpack_exports__, "a", function() {
                return FBS_CAROUSEL_CONFIG_ID_ATTRIBUTE;
            });
            /* unused harmony export hasMatchmedia */
            /* harmony export (immutable) */
            __webpack_exports__["b"] = findCurrentConfiguration;
            /* harmony export (immutable) */
            __webpack_exports__["c"] = generateActiveConfiguration;
            /* harmony export (immutable) */
            __webpack_exports__["g"] = loopIndexOrder;
            /* harmony export (immutable) */
            __webpack_exports__["f"] = loopIndex;
            /* harmony export (immutable) */
            __webpack_exports__["d"] = getDistances;
            /* harmony import */
            var __WEBPACK_IMPORTED_MODULE_0__models_fbs_carousel_config__ = __webpack_require__(1);
            var __assign = (this && this.__assign) || Object.assign || function(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (var p in s)
                        if (Object.prototype.hasOwnProperty.call(s, p))
                            t[p] = s[p];
                }
                return t;
            };

            /**
             * Use this to stop erroring out on server (even if invalid isServerPrerender flag is sent)
             */
            var hasWindow = typeof window !== 'undefined';
            var hasDocument = typeof document !== 'undefined';
            var FBS_CAROUSEL_CONFIG_ID_ATTRIBUTE = 'data-fbs-carousel-config-id';
            var EMPTY_BREAKPOINT = {
                breakpoints: []
            };
            /**
             * Who doesn't support matchmedia? Check for it regardless, but expect diminished functionality.
             */
            var hasMatchmedia = hasWindow && !!window.matchMedia;
            /**
             * Finds the current carousel configuration from all allowed locations
             *
             * If rendering on a client, look for configuration objects on the window object
             * First look for ID, then the special `data-fbs-carousel-config-id` attribute if not found
             * Config will be used if it exists on the window.FbsCarouselConfig object
             *
             * E.G.
             * `<fbs-carousel id="carousel-1"></fbs-carousel>`
             * would use the config from
             * `window.FbsCarouselConfig['carousel-1]: FbsCarouselConfig` configuration object
             *
             * while
             * `<fbs-carousel data-fbs-carousel-config-id="carousel-2"></fbs-carousel>`
             * would use the config from
             * `window.FbsCarouselConfig['carousel-2]: FbsCarouselConfig` configuration object
             * @param config Configuration value passed to carousel initialization. If present, supercedes all others.
             * @param el Parent element of fbs-carousel or fbs-slider.
             */
            function findCurrentConfiguration(config, el) {
                /**
                 * Performs housekeeping for storing unmodified, unflattened configuration values for server prerender
                 * @param config Current unflattened configuration
                 * @returns Current active unflattened configuration minus server prerender values
                 */
                var cb = function(config) {
                    var _config = __assign({}, config);
                    delete _config.serverDomEngine;
                    delete _config.isServerPrerender;
                    return _config;
                };
                // If a config was passed to the carousel initialization, use it.
                if (config) {
                    config.originalConfig = cb(config);
                    return config;
                }
                // Looks for config on window objects otherwise
                var windowConfig;
                if (hasWindow) {
                    if (el.id && (windowConfig = (window.FbsCarouselConfig || {})[el.id])) {
                        // Inline assignment because it's long
                    } else {
                        var attribute = el.getAttribute(FBS_CAROUSEL_CONFIG_ID_ATTRIBUTE);
                        windowConfig = attribute && (window.FbsCarouselConfig || {})[attribute];
                    }
                }
                if (windowConfig) {
                    windowConfig.originalConfig = cb(windowConfig);
                }
                // If no allowable configuration was provided, just use the default
                return windowConfig || __WEBPACK_IMPORTED_MODULE_0__models_fbs_carousel_config__["a" /* FBS_CAROUSEL_DEFAULTS */ ];
            }
            /**
             * Recursively loops over the passed carousel configuration options to match provided breakpoints
             * and create a single flattened ruleset for the current window size
             *
             * @param config Global configuration object passed to FbsCarousel
             * @param bypassDefaults When true, doesn't combine current config rules with FBS_CAROUSEL_DEFAULTS
             */
            function generateActiveConfiguration(config, bypassDefaults) {
                var _config = __assign({}, config);
                var cleanup = function() {
                    _config.slidesToScroll = Math.min(_config.inView || 1, _config.slidesToScroll || 1);
                    _config.currentOffset = Math.max(0, Math.min(_config.currentOffset, _config.inView - 1));
                };
                if (!bypassDefaults) {
                    _config = __assign({}, __WEBPACK_IMPORTED_MODULE_0__models_fbs_carousel_config__["a" /* FBS_CAROUSEL_DEFAULTS */ ], config);
                }
                // Don't flatten the config object if it's rendering for server view -
                // Breakpoint data is required for inline styles
                // Additionally, allow graceful degredation for IE9- or other browsers that don't have css matchmedia support
                if (_config.isServerPrerender || !hasWindow || !hasMatchmedia) {
                    // On server prerender, we need to know the *largest possible* number of slides to display
                    // regardless of breakpoint registered. The easiest way is to just recursively check all breakpoints
                    // and set the top level inView to the largest one found.
                    if (_config.isServerPrerender) {
                        var largestInView = _config.inView;
                        var hasDisabledBreakpoint = _config.enabled === false;
                        var breakpoints = (_config.breakpoints || []).slice(0);
                        while (breakpoints.length) {
                            var b = breakpoints.shift();
                            hasDisabledBreakpoint = hasDisabledBreakpoint || b.config.enabled === false;
                            if (b.config.inView > largestInView) {
                                largestInView = b.config.inView;
                            }
                        }
                        _config.inView = largestInView;
                        _config.hasDisabledBreakpoint = hasDisabledBreakpoint;
                    }
                    cleanup();
                    return _config;
                }
                // Start flattening breakpoint specific rules
                if ((_config.breakpoints || []).length) {
                    for (var i = 0; i < _config.breakpoints.length; i++) {
                        var breakpoint = _config.breakpoints[i];
                        // Only allow valid breakpoint definitions
                        if (!breakpoint.breakpoint) {
                            continue;
                        }
                        if (window.matchMedia(breakpoint.breakpoint.substr(7)).matches) {
                            // Flatten current breakpoint level and check for matching children to flatten
                            _config = generateActiveConfiguration(__assign({}, _config, EMPTY_BREAKPOINT, breakpoint.config), true);
                            // Only flatten first matched rule per level
                            break;
                        }
                    }
                }
                cleanup();
                return _config;
            }
            /**
             * Gets slide at specified index, looping around boundaries
             * E.G. array ['a', 'b', 'c'] with i `-1` returns 'c'
             * @param order Slide order object of carousel
             * @param i Index of slide to retrieve
             */
            function loopIndexOrder(order, i) {
                return order[loopIndex(i, order.length)];
            }
            /**
             * Gets loop-adjusted index value after modifications
             * Ranges number between 0 inclusive and len, non inclusive
             * @param i Index to loop
             * @param len Maximum size of i
             */
            function loopIndex(i, len) {
                while (i < len) {
                    i += len;
                }
                return (len + i) % len;
            }
            /**
             * Calculates straight line distance between two points on a bidirectionally linked array
             * E. G. ['a', 'b', 'c', 'd', 'e'], using points 0 and 3 would take [2, 3]. 2 steps left, 3 steps right.
             * Straight line distance will always equal array.length
             * @param a First point
             * @param b Second point
             * @param len Length of source array
             */
            function getDistances(a, b, len) {
                return a > b ? [a - b, len - a + b] : [len - b + a, b - a];
            }


            /***/
        }),
        /* 1 */
        /***/
        (function(module, __webpack_exports__, __webpack_require__) {

            "use strict";
            /* harmony export (binding) */
            __webpack_require__.d(__webpack_exports__, "a", function() {
                return FBS_CAROUSEL_DEFAULTS;
            });
            var FBS_CAROUSEL_DEFAULTS = {
                currentOffset: 0,
                inView: 1,
                speed: 500,
                showControls: true,
                imagePreloadAttribute: 'data-bg-image',
                initialIndex: 0,
                isServerPrerender: false,
            };


            /***/
        }),
        /* 2 */
        /***/
        (function(module, __webpack_exports__, __webpack_require__) {

            "use strict";
            /* unused harmony export SLIDE_WRAPPER_CLASS */
            /* harmony export (binding) */
            __webpack_require__.d(__webpack_exports__, "e", function() {
                return SLIDE_TRACK_CLASS;
            });
            /* harmony export (binding) */
            __webpack_require__.d(__webpack_exports__, "d", function() {
                return SLIDE_CLASS;
            });
            /* harmony export (binding) */
            __webpack_require__.d(__webpack_exports__, "a", function() {
                return CONTROL_WRAPPER_CLASS;
            });
            /* unused harmony export CONTROL_DISABLED_WRAPPER_CLASS */
            /* unused harmony export CONTROL_LEFT_CLASS */
            /* unused harmony export CONTROL_RIGHT_CLASS */
            /* unused harmony export CONTROL_DISABLED_CLASS */
            /* unused harmony export SLIDER_INITIALIZED_CLASS */
            /* harmony export (binding) */
            __webpack_require__.d(__webpack_exports__, "c", function() {
                return SLIDER_SLIDE_ID;
            });
            /* harmony export (binding) */
            __webpack_require__.d(__webpack_exports__, "b", function() {
                return SLIDER_PRERENDER_STYLES;
            });
            /* unused harmony export SLIDER_UNIQUE_ID */
            /* harmony export (immutable) */
            __webpack_exports__["g"] = initFromDom;
            /* unused harmony export createControls */
            /* unused harmony export createSlideNode */
            /* harmony export (immutable) */
            __webpack_exports__["f"] = generateSlideId;
            /* unused harmony export toggleControls */
            /* harmony export (immutable) */
            __webpack_exports__["h"] = updateSlides;
            /* harmony import */
            var __WEBPACK_IMPORTED_MODULE_0__serverHelpers__ = __webpack_require__(4);
            /* harmony import */
            var __WEBPACK_IMPORTED_MODULE_1__utility__ = __webpack_require__(0);
            /* harmony import */
            var __WEBPACK_IMPORTED_MODULE_2__node_modules_forbes_fbs_icons__ = __webpack_require__(5);
            /* harmony import */
            var __WEBPACK_IMPORTED_MODULE_2__node_modules_forbes_fbs_icons___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__node_modules_forbes_fbs_icons__);
            var __assign = (this && this.__assign) || Object.assign || function(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (var p in s)
                        if (Object.prototype.hasOwnProperty.call(s, p))
                            t[p] = s[p];
                }
                return t;
            };



            var SLIDE_WRAPPER_CLASS = 'fbs-slider__slides-wrapper';
            var SLIDE_TRACK_CLASS = 'fbs-slider__slides';
            var SLIDE_CLASS = 'fbs-slider__slide';
            var CONTROL_WRAPPER_CLASS = 'fbs-slider__controls';
            var CONTROL_DISABLED_WRAPPER_CLASS = 'fbs-slider--no-controls';
            var CONTROL_LEFT_CLASS = 'fbs-slider__control-left';
            var CONTROL_RIGHT_CLASS = 'fbs-slider__control-right';
            var CONTROL_DISABLED_CLASS = 'disabled';
            var SLIDER_INITIALIZED_CLASS = 'fbs-slider--initialized';
            var SLIDER_SLIDE_ID = 'data-fbs-carousel-slide-id';
            var SLIDER_PRERENDER_STYLES = 'data-fbs-carousel-prerender-styles';
            var SLIDER_UNIQUE_ID = 'data-fbs-carousel-id';
            /**
             * Parses a carousel state out of HTML elements present inside of `el`.
             * @param el Parent <fbs-carousel> or `fbs-slider` element
             * @param config Current carousel active configuration
             */
            function initFromDom(el, config) {
                var _document = __WEBPACK_IMPORTED_MODULE_1__utility__["e" /* hasDocument */ ] ? document : config.serverDomEngine;
                var state = {
                    __slides: new Map(),
                    __order: [],
                    __index: config.initialIndex || 0,
                };
                var slideWrapper;
                var slides = [];
                var uniqueId = '';
                el.classList.add('fbs-slider');
                // If carousel has no ID, give it a unique string for server side styles to apply
                if (el.id) {
                    uniqueId = "#" + el.id;
                } else if (el.hasAttribute(__WEBPACK_IMPORTED_MODULE_1__utility__["a" /* FBS_CAROUSEL_CONFIG_ID_ATTRIBUTE */ ])) {
                    uniqueId = el.getAttribute(__WEBPACK_IMPORTED_MODULE_1__utility__["a" /* FBS_CAROUSEL_CONFIG_ID_ATTRIBUTE */ ]);
                    el.classList.add(uniqueId);
                } else {
                    uniqueId = "_" + generateSlideId(state.__slides);
                    el.setAttribute(__WEBPACK_IMPORTED_MODULE_1__utility__["a" /* FBS_CAROUSEL_CONFIG_ID_ATTRIBUTE */ ], uniqueId);
                    el.classList.add(uniqueId);
                }
                for (var i = 0; i < el.children.length; i++) {
                    var child = el.children.item(i);
                    // Handle importing existing control buttons
                    if (child.classList.contains(CONTROL_WRAPPER_CLASS)) {
                        // Only one controls allowed
                        if (state.__controls) {
                            child.remove();
                            i--;
                            continue;
                        }
                        var left = child.querySelector("." + CONTROL_LEFT_CLASS);
                        var right = child.querySelector("." + CONTROL_RIGHT_CLASS);
                        state.__controls = {
                            __wrapper: child,
                            __left: left,
                            __right: right,
                        };
                        // Import slide wrapper and store for later use
                    } else if (child.classList.contains(SLIDE_WRAPPER_CLASS)) {
                        // Only one slide wrapper allowed
                        if (slideWrapper) {
                            child.remove();
                            i--;
                            continue;
                        }
                        slideWrapper = child;
                        // By this point it's probably a slide
                    } else {
                        slides.push(child);
                    }
                }
                /**
                 * Converts all remaining elements to valid slides.
                 * @param slides Array of all remaining matched nodes
                 * @param removeMatched Detach DOM node after converting to valid slide?
                 *                      Required for converting from trackless slide
                 */
                var validateSlides = function(slides, removeMatched) {
                    // Populate the state slides array
                    slides.forEach(function(slide) {
                        // If a slides array was present the only nodes allowed are prerendered ID'ed content
                        if (config.slides) {
                            var found = void 0;
                            var attribute = slide.getAttribute(SLIDER_SLIDE_ID);
                            for (var i = 0; i < config.slides.length; i++) {
                                if (attribute && attribute === config.slides[i].id) {
                                    found = config.slides[i];
                                    break;
                                }
                            }
                            if (found) {
                                found.domNode = slide;
                                state.__slides.set(found.id, found);
                            } else {
                                slide.remove();
                            }
                            // Otherwise, all slides are valid. Run initial construction
                        } else {
                            var slideMeta = {
                                id: generateSlideId(state.__slides),
                                domNode: slide,
                                scope: {},
                            };
                            createSlideNode(slideMeta, config);
                            state.__slides.set(slideMeta.id, slideMeta);
                            state.__order.push(slideMeta.id);
                        }
                        if (removeMatched) {
                            el.removeChild(slide);
                        }
                    });
                };
                if (slideWrapper) {
                    state.__track = slideWrapper.querySelector("." + SLIDE_TRACK_CLASS);
                    validateSlides(Array.prototype.slice.call(state.__track.children));
                    // If a slide wrapper was found, all other remaining nodes are invalid
                    slides.forEach(function(slide) {
                        slide.remove();
                    });
                } else {
                    validateSlides(slides, true);
                    slideWrapper = _document.createElement('div');
                    slideWrapper.classList.add(SLIDE_WRAPPER_CLASS);
                    state.__track = _document.createElement('div');
                    state.__track.classList.add(SLIDE_TRACK_CLASS);
                    slideWrapper.appendChild(state.__track);
                    el.insertBefore(slideWrapper, el.childNodes[0]);
                }
                state.__wrapper = slideWrapper;
                // Handle control creation/removal
                if (!state.__controls) {
                    state.__controls = {};
                }
                // When carousel uses slide configuration over DOM, all slides must be preloded
                // into __slides on init
                if (config.slides) {
                    for (var i = 0; i < config.slides.length; i++) {
                        var slideConfig = {};
                        if (!config.slides[i].id) {
                            slideConfig.id = generateSlideId(state.__slides);
                        }
                        if (!state.__slides.has(slideConfig.id)) {
                            slideConfig = __assign({}, slideConfig, config.slides[i]);
                            state.__slides.set(slideConfig.id, slideConfig);
                        }
                        state.__order.push(slideConfig.id);
                    }
                }
                // @TODO find somewhere better for this
                if (config.looping &&
                    config.inView + (config.slidesToScroll * 2) > state.__order.length) {
                    config.looping = false;
                }
                state.__active_slides = updateSlides(el, state, config, true);
                // Now that slides have been created/indexed, dump prerender styles and carousel
                // initialization state to the client
                Object(__WEBPACK_IMPORTED_MODULE_0__serverHelpers__["a" /* prerenderBootstrapHelper */ ])(el, config, state, uniqueId);
                return state;
            }
            /**
             * Creates missing control elements if required
             * @param controls Current controls object on the state
             * @param _document Current document render context
             * Returns new control state
             */
            function createControls(controls, _document) {
                if (!controls.__wrapper) {
                    var controlWrapper = _document.createElement('div');
                    controlWrapper.classList.add(CONTROL_WRAPPER_CLASS);
                    controls.__wrapper = controlWrapper;
                }
                ['left', 'right'].forEach(function(dir) {
                    if (!controls["__" + dir]) {
                        var control = _document.createElement('button');
                        var svgName = "arrow" + (dir === 'left' ? 'Left' : 'Right');
                        control.innerHTML = __WEBPACK_IMPORTED_MODULE_2__node_modules_forbes_fbs_icons___default.a[svgName];
                        control.classList.add(dir === 'left' ? CONTROL_LEFT_CLASS : CONTROL_RIGHT_CLASS);
                        controls.__wrapper.appendChild(control);
                        controls["__" + dir] = control;
                    }
                });
                return controls;
            }
            /**
             * Creates a new DOM node with the slide content.
             * If one already exists and is stored, it returns that instead of creating a new one.
             *
             * @TODO - Too many slide nodes created at once will bog down the browser from detached DOM trees.
             * Perhaps implement some kind of LRU cache purge of old slide domNodes?
             * @param slideData
             * @param config
             */
            function createSlideNode(slideData, config) {
                var node;
                var _document = __WEBPACK_IMPORTED_MODULE_1__utility__["e" /* hasDocument */ ] ? document : config.serverDomEngine;
                if (slideData.domNode) {
                    node = slideData.domNode;
                } else if (slideData.textContent) {
                    var container = _document.createElement('div');
                    container.innerHTML = slideData.textContent;
                    delete slideData.textContent;
                    if (container.firstElementChild.classList.contains(SLIDE_CLASS)) {
                        container = container.firstElementChild;
                    }
                    node = container;
                } else if (config.slideGenerator) {
                    node = config.slideGenerator(slideData.scope, __WEBPACK_IMPORTED_MODULE_1__utility__["e" /* hasDocument */ ] ? document : config.serverDomEngine);
                } else {
                    console.error("WARNING: Slide " + slideData.id + " was generated with no content! Provide a generator function.");
                    node = _document.createElement('div');
                }
                node.classList.add(SLIDE_CLASS);
                node.setAttribute(SLIDER_SLIDE_ID, slideData.id);
                // Load async images from slide
                // Don't load image attributes when server-side rendering, it's handled later during the style dump
                // @TODO ...maybe rethink this
                if (!config.isServerPrerender) {
                    var datasetLocation = config.imagePreloadAttribute.split('-')
                        .filter(function(val) {
                            return val.toLowerCase() !== 'data';
                        })
                        .map(function(val, idx) {
                            return idx === 0 ? val : "" + val.slice(0, 1).toUpperCase() + val.slice(1);
                        })
                        .join('');
                    if (node.imagesPreloaded !== datasetLocation) {
                        var imagePreload = node.querySelectorAll("*[" + config.imagePreloadAttribute + "]");
                        for (var i = 0; i < imagePreload.length; i++) {
                            imagePreload[i].style.backgroundImage = "url(" + imagePreload[i].dataset[datasetLocation] + ")";
                        }
                        // Don't try to load this image again
                        node.imagesPreloaded = datasetLocation;
                    }
                }
                slideData.domNode = node;
                // Callback for the first time createSlideNode is called on a slide
                if (!node.fbsCalledback) {
                    if (config.slideGeneratedCallback) {
                        config.slideGeneratedCallback(slideData);
                        // Don't try to load this image again
                        node.fbsCalledback = true;
                    }
                }
                return node;
            }
            /**
             * Generates a new, random slide ID. No duplicates.
             * @param slides Existing slide pool to check for duplicates
             */
            function generateSlideId(slides) {
                var slideId;
                do {
                    slideId = (Math.random() * 1e20).toString(28);
                } while (slides.has(slideId));
                return slideId;
            }
            /**
             * Inserts and removes controls based on active configuration. Adds enabled/disabled classes if non-looping and required
             * @param el Parent <fbs-carousel> or `fbs-slider` element
             * @param state Current carousel state.
             * @param config Carousel active configuration.
             */
            function toggleControls(el, state, config) {
                var controlsActive = config.showControls && config.enabled !== false;
                if (controlsActive && !state.__controls.__wrapper) {
                    var _document = __WEBPACK_IMPORTED_MODULE_1__utility__["e" /* hasDocument */ ] ? document : config.serverDomEngine;
                    state.__controls = createControls(state.__controls, _document);
                    el.insertBefore(state.__controls.__wrapper, state.__wrapper.nextSibling);
                } else if (state.__controls.__wrapper) {
                    if (controlsActive) {
                        el.classList.remove(CONTROL_DISABLED_WRAPPER_CLASS);
                    } else {
                        el.classList.add(CONTROL_DISABLED_WRAPPER_CLASS);
                    }
                }
                // Enable/disable control arrows for non-looping carousels
                // Also disables control arrows for server prerenders
                var cb = function(el, enabled) {
                    if (enabled) {
                        el.classList.remove(CONTROL_DISABLED_CLASS);
                    } else {
                        el.classList.add(CONTROL_DISABLED_CLASS);
                    }
                };
                var left = state.__controls.__left;
                var right = state.__controls.__right;
                if (left) {
                    cb(left, !((!config.looping && state.__index === 0) || config.isServerPrerender));
                }
                if (right) {
                    cb(right, !((!config.looping && state.__index + config.inView === state.__order.length) || config.isServerPrerender));
                }
            }
            /**
             * Updates carousel display state to match new state.__order
             * @param el Parent <fbs-carousel> or `fbs-slider` element
             * @param state Current carousel state.
             * @param config Carousel active configuration.
             * @param resized Has a resize event happened since the last time this ran?
             */
            function updateSlides(el, state, config, resized) {
                if (resized === void 0) {
                    resized = false;
                }
                var displayedSlides = [];
                // @TODO: Support looping element cloning
                // Preload slidesToScroll slides left, if available
                // If running a server render, only show visible slides
                var startIndex = config.isServerPrerender ? state.__index : state.__index - config.slidesToScroll;
                if (!config.looping) {
                    startIndex = Math.max(0, startIndex);
                }
                // Show inView slides, then preload slidesToScroll slides right
                // If running a server prerender, only show visible slides
                var endIndex = state.__index + config.inView + (config.isServerPrerender ? 0 : config.slidesToScroll);
                if (!config.looping) {
                    endIndex = Math.min(state.__order.length, endIndex);
                }
                // If any breakpoint in the carousel has a disabled attribute, then need to dump every slide regardless of preloading rules
                if (config.enabled === false || (config.isServerPrerender && config.hasDisabledBreakpoint)) {
                    startIndex = 0;
                    endIndex = state.__order.length;
                }
                // Track all current children
                for (var i = 0; i < state.__track.childNodes.length; i++) {
                    state.__track.removeChild(state.__track.childNodes[0]);
                    i--;
                }
                // Only need to reset carousel/track level sizings on parent resize
                if (resized) {
                    state.__viewWidth = state.__wrapper.getBoundingClientRect().width;
                    state.__slideWidth = state.__viewWidth / config.inView;
                    // Server track size is controlled by dumped CSS
                    if (!config.isServerPrerender && config.enabled !== false) {
                        state.__track.style.width = (state.__slideWidth) * (endIndex - startIndex) + "px";
                    } else {
                        state.__track.style.width = '100%';
                    }
                }
                // @TODO - Don't reset this number if not strictly required
                // Needed on slide change and resize
                var offset = -(state.__slideWidth * config.slidesToScroll);
                if (!config.looping) {
                    offset = -(state.__slideWidth * Math.min(config.slidesToScroll, state.__index));
                }
                if (config.isServerPrerender || config.enabled === false) {
                    offset = 0;
                }
                state.__track.style.transform = "translateX(" + offset + "px)";
                state.__translationOffset = offset;
                for (var i = startIndex; i < endIndex; i++) {
                    var currentSlideId = Object(__WEBPACK_IMPORTED_MODULE_1__utility__["g" /* loopIndexOrder */ ])(state.__order, i);
                    var currentSlide = state.__slides.get(currentSlideId);
                    var slide = createSlideNode(currentSlide, config);
                    var inView = i >= state.__index && i < state.__index + config.inView;
                    displayedSlides.push({
                        inView: inView,
                        slideData: currentSlide,
                    });
                    if (inView && i === state.__index + config.currentOffset) {
                        slide.classList.add('active', 'primary');
                    } else if (inView) {
                        slide.classList.add('active');
                        slide.classList.remove('primary');
                    } else {
                        slide.classList.remove('active', 'primary');
                    }
                    if (!config.isServerPrerender && config.enabled !== false) {
                        slide.style.width = (state.__slideWidth) + "px";
                    } else if (config.enabled === false) {
                        slide.style.width = '';
                    }
                    state.__track.appendChild(slide);
                }
                // If the number of slides changed, and not on the server, then update the track width
                if (displayedSlides.length !== (state.__active_slides || []).length && !config.isServerPrerender && config.enabled !== false) {
                    state.__track.style.width = (state.__slideWidth) * (endIndex - startIndex) + "px";
                }
                toggleControls(el, state, config);
                return displayedSlides;
            }


            /***/
        }),
        /* 3 */
        /***/
        (function(module, __webpack_exports__, __webpack_require__) {

            "use strict";
            /* harmony export (binding) */
            __webpack_require__.d(__webpack_exports__, "a", function() {
                return FbsCarousel;
            });
            /* harmony import */
            var __WEBPACK_IMPORTED_MODULE_0__helpers_utility__ = __webpack_require__(0);
            /* harmony import */
            var __WEBPACK_IMPORTED_MODULE_1__helpers_dom__ = __webpack_require__(2);
            var __assign = (this && this.__assign) || Object.assign || function(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (var p in s)
                        if (Object.prototype.hasOwnProperty.call(s, p))
                            t[p] = s[p];
                }
                return t;
            };



            var FbsCarousel = /** @class */ (function() {
                /**
                 * Creates a new fbs-carousel from scratch
                 * @param el HTML element of base level element. Required. Must be either <fbs-carousel> or have class `fbs-slider`
                 * @param config Optional configuration value to use. If not passed loads from window, or defaults.
                 *               See `Utility.findCurrentConfiguration` for more.
                 */
                function FbsCarousel(el, config) {
                    this.el = el;
                    this.isAnimating = false;
                    this.__config = config;
                }
                FbsCarousel.prototype.init = function() {
                    // An element is required to configure a carousel correctly.
                    if (!this.el) {
                        return;
                    }
                    this.loadConfiguration(this.__config);
                    this.loadState();
                    this.el.classList.add('fbs-slider--initialized');
                    this.registerEvents();
                    this.triggerEvent('sliderInitialized', {
                        currentSlide: this.getCurrentSlide(),
                    });
                };
                FbsCarousel.prototype.uninit = function() {
                    this.unregisterEvents();
                    this.triggerEvent('sliderDestroyed', {
                        currentSlide: this.getCurrentSlide(),
                    });
                };
                /**
                 * Sets global and active configurations
                 * @param config Starting configuration to use, otherwise load from default locations
                 */
                FbsCarousel.prototype.loadConfiguration = function(config) {
                    this.__config = Object(__WEBPACK_IMPORTED_MODULE_0__helpers_utility__["b" /* findCurrentConfiguration */ ])(config, this.el);
                    this.__active_config = Object(__WEBPACK_IMPORTED_MODULE_0__helpers_utility__["c" /* generateActiveConfiguration */ ])(this.__config);
                };
                /**
                 * Initializes carousel state from loaded config.
                 * This function should *only* be called from init(), and will reset a carousel back to initial configuration values.
                 *
                 * Only use this function when actually necessary. It's extremely expensive.
                 */
                FbsCarousel.prototype.loadState = function() {
                    // Generate initial carousel state from child DOM elements
                    this.__state = Object(__WEBPACK_IMPORTED_MODULE_1__helpers_dom__["g" /* initFromDom */ ])(this.el, this.__active_config);
                };
                /**
                 * Registers event handlers for touch and mouse drag, window resize, orientation change
                 */
                FbsCarousel.prototype.registerEvents = function() {
                    var _this = this;
                    // Register prev/next buttons
                    if (this.__state.__controls.__left) {
                        this.__state.__controls.__left.addEventListener('click', function() {
                            return _this.goPrev();
                        });
                    }
                    if (this.__state.__controls.__right) {
                        this.__state.__controls.__right.addEventListener('click', function() {
                            return _this.goNext();
                        });
                    }
                    this.handleSwipe();
                    if (typeof window !== 'undefined') {
                        window.addEventListener('resize', this.resize.bind(this));
                        window.addEventListener('orientationchange', this.resize.bind(this));
                    }
                };
                /**
                 * Don't leak your listeners
                 */
                FbsCarousel.prototype.unregisterEvents = function() {
                    // @TODO
                };
                /**
                 * Changes slide index
                 * @param slidesToChange Number of slides to move left/right
                 * @returns True if carousel is attempting to change slide index, false if it failed for any reason
                 */
                FbsCarousel.prototype.go = function(slidesToChange) {
                    var _this = this;
                    if (slidesToChange === void 0) {
                        slidesToChange = 0;
                    }
                    var delta = slidesToChange;
                    // Bail if currently mid-slide change
                    if (this.isAnimating) {
                        return false;
                    }
                    // If not an infinite looping carousel, normalize to maximum distance allowed
                    if (!this.__active_config.looping) {
                        if (this.__state.__index + delta < 0) {
                            delta = -this.__state.__index;
                        }
                        if (this.__state.__index + delta + this.__active_config.inView > this.__state.__order.length) {
                            delta = Math.max(0, this.__state.__order.length - (this.__state.__index + this.__active_config.inView));
                        }
                    }
                    // Don't do anything if you're not actually going anywhere
                    if (this.__active_config.enabled === false || delta % this.__state.__order.length === 0) {
                        return false;
                    }
                    // Broadcast the slide we are going to next.
                    var currentSlide = this.getCurrentSlide();
                    var targetSlide = this.__state.__slides.get(Object(__WEBPACK_IMPORTED_MODULE_0__helpers_utility__["g" /* loopIndexOrder */ ])(this.__state.__order, this.__state.__index + delta + this.__active_config.currentOffset));
                    this.triggerEvent('slideChangeStart', {
                        currentSlide: currentSlide,
                        targetSlide: targetSlide,
                    });
                    /**
                     * Update the carousel index and rerender the slides.
                     * Also fires the completed `slideChanged` event
                     * Called either after transition if within viewing distance, or immediately if out of range.
                     */
                    var changeSlide = (function() {
                        _this.__state.__index = Object(__WEBPACK_IMPORTED_MODULE_0__helpers_utility__["f" /* loopIndex */ ])(_this.__state.__index + delta, _this.__state.__order.length);
                        _this.__state.__active_slides = Object(__WEBPACK_IMPORTED_MODULE_1__helpers_dom__["h" /* updateSlides */ ])(_this.el, _this.__state, _this.__active_config, false);
                        _this.triggerEvent('slideChanged', {
                            previousSlide: currentSlide,
                            currentSlide: targetSlide,
                        });
                    }).bind(this);
                    // Figure out how many slides left and right need to transition
                    var distances = Object(__WEBPACK_IMPORTED_MODULE_0__helpers_utility__["d" /* getDistances */ ])(this.__state.__index, Object(__WEBPACK_IMPORTED_MODULE_0__helpers_utility__["f" /* loopIndex */ ])(this.__state.__index + delta, this.__state.__order.length), this.__state.__order.length);
                    // If moving more than the maximum allowable slides, don't animate.
                    // In a looping carousel, use straight line distance left/right to calculate maximums
                    if ((this.__active_config.looping &&
                            distances[0] > this.__active_config.slidesToScroll &&
                            distances[1] > this.__active_config.slidesToScroll) ||
                        // In a non-looping, use simple slide change index value
                        (!this.__active_config.looping && Math.abs(delta) > this.__active_config.slidesToScroll)) {
                        // Bypass animations
                        changeSlide();
                        return true;
                    }
                    // Start sliding in the direction requested
                    this.isAnimating = true;
                    this.__state.__track.classList.add(FbsCarousel.ANIMATING_CLASS);
                    // Calculate translate pixel distance based on number of slides to transition and apply it.
                    // Give it a quick timeout to allow the classList add to complete and give the transitions
                    var transitionOffset = this.__active_config.looping ?
                        (distances[0] > distances[1] ? distances[1] : -distances[0]) : delta;
                    var offset = this.__state.__translationOffset - (this.__state.__slideWidth * transitionOffset);
                    setTimeout(function() {
                        _this.__state.__track.style.transform = "translateX(" + offset + "px)";
                    }, 0);
                    // After transform has finished CSS transitioning, remove transition class and rerender the
                    // slide list
                    setTimeout(function() {
                        _this.isAnimating = false;
                        _this.__state.__track.classList.remove(FbsCarousel.ANIMATING_CLASS);
                        changeSlide();
                    }, this.__active_config.speed);
                    return true;
                };
                /**
                 * Handy go() aliases
                 */
                FbsCarousel.prototype.goPrev = function() {
                    return this.go(-(this.__active_config.slidesToScroll));
                };
                FbsCarousel.prototype.goNext = function() {
                    return this.go(this.__active_config.slidesToScroll);
                };
                FbsCarousel.prototype.goToIndex = function(index) {
                    return this.go(index - this.__state.__index);
                };
                FbsCarousel.prototype.goToSlideById = function(slideId) {
                    var index = this.__state.__order.indexOf(slideId);
                    return index === -1 ? false : this.goToIndex(index);
                };
                // @TODO Refactor touch events again after SSR is handled more sanely
                FbsCarousel.prototype.handleSwipe = function() {
                    var _this = this;
                    var touchstartX = 0;
                    var touchendX = 0;
                    var startWinY = 0;
                    var thresholdX = 50;
                    var thresholdY = 50;

                    function tooMuchY(start, end) {
                        if (start > end) {
                            return start - end > thresholdY;
                        } else {
                            return end - start > thresholdY;
                        }
                    }
                    this.el.addEventListener('touchstart', function(event) {
                        touchstartX = event.changedTouches[0].screenX;
                        startWinY = window.pageYOffset;
                    }, false);
                    this.el.addEventListener('touchend', function(event) {
                        touchendX = event.changedTouches[0].screenX;
                        if (!tooMuchY(startWinY, window.pageYOffset)) {
                            if (touchendX < touchstartX && (touchstartX - touchendX > thresholdX)) {
                                _this.go(_this.__active_config.slidesToScroll);
                            } else if (touchendX > touchstartX && (touchendX - touchstartX > thresholdX)) {
                                _this.go(-_this.__active_config.slidesToScroll);
                            }
                        }
                    }, false);
                };
                /**
                 * Custom event interceptor
                 * @TODO - Add window object level callbacks in config
                 * @param event Event name
                 * @param detail Data to pass alongside event
                 */
                FbsCarousel.prototype.triggerEvent = function(event, detail) {
                    if (typeof CustomEvent !== 'undefined') {
                        this.el.dispatchEvent(new CustomEvent(event, {
                            detail: __assign({}, detail, {
                                activeSlides: this.__state.__active_slides
                            }),
                        }));
                    }
                };
                /**
                 * Resizes the carousel
                 * Rerenders the current slide state with updated width information
                 * Fires on window resize and orientation change
                 * Can be manually called by the custom element, or class interface
                 */
                FbsCarousel.prototype.resize = function() {
                    this.loadConfiguration(this.__config);
                    // @TODO find somewhere better for this
                    // Disable looping if the carousel is too small for it at this breakpoint
                    if (this.__active_config.looping &&
                        this.__active_config.inView + (this.__active_config.slidesToScroll * 2) > this.__state.__order.length) {
                        this.__active_config.looping = false;
                    }
                    // Move back a slide if you change the number of visible slides on us
                    if (!this.__active_config.looping && this.__state.__index + this.__active_config.inView > this.__state.__order.length) {
                        this.__state.__index = this.__state.__order.length - this.__active_config.inView;
                    }
                    this.__state.__active_slides = Object(__WEBPACK_IMPORTED_MODULE_1__helpers_dom__["h" /* updateSlides */ ])(this.el, this.__state, this.__active_config, true);
                    this.triggerEvent('sliderResized', {
                        currentSlide: this.getCurrentSlide(),
                    });
                };
                /**
                 * Returns current active slide data. Only returns data for __index, not all inView slides.
                 */
                FbsCarousel.prototype.getCurrentSlide = function() {
                    return this.__state.__slides.get(this.__state.__order[this.__state.__index + this.__active_config.currentOffset]);
                };
                /**
                 * Returns list of all slides currently added to dom.
                 */
                FbsCarousel.prototype.getActiveSlides = function() {
                    return this.__state.__active_slides;
                };
                /**
                 * Adds slides to the carousel at provided index.
                 * If no index is provided, then slide will be inserted at the end.
                 * @param slideData[] Slide data used to generate the new slide(s)
                 * @param index Location to insert the slide. Default end.
                 * @param adjustIndex If slides are inserted before the currently visible slide, adjust
                 * 					  index to keep user on the intended slide?
                 * @returns Slide IDs if slides were inserted successfully
                 */
                FbsCarousel.prototype.addSlides = function(slideData, index, adjustIndex) {
                    if (adjustIndex === void 0) {
                        adjustIndex = true;
                    }
                    var _a;
                    if (!index && index !== 0) {
                        index = this.__state.__order.length;
                    }
                    var slides = [];
                    for (var i = 0; i < slideData.length; i++) {
                        if (!slideData[i].id || this.__state.__slides.has(slideData[i].id)) {
                            slideData[i].id = Object(__WEBPACK_IMPORTED_MODULE_1__helpers_dom__["f" /* generateSlideId */ ])(this.__state.__slides);
                        }
                        this.__state.__slides.set(slideData[i].id, slideData[i]);
                        slides.push(slideData[i].id);
                    }
                    (_a = this.__state.__order).splice.apply(_a, [Math.max(0, Math.min(this.__state.__order.length, index)), 0].concat(slides));
                    if (adjustIndex && this.__state.__index >= index) {
                        this.__state.__index += slides.length;
                    }
                    // @TODO - Resize may stop working depending on how the diffing algorithm changes
                    this.resize();
                    return slides;
                };
                FbsCarousel.prototype.addSlide = function(slideData, index, adjustIndex) {
                    if (adjustIndex === void 0) {
                        adjustIndex = true;
                    }
                    return this.addSlides([slideData], index, adjustIndex)[0];
                };
                /**
                 * Removes slides by ID. Not limited to any specific index groupings.
                 * @param slideIds Array of slide ID strings to remove
                 * @param adjustIndex If slides are removed before the currently visible slide, adjust
                 * 					  index to keep user on the intended slide?
                 * @returns List of slide IDs that were successfully removed
                 */
                FbsCarousel.prototype.removeSlides = function(slideIds, adjustIndex) {
                    if (adjustIndex === void 0) {
                        adjustIndex = true;
                    }
                    var success = [];
                    var adjustment = 0;
                    for (var i = 0; i < slideIds.length; i++) {
                        var index = this.__state.__order.indexOf(slideIds[i]);
                        if (index !== -1) {
                            var slideId = this.__state.__order[index];
                            if (index < this.__state.__index) {
                                adjustment--;
                            }
                            success.push(slideId);
                            this.__state.__slides.delete(slideId);
                            this.__state.__order.splice(index, 1);
                        }
                    }
                    if (adjustIndex) {
                        this.__state.__index += adjustment;
                    }
                    // @TODO - Resize may stop working depending on how the diffing algorithm changes
                    this.resize();
                    return success;
                };
                FbsCarousel.prototype.removeSlide = function(slideId, adjustIndex) {
                    if (adjustIndex === void 0) {
                        adjustIndex = true;
                    }
                    return this.removeSlides([slideId], adjustIndex)[0];
                };
                /**
                 * Helper function to remove slides by ID. By using the function removeSlide which uses IDs alone,
                 * there are no issues with slide removal batching. No need to progressively adjust indexes!
                 * @param index Array of slide indexes to remove
                 * @param adjustIndex If slides are removed before the currently visible slide, adjust
                 * 					  index to keep user on the intended slide?
                 * @return List of slide IDs that were successfully removed
                 */
                FbsCarousel.prototype.removeSlidesByIndex = function(index, adjustIndex) {
                    if (adjustIndex === void 0) {
                        adjustIndex = true;
                    }
                    var slides = [];
                    for (var i = 0; i < index.length; i++) {
                        var slide = this.__state.__order[index[i]];
                        if (slide && slides.indexOf(slide) === -1) {
                            slides.push(slide);
                        }
                    }
                    if (slides.length > 0) {
                        return this.removeSlides(slides, adjustIndex);
                    }
                    return [];
                };
                FbsCarousel.prototype.removeSlideByIndex = function(index, adjustIndex) {
                    if (adjustIndex === void 0) {
                        adjustIndex = true;
                    }
                    return this.removeSlidesByIndex([index], adjustIndex)[0];
                };
                FbsCarousel.prototype.getEl = function() {
                    return this.el;
                };
                FbsCarousel.ANIMATING_CLASS = 'is-animating';
                return FbsCarousel;
            }());



            /***/
        }),
        /* 4 */
        /***/
        (function(module, __webpack_exports__, __webpack_require__) {

            "use strict";
            /* harmony export (immutable) */
            __webpack_exports__["a"] = prerenderBootstrapHelper;
            /* harmony import */
            var __WEBPACK_IMPORTED_MODULE_0__models_fbs_carousel_config__ = __webpack_require__(1);
            /* harmony import */
            var __WEBPACK_IMPORTED_MODULE_1__utility__ = __webpack_require__(0);
            /* harmony import */
            var __WEBPACK_IMPORTED_MODULE_2__dom__ = __webpack_require__(2);
            var __assign = (this && this.__assign) || Object.assign || function(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (var p in s)
                        if (Object.prototype.hasOwnProperty.call(s, p))
                            t[p] = s[p];
                }
                return t;
            };



            /**
             * Creates all required settings for client-side rendering and bootstrap
             * @param el Parent <fbs-carousel> or `fbs-slider` element
             * @param config Current carousel active configuration
             * @param state Current carousel state
             * @param id Current unique identifier for the carousel
             */
            function prerenderBootstrapHelper(el, config, state, id) {
                // If running server-side prerender, dump style tag with complete render information
                if (config.isServerPrerender) {
                    var start_1 = config.hasDisabledBreakpoint ? 0 : state.__index;
                    var end_1 = config.hasDisabledBreakpoint ? state.__active_slides.length : state.__index + config.inView;
                    var visibleSlides_1 = [];
                    // If a slides array is present in configuration, update slide IDs stored
                    // so that the client will correctly import the rendered slides on bootstrap
                    if ((config.originalConfig.slides || []).length) {
                        state.__order.slice(start_1, end_1).forEach(function(slide, i) {
                            var slideData = state.__slides.get(slide);
                            visibleSlides_1.push(slideData);
                            config.originalConfig.slides[start_1 + i].id = slideData.id;
                        });
                        // If no config or slide list was provided, then we need to save slide state or some will be missing.
                    } else {
                        config.originalConfig.slides = [];
                        state.__order.forEach(function(slide, index) {
                            var slideData = __assign({}, state.__slides.get(slide));
                            // If a slide is out of view, then need to dump the textContent so we don't lose the slide
                            if (index < start_1 || index >= end_1) {
                                slideData.textContent = slideData.domNode.outerHTML;
                                delete slideData.id;
                            } else {
                                visibleSlides_1.push(__assign({}, slideData));
                            }
                            delete slideData.domNode;
                            config.originalConfig.slides.push(slideData);
                        });
                    }
                    // Handle style output
                    var _document = __WEBPACK_IMPORTED_MODULE_1__utility__["e" /* hasDocument */ ] ? document : config.serverDomEngine;
                    var styles = _document.createElement('style');
                    var stylePrefix_1 = id.indexOf('#') === 0 ? id : "." + id;
                    var baseStyle = "\n\t\t\tfbs-carousel {\n\t\t\t\tdisplay: block;\n\t\t\t}\n\t\t\t" + stylePrefix_1 + " ." + __WEBPACK_IMPORTED_MODULE_2__dom__["e" /* SLIDE_TRACK_CLASS */ ] + " {\n\t\t\t\twidth: 100%;\n\t\t\t}\n\t\t";
                    var imageIndex_1 = 0;
                    // Array to store all breakpoints that still need parsed.
                    // Unlike elsewhere that checks the original configuration values (Without defaults), this needs to use
                    // default values on the top level if and only if no custom configuration was provided.
                    var breakpointTree = [{
                        config: __assign({}, __WEBPACK_IMPORTED_MODULE_0__models_fbs_carousel_config__["a" /* FBS_CAROUSEL_DEFAULTS */ ], (Object.keys(config.originalConfig).length > 0 ? config.originalConfig : config)),
                    }];
                    var breakpointCss_1 = [baseStyle];
                    var cb = function(breakpoint) {
                        var _config = breakpoint.config;
                        // Dump mediaquery if present
                        if (breakpoint.breakpoint) {
                            breakpointCss_1.push(breakpoint.breakpoint + " {");
                        }
                        // Show/hide controls at this breakpoint
                        breakpointCss_1.push("\n\t\t\t\t" + stylePrefix_1 + " ." + __WEBPACK_IMPORTED_MODULE_2__dom__["a" /* CONTROL_WRAPPER_CLASS */ ] + " {\n\t\t\t\t\tdisplay: " + (_config.enabled !== false && _config.showControls !== false ? 'block' : 'none') + ";\n\t\t\t\t}\n\t\t\t");
                        // Loop over slides currently visible at this breakpoint
                        for (var i = 0; i < visibleSlides_1.length; i++) {
                            var slide = visibleSlides_1[i];
                            breakpointCss_1.push(stylePrefix_1 + " ." + __WEBPACK_IMPORTED_MODULE_2__dom__["d" /* SLIDE_CLASS */ ] + "[" + __WEBPACK_IMPORTED_MODULE_2__dom__["c" /* SLIDER_SLIDE_ID */ ] + "=\"" + slide.id + "\"] {");
                            // If the slide is in view, set it visible and give it a width in percentage
                            if (i < _config.inView || _config.enabled === false) {
                                breakpointCss_1.push("\n\t\t\t\t\t\tdisplay: block;\n\t\t\t\t\t\twidth: " + (_config.enabled === false ? 'auto' : 100 / _config.inView + "%") + ";}\n\t\t\t\t\t");
                                // In-view slides get a background-image if it found one!
                                if (slide.domNode) {
                                    var selector = _config.imagePreloadAttribute || 'data-bg-image';
                                    var images = slide.domNode.querySelectorAll("*[" + selector + "]");
                                    for (var index = 0; index < images.length; index++) {
                                        var node = images.item(index);
                                        breakpointCss_1.push("\n\t\t\t\t\t\t\t \t" + stylePrefix_1 + " ." + __WEBPACK_IMPORTED_MODULE_2__dom__["d" /* SLIDE_CLASS */ ] + "[" + __WEBPACK_IMPORTED_MODULE_2__dom__["c" /* SLIDER_SLIDE_ID */ ] + "=\"" + slide.id + "\"] .ssr-i-" + imageIndex_1 + " {\n\t\t\t\t\t\t\t\tbackground-image: url(" + node.getAttribute(selector) + ");}\n\t\t\t\t\t\t\t");
                                        node.classList.add("ssr-i-" + imageIndex_1++);
                                    }
                                }
                                // Otherwise hide it
                            } else {
                                breakpointCss_1.push('display: none;}');
                            }
                        }
                        // If a mediaquery was started, need to end it
                        if (breakpoint.breakpoint) {
                            breakpointCss_1.push('}');
                        }
                    };
                    var _loop_1 = function() {
                        var breakpoint = breakpointTree.pop();
                        if (((breakpoint.config || {}).breakpoints || []).length) {
                            breakpointTree.push.apply(breakpointTree, breakpoint.config.breakpoints.map(function(childBreakpoint) {
                                return (__assign({}, childBreakpoint, {
                                    config: __assign({}, breakpoint.config, {
                                        breakpoints: []
                                    }, childBreakpoint.config)
                                }));
                            }));
                        }
                        cb(breakpoint);
                    };
                    while (breakpointTree.length > 0) {
                        _loop_1();
                    }
                    styles.setAttribute(__WEBPACK_IMPORTED_MODULE_2__dom__["b" /* SLIDER_PRERENDER_STYLES */ ], '');
                    styles.setAttribute('type', 'text/css');
                    styles.innerHTML = breakpointCss_1.join('\n').replace(/\t/gi, '');
                    el.insertBefore(styles, el.firstElementChild);
                    // Handle script output
                    // Super easy, comparatively
                    var script = _document.createElement('script');
                    script.appendChild(_document.createTextNode(("\n\t\twindow.FbsCarouselConfig = window.FbsCarouselConfig || {};\n\t\twindow.FbsCarouselConfig['" + stylePrefix_1.slice(1) + "'] = " + JSON.stringify(config.originalConfig) + ";\n\t\t").replace(/\t/gi, '')));
                    el.appendChild(script);
                }
            }


            /***/
        }),
        /* 5 */
        /***/
        (function(module, exports) {

            module.exports = {
                arrowLeft: '<svg class="fs-icon fs-icon--arrow-left" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 10h16v2h-16z"/><path transform="rotate(-45.001 4.5 8.877)" d="M.5 7.9h8v2h-8z"/><path transform="rotate(45.001 4.5 13.124)" d="M.5 12.1h8v2h-8z"/></svg>',
                arrowRight: '<svg class="fs-icon fs-icon--arrow-right" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path transform="rotate(-180 8.964 11)" d="M1 10h16v2H1z"/><path transform="rotate(134.999 14.965 13.124)" d="M11 12.1h8v2h-8z"/><path transform="rotate(-134.999 14.965 8.877)" d="M11 7.9h8v2h-8z"/></svg>',
                chevronDown: '<svg class="fs-icon fs-icon--chevron-down" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.8 19.8"><path transform="rotate(-134.999 7.586 10.187)" d="M2.8 9h9.5v2.4H2.8z"/><path transform="rotate(-45.001 12.615 10.187)" d="M7.9 9h9.5v2.4H7.9z"/></svg>',
                chevronLeft: '<svg class="fs-icon fs-icon--chevron-left" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.8 19.8"><path transform="rotate(-45.001 10.1 7.672)" d="M5.4 6.5h9.5v2.4H5.4z"/><path transform="rotate(45.001 10.1 12.701)" d="M5.4 11.5h9.5v2.4H5.4z"/></svg>',
                chevronRight: '<svg class="fs-icon fs-icon--chevron-right" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.8 19.8"><path transform="rotate(134.999 10.1 12.701)" d="M5.4 11.5h9.5v2.4H5.4z"/><path transform="rotate(-134.999 10.1 7.672)" d="M5.4 6.5h9.5v2.4H5.4z"/></svg>',
                chevronUp: '<svg class="fs-icon fs-icon--chevron-up" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.8 19.8"><path transform="rotate(45.001 12.615 10.187)" d="M7.9 9h9.5v2.4H7.9z"/><path transform="rotate(134.999 7.586 10.187)" d="M2.8 9h9.5v2.4H2.8z"/></svg>',
                close: '<svg class="fs-icon fs-icon--close" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path transform="rotate(45.001 10 10)" d="M2 9h16v2H2z"/><path transform="rotate(134.999 10 10)" d="M2 9h16v2H2z"/></svg>',
                forbesLogo: '<svg class="fs-icon fs-icon--forbes-logo" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 54"><path d="M113.3 18.2c0-5.8.1-11.2.4-16.2L98.4 4.9v1.4l1.5.2c1.1.1 1.8.5 2.2 1.1.4.7.7 1.7.9 3.2.2 2.9.4 9.5.3 19.9 0 10.3-.1 16.8-.3 19.3 5.5 1.2 9.8 1.7 13 1.7 6 0 10.7-1.7 14.1-5.2 3.4-3.4 5.2-8.2 5.2-14.1 0-4.7-1.3-8.6-3.9-11.7-2.6-3.1-5.9-4.6-9.8-4.6-2.6 0-5.3.7-8.3 2.1zm.3 30.8c-.2-3.2-.4-12.8-.4-28.5.9-.3 2.1-.5 3.6-.5 2.4 0 4.3 1.2 5.7 3.7 1.4 2.5 2.1 5.5 2.1 9.3 0 4.7-.8 8.5-2.4 11.7-1.6 3.1-3.6 4.7-6.1 4.7-.8-.2-1.6-.3-2.5-.4zM41 3H1v2l2.1.2c1.6.3 2.7.9 3.4 1.8.7 1 1.1 2.6 1.2 4.8.8 10.8.8 20.9 0 30.2-.2 2.2-.6 3.8-1.2 4.8-.7 1-1.8 1.6-3.4 1.8l-2.1.3v2h25.8v-2l-2.7-.2c-1.6-.2-2.7-.9-3.4-1.8-.7-1-1.1-2.6-1.2-4.8-.3-4-.5-8.6-.5-13.7l5.4.1c2.9.1 4.9 2.3 5.9 6.7h2V18.9h-2c-1 4.3-2.9 6.5-5.9 6.6l-5.4.1c0-9 .2-15.4.5-19.3h7.9c5.6 0 9.4 3.6 11.6 10.8l2.4-.7L41 3zm-4.7 30.8c0 5.2 1.5 9.5 4.4 12.9 2.9 3.4 7.2 5 12.6 5s9.8-1.7 13-5.2c3.2-3.4 4.7-7.7 4.7-12.9s-1.5-9.5-4.4-12.9c-2.9-3.4-7.2-5-12.6-5s-9.8 1.7-13 5.2c-3.2 3.4-4.7 7.7-4.7 12.9zm22.3-11.4c1.2 2.9 1.7 6.7 1.7 11.3 0 10.6-2.2 15.8-6.5 15.8-2.2 0-3.9-1.5-5.1-4.5-1.2-3-1.7-6.8-1.7-11.3C47 23.2 49.2 18 53.5 18c2.2-.1 3.9 1.4 5.1 4.4zm84.5 24.3c3.3 3.3 7.5 5 12.5 5 3.1 0 5.8-.6 8.2-1.9 2.4-1.2 4.3-2.7 5.6-4.5l-1-1.2c-2.2 1.7-4.7 2.5-7.6 2.5-4 0-7.1-1.3-9.2-4-2.2-2.7-3.2-6.1-3-10.5H170c0-4.8-1.2-8.7-3.7-11.8-2.5-3-6-4.5-10.5-4.5-5.6 0-9.9 1.8-13 5.3-3.1 3.5-4.6 7.8-4.6 12.9 0 5.2 1.6 9.4 4.9 12.7zm7.4-25.1c1.1-2.4 2.5-3.6 4.4-3.6 3 0 4.5 3.8 4.5 11.5l-10.6.2c.1-3 .6-5.7 1.7-8.1zm46.4-4c-2.7-1.2-6.1-1.9-10.2-1.9-4.2 0-7.5 1.1-10 3.2s-3.8 4.7-3.8 7.8c0 2.7.8 4.8 2.3 6.3 1.5 1.5 3.9 2.8 7 3.9 2.8 1 4.8 2 5.8 2.9 1 1 1.6 2.1 1.6 3.6 0 1.4-.5 2.7-1.6 3.7-1 1.1-2.4 1.6-4.2 1.6-4.4 0-7.7-3.2-10-9.6l-1.7.5.4 10c3.6 1.4 7.6 2.1 12 2.1 4.6 0 8.1-1 10.7-3.1 2.6-2 3.9-4.9 3.9-8.5 0-2.4-.6-4.4-1.9-5.9-1.3-1.5-3.4-2.8-6.4-4-3.3-1.2-5.6-2.3-6.8-3.3-1.2-1-1.8-2.2-1.8-3.7s.4-2.7 1.3-3.7 2-1.4 3.4-1.4c4 0 6.9 2.9 8.7 8.6l1.7-.5-.4-8.6zm-96.2-.9c-1.4-.7-2.9-1-4.6-1-1.7 0-3.4.7-5.3 2.1-1.9 1.4-3.3 3.3-4.4 5.9l.1-8-15.2 3v1.4l1.5.1c1.9.2 3 1.7 3.2 4.4.6 6.2.6 12.8 0 19.8-.2 2.7-1.3 4.1-3.2 4.4l-1.5.2v1.9h21.2V49l-2.7-.2c-1.9-.2-3-1.7-3.2-4.4-.6-5.8-.7-12-.2-18.4.6-1 1.9-1.6 3.9-1.8 2-.2 4.3.4 6.7 1.8l3.7-9.3z"/></svg>',
                hamburger: '<svg class="fs-icon fs-icon--hamburger" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2 5.5h16v2H2zM2 9.5h16v2H2zM2 13.5h16v2H2z"/></svg>',
                play: '<svg class="fs-icon fs-icon--play" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M7 2v16.9l11.1-8.5z"/></svg>',
                search: '<svg class="fs-icon fs-icon--search" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><circle fill="none" stroke="#000" stroke-width="2" cx="8.5" cy="9" r="6"/><path transform="rotate(45.001 14.922 15.421)" d="M12 14.4h5.9v2H12z"/></svg>',
            };


            /***/
        }),
        /* 6 */
        /***/
        (function(module, __webpack_exports__, __webpack_require__) {

            "use strict";
            /* harmony export (binding) */
            __webpack_require__.d(__webpack_exports__, "a", function() {
                return FbsCarouselComponent;
            });
            /* harmony import */
            var __WEBPACK_IMPORTED_MODULE_0__fbs_carousel__ = __webpack_require__(3);
            var __extends = (this && this.__extends) || (function() {
                var extendStatics = Object.setPrototypeOf ||
                    ({
                            __proto__: []
                        }
                        instanceof Array && function(d, b) {
                            d.__proto__ = b;
                        }) ||
                    function(d, b) {
                        for (var p in b)
                            if (b.hasOwnProperty(p)) d[p] = b[p];
                    };
                return function(d, b) {
                    extendStatics(d, b);

                    function __() {
                        this.constructor = d;
                    }
                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            })();

            var FbsCarouselComponent = /** @class */ (function(_super) {
                __extends(FbsCarouselComponent, _super);

                function FbsCarouselComponent(el) {
                    var _this = _super.call(this) || this;
                    _this.carousel = new __WEBPACK_IMPORTED_MODULE_0__fbs_carousel__["a" /* FbsCarousel */ ](_this);
                    return _this;
                }
                FbsCarouselComponent.prototype.connectedCallback = function() {
                    this.carousel.init();
                };
                FbsCarouselComponent.prototype.disconnectedCallback = function() {
                    this.carousel.uninit();
                };
                Object.defineProperty(FbsCarouselComponent.prototype, "currentSlide", {
                    /**
                     * The following are simple interfaces to interact with the exposed members of the FbsCarousel class
                     * See the method documentation for more information.
                     */
                    get: function() {
                        return this.carousel.getCurrentSlide();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(FbsCarouselComponent.prototype, "activeSlides", {
                    get: function() {
                        return this.carousel.getActiveSlides();
                    },
                    enumerable: true,
                    configurable: true
                });
                FbsCarouselComponent.prototype.rerender = function() {
                    this.carousel.resize();
                };
                FbsCarouselComponent.prototype.prevSlide = function() {
                    return this.carousel.goPrev();
                };
                FbsCarouselComponent.prototype.nextSlide = function() {
                    return this.carousel.goNext();
                };
                FbsCarouselComponent.prototype.go = function(slidesToScroll) {
                    return this.carousel.go(slidesToScroll);
                };
                FbsCarouselComponent.prototype.goToIndex = function(index) {
                    return this.carousel.goToIndex(index);
                };
                FbsCarouselComponent.prototype.goToSlideById = function(slideId) {
                    return this.carousel.goToSlideById(slideId);
                };
                FbsCarouselComponent.prototype.addSlide = function(slideData, index, adjustIndex) {
                    if (adjustIndex === void 0) {
                        adjustIndex = true;
                    }
                    return this.carousel.addSlide(slideData, index, adjustIndex);
                };
                FbsCarouselComponent.prototype.addSlides = function(slideData, index, adjustIndex) {
                    if (adjustIndex === void 0) {
                        adjustIndex = true;
                    }
                    return this.carousel.addSlides(slideData, index, adjustIndex);
                };
                FbsCarouselComponent.prototype.removeSlide = function(slideIds, adjustIndex) {
                    if (adjustIndex === void 0) {
                        adjustIndex = true;
                    }
                    return this.carousel.removeSlide(slideIds, adjustIndex);
                };
                FbsCarouselComponent.prototype.removeSlides = function(slideIds, adjustIndex) {
                    if (adjustIndex === void 0) {
                        adjustIndex = true;
                    }
                    return this.carousel.removeSlides(slideIds, adjustIndex);
                };
                FbsCarouselComponent.prototype.removeSlideByIndex = function(index, adjustIndex) {
                    if (adjustIndex === void 0) {
                        adjustIndex = true;
                    }
                    return this.carousel.removeSlideByIndex(index, adjustIndex);
                };
                FbsCarouselComponent.prototype.removeSlidesByIndex = function(index, adjustIndex) {
                    if (adjustIndex === void 0) {
                        adjustIndex = true;
                    }
                    return this.carousel.removeSlidesByIndex(index, adjustIndex);
                };
                return FbsCarouselComponent;
            }(HTMLElement));



            /***/
        }),
        /* 7 */
        ,
        /* 8 */
        ,
        /* 9 */
        ,
        /* 10 */
        ,
        /* 11 */
        ,
        /* 12 */
        ,
        /* 13 */
        ,
        /* 14 */
        ,
        /* 15 */
        ,
        /* 16 */
        ,
        /* 17 */
        ,
        /* 18 */
        ,
        /* 19 */
        ,
        /* 20 */
        /***/
        (function(module, __webpack_exports__, __webpack_require__) {

            "use strict";
            Object.defineProperty(__webpack_exports__, "__esModule", {
                value: true
            });
            /* harmony import */
            var __WEBPACK_IMPORTED_MODULE_0__fbs_carousel__ = __webpack_require__(21);
            /* harmony namespace reexport (by provided) */
            __webpack_require__.d(__webpack_exports__, "FbsCarousel", function() {
                return __WEBPACK_IMPORTED_MODULE_0__fbs_carousel__["a"];
            });
            /* harmony namespace reexport (by provided) */
            __webpack_require__.d(__webpack_exports__, "FbsCarouselComponent", function() {
                return __WEBPACK_IMPORTED_MODULE_0__fbs_carousel__["b"];
            });



            /***/
        }),
        /* 21 */
        /***/
        (function(module, __webpack_exports__, __webpack_require__) {

            "use strict";
            /* harmony import */
            var __WEBPACK_IMPORTED_MODULE_0__fbs_carousel__ = __webpack_require__(3);
            /* harmony namespace reexport (by used) */
            __webpack_require__.d(__webpack_exports__, "a", function() {
                return __WEBPACK_IMPORTED_MODULE_0__fbs_carousel__["a"];
            });
            /* harmony import */
            var __WEBPACK_IMPORTED_MODULE_1__fbs_carousel_component__ = __webpack_require__(6);
            /* harmony namespace reexport (by used) */
            __webpack_require__.d(__webpack_exports__, "b", function() {
                return __WEBPACK_IMPORTED_MODULE_1__fbs_carousel_component__["a"];
            });




            /***/
        })
        /******/
    ]);
});


//////////////////
// WEBPACK FOOTER
// ./node_modules/@forbes/fbs-carousel/dist/index.js
// module id = 10
// module chunks = 0 1 2 3 4 6 7 8 9 12