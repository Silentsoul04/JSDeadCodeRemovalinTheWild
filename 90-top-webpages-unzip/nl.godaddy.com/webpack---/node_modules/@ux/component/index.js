/* eslint no-undefined: 0*/

import Component, { eventdist, target, EventDistContext, EventDistShape, withEventDistContext } from './component';
import breakpoints from './breakpoints';
import debug from 'diagnostics';

//
// We pre-assign an event listener. This has one major drawback and that is that
// we always assign an resize listen even when it's not needed or used by
// components. But the added benefit is that if we have multiple components
// listening, we don't do viewport comparison x amount of times. Another reason
// is that breakpoints.changed() will only evaluate to `true` once. So if we
// have multiple components listening to resize and checking for changes only
// one them will actually see it as changed.
//
eventdist.on('resize', function resized() {
  if (!breakpoints.changed()) return;

  eventdist.emit('breakpoint:' + breakpoints.breakpoint);
  eventdist.emit('breakpoint:changed', breakpoints.breakpoint);
});

/**
 * The default component that extends React.Component so we can force the
 * Component interface and prevent React.createClass usage.
 *
 * @displayName Component (Web)
 * @constructor
 * @public
 */
export default class WebComponent extends Component {
  /**
   * Helper function to create and manage an array of classNames.
   *
   * @returns {String|Undefined} Concatenated result of classNames.
   * @public
   */
  classNames(...names) {
    const result = names
      .filter(Boolean)
      .reduce((memo, className) => {
        if (typeof className === 'string' && ~className.indexOf(' ')) {
          className = className.split(' ');
        }

        if (Array.isArray(className)) {
          Array.prototype.push.apply(memo, this.classNames(...className).split(' '));
        } else if (typeof className === 'object') {
          Object.keys(className).forEach(function each(key) {
          //
          // In object mode we want to optionally enable or disable classNames
          // based on boolean values for the keys. We're not going to be too
          // strict on true and false as we want things like `undefined` and
          // `null` to also trigger removal.
          //
            if (className[key]) {
              memo.push(key);
            } else if (~memo.indexOf(key)) {
              memo.splice(memo.indexOf(key), 1);
            }
          });
        } else {
          memo.push(className);
        }

        return memo;
      }, [])
      .filter(function filter(item, i, all) {
        return Boolean(item) && all.indexOf(item) === i;
      })
      .join(' ');

    //
    // If we return an empty string and directly pass it in to the className
    // property of a React component we will add an empty attribute to the
    // element. Returning `undefined` ensures that no empty property is added.
    //
    // The undefined value is also still accepted as value for the `classNames`
    // method so the resulting className can still be manipulated afterwards.
    //
    return result ? result : undefined;
  }

  /**
   * Check if we are running in a TRUE browser (i.e. **NOT** Node.js)
   * environment. This will only return true in REAL browser environments
   * (i.e. not `jsdom`). The navigator object will toString as '[object Navigator]'
   * instead of '[object Object]' if it was a leaked Node.js global.
   *
   * *NOTE:* This will return true in PhantomJS environments and other headless
   * browsers since those are, in fact, REAL browsers in the strict sense.
   *
   * @returns {Boolean} Is this a browser
   * @public
   */
  get isBrowser() {
    return typeof navigator !== 'undefined' && Object.prototype.toString.call(navigator) === '[object Navigator]';
  }

  /**
   * Helper function to set style.display = 'block'.
   *
   * @returns {Object} style object.
   * @public
   */
  get show() {
    return this.display(true);
  }

  /**
   * Helper function to set style.display = 'none'.
   *
   * @returns {Object} style object.
   * @public
   */
  get hide() {
    return this.display(false);
  }

  /**
   * Helper function to display components. By default sets `display` to 'block'.
   *
   * @param {Object} style Mutable style object.
   * @param {Boolean} show Should style become visible or not.
   * @returns {Object} style object.
   * @public
   */
  display(style, show = true) {
    if (typeof style === 'boolean') {
      show = style;
      style = {};
    }

    style.display = show ? 'block' : 'none';
    return { style };
  }

  /**
   * Calculate the component's offset relative to the window.
   *
   * @param {Node|ReactElement} ref Reference to a DOM Node or React Element.
   * @returns {Object} left and top offsets.
   * @public
   */
  offset(ref) {
    const rect = ref.getBoundingClientRect();

    return {
      left: rect.left + target.pageXOffset - target.document.documentElement.clientLeft,
      top: rect.top + target.pageYOffset - target.document.documentElement.clientTop
    };
  }

  /**
   * Assign an new event listener to the body element that only triggers if the
   * event target is outside the provided reference DOM Node.
   *
   * @param {String} event Event name.
   * @param {Function} fn Completion callback function.
   * @param {Node|ReactElement} ref Reference to a DOM Node or React Element.
   * @returns {Component} Returns self for chaining purposes.
   * @public
   */
  outside(event, fn, ref) {
    /**
     * Trigger the listener if the clicked target does not contain the
     * HTML/Component reference.
     *
     * @param {Event} e Browser event.
     * @private
     */
    function trigger(e) {
      if (ref && !ref.contains(e.target)) fn(e, trigger);
    }

    this.eventdist.on(event, trigger, this);
    return trigger;
  }

  /**
   * Returns a value indicating that the specified `ref` is out of the viewport in
   * a given direction +ve or -ve pixels. If the `ref` is within the viewport then
   * returns 0.
   *
   * @param {Node|ReactElement} ref Reference to a DOM Node or React Element.
   * @returns {Number|undefined} Number of pixels document.body.scrollTop must be modified by
   * @public
   */
  outOfViewport(ref) {
    const rect = ref.getBoundingClientRect();
    if (rect.top < 0) {
      return rect.top;
    }

    const height = window.innerHeight || document.documentElement.clientHeight;
    if (rect.bottom > height) {
      return rect.bottom - height;
    }

    return 0;
  }

  /**
   * Scroll the current element into the visible area of the browser window if not there.
   * If the element is already within the visible area of the browser window, then do not scroll.
   *
   * @param {Node|ReactElement} ref Reference to a DOM Node or React Element.
   * @public
   */
  scrollIntoViewIfNeeded(ref) {
    const outOf = this.outOfViewport(ref);
    if (!outOf) { return; }

    // WebKit & Blink have this native method.
    if (ref.scrollIntoViewIfNeeded) {
      ref.scrollIntoViewIfNeeded(false);
      return;
    }

    //
    // TODO (crobbins, jkeslin): do we still need this in this implementation?
    //
    // // If the menu itself is statically positioned, we need to take that into account
    // if (ref.offsetParent !== ref.parentNode) {
    //   top -= activeItem.parentNode.offsetTop;
    // }

    //
    // Remark (crobbins): MDN suggests checking if `typeof body.scrollTop === 'number'`
    // but based on empirical evidence that documentation is simply wrong. Other sources
    // around the Internetz suggest that when the value is 0 `document.body` should be used.
    // (see: https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect)
    //
    let body = document.documentElement || document.body.parentNode;
    if (body.scrollTop === 0) {
      body = document.body;
    }

    body.scrollTop = body.scrollTop + outOf;
  }
}

//
// Export our utilized internals in various ways so they can be imported as
// standalone functionality through the `import {debug} from 'component'`
// syntax as well as access them directly through the exposed Component
// constructor. This allows build systems to optimize and remove dead code if
// needed.
//
export { debug, eventdist, breakpoints, EventDistContext, EventDistShape, withEventDistContext };

WebComponent.debug = debug;
WebComponent.eventdist = eventdist;
WebComponent.breakpoints = breakpoints;
WebComponent.EventDistContext = EventDistContext;
WebComponent.EventDistShape = EventDistShape;
WebComponent.withEventDistContext = withEventDistContext;



// WEBPACK FOOTER //
// ./node_modules/@ux/component/index.js