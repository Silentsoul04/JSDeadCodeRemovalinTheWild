import { NamespaceConsumer, NamespaceShape } from '@ux/namespace-component';
import { propTypes, getValue, getType, getStateProperty } from './enums';
import { Validates } from 'react-validation-context';
import PropTypes from 'prop-types';
import Textual from './textual';
import Flip from './flip';
import React from 'react';

const undef = void 0;

/**
 * Helper function to discover data to use.
 *
 * @param {String} name Name of the key to search.
 * @param {Array} dataset Data set to search
 * @param {Mixed} fallback Optional fallback data.
 * @returns {Any} The found result.
 * @private
 */
function find(name, dataset, fallback) {
  const data = dataset.filter(obj => typeof obj[name] !== 'undefined')[0];

  if (typeof data !== 'object') {
    return fallback;
  }

  return data[name];
}

/**
 * Base class that contains the validation logic for inputs
 *
 * @displayName FormElement
 *
 * @class Base
 * @public
 */
export default class Base extends NamespaceConsumer {
  constructor() {
    super(...arguments);

    this.state = {
      ...this.state,
      hadInput: false
    };

    this.ignoreProps = [];
    this.elements = {};

    this.clear = this.clear.bind(this);
    this.onChange = this.onChange.bind(this);
  }

  /**
   * React lifecycle hook invoked when component is about to mount. Unless the overriding `validates`
   * property is present, initially load the Input as valid and only call `validating` on change.
   *
   * @private
   */
  componentWillMount() {
    const { props } = this;
    const type = this.select('type');
    const required = this.select('required');

    this.isFlip = type === 'checkbox' || type === 'radio';

    this.setState({ hadInput: !required || 'validates' in props || this.state.hadInput });

    if ('validates' in props || required) {
      this.validating(this.select('value'), this.select('validate'), (error, isValid) => {
        this.setState({ isValid, error });
      });
    }
  }

  /**
   * Handle state changes.
   *
   * @param {Object} prevProps previous this.props.
   * @param {Object} prevState previous this.state.
   */
  componentDidUpdate(prevProps, prevState) { // eslint-disable-line max-statements, complexity
    const nextProps = this.props;
    const lookups = [prevState, prevProps, this];

    if ('validates' in nextProps && prevProps.validates !== nextProps.validates) {
      const failure = nextProps.failure || find('failure', lookups);

      this.setState({
        error: failure && !nextProps.validates ? failure : null,
        isValid: nextProps.validates
      });
    }

    const nextValidate = nextProps.validate;
    const validate = find('validate', lookups);
    const value = nextProps.value || find('value', lookups);

    if ('value' in nextProps && nextProps.value !== prevProps.value && 'onValidation' in nextProps) {
      nextProps.onValidation(nextProps.value);
    }

    const failureMessage = nextProps.failure || (typeof nextProps.required !== 'boolean' ? nextProps.required : undef);

    //
    // Only revalidate the value if both functions exist, are different and their return value is not equal.
    // This will ensure `validate` does not run if identical arrow or bound functions are passed
    // as properties, that are only distinct by memory reference.
    //
    if (nextValidate !== validate) {
      if (nextValidate && validate && nextValidate(value) === validate(value)) {
        return;
      }

      this.validating(value, nextProps.validate, (error, isValid) => {
        this.setState({
          isValid,
          error: (isValid === false && prevState.error !== failureMessage) ? failureMessage : error
        });
      });
    } else if (prevState.isValid === false && prevState.error !== failureMessage) {
      this.setState({ error: failureMessage });
    }
  }

  /**
   * Clean up and merge the properties that can be passed to the internal input element.
   *
   * @param {Object} data Attributes.
   * @returns {Object} properties that can be spread,
   * @private
   */
  filter(data) {
    const props = this.props;
    const spread = Object.keys(props)
      .filter(v => !(v in data || v in propTypes.element || ~this.ignoreProps.indexOf(v) || v in NamespaceShape))
      .reduce((memo, key) => {
        memo[key] = props[key];
        return memo;
      }, {});

    if (this.isFlip && typeof spread.checked !== 'undefined' && typeof spread.defaultChecked !== 'undefined') {
      delete spread.defaultChecked;
    }

    return spread;
  }

  /**
   * Minor mock change handler that should be provided by the developer.
   *
   * @param {Event} event Change event.
   * @param {boolean=} isClear Is the input being cleared by the clear button, defaults to false
   * @private
   */
  onChange(event, isClear = false) {
    const property = !isClear ? getStateProperty(getType(event)) : 'value';
    const value = !isClear ? getValue(event) : this.state.value;
    const props = this.props;

    this.setState({ hadInput: true });

    //
    // Check if the input validates and set state appropriately.
    //
    this.validating(value, this.select('validate'), (error, isValid) => {
      this.setState({ isValid, error });

      //
      // Always call the provided onChange listener as developers might be
      // interested in doing additional validation against event.target.value.
      // Only call the default onChange mock if no value was explicitly passed
      // as property, this prevents duplicating value states.
      //
      if ('onChange' in props) props.onChange(event, value);
      if ('onValidation' in props) props.onValidation(value);
      if (!(property in props)) this.setState({ [property]: value });
    });
  }

  /**
   * Generate all the attributes to be rendered on an input.
   *
   * @returns {Object} Required data to render an input.
   * @private
   */
  attributes() {
    const { isValid, hadInput } = this.state;
    const defaultValue = this.select('defaultValue');
    let { id } = this.props;

    // If no `id` prop was specified, fall back to label
    if (!id) {
      const label = this.select('label');

      id = React.isValidElement(label)  // If the label is a React element with an `id` prop...
        ? label.props.id                // use its `id` prop; otherwise...
        : this.id('label');             // generate an `id` from it
    }

    const result = {
      id,
      type: this.select('type'),
      name: this.select('name'),
      value: this.select('value', defaultValue ? undef : ''),
      placeholder: this.select('placeholder'),
      readOnly: this.select('readOnly'),
      disabled: this.select('disabled'),
      defaultValue: defaultValue,
      autoComplete: this.select('autoComplete'),
      onChange: this.onChange,
      onBlur: this.select('onBlur')
    };

    if (hadInput && isValid === false) { result['data-invalid'] = true; }
    if (!hadInput || isValid === true) { result['data-valid'] = true; }

    return result;
  }

  /**
   * Clear the input value.
   *
   * @param {Event} event Input event.
   * @public
   */
  clear(event) {
    const input = this.elements.input;

    if (event) {
      event.preventDefault();
      event.persist();
    }

    if (input) {
      this.setState({ value: '' }, function () {
        this.onChange(event, true);
      });
      input.focus();
    }
  }

  /**
   * Get data from either the state, props or set property. Allow empty strings to
   * be returned, especially important around `value` property.
   *
   * @param {String} name Property name.
   * @param {Mixed} fallback Fallback value when property does not exist.
   * @returns {Mixed} The value.
   * @private
   */
  select(name, fallback) {
    return find(name, [this.state, this.props, this], fallback);
  }

  /**
   * Checks if the input validates.
   *
   * @param {Mixed} value String or number representating the value to validate.
   * @param {Function} validator Validator function to use. By default, selects the 'validate' property.
   * @param {Function} done Completion callback.
   * @returns {Mixed} The result of the callback.
   * @private
   */
  validating(value, validator, done) { // eslint-disable-line max-statements, complexity
    validator = validator || this.select('validate');

    const required = this.select('required');
    const failure = this.select('failure');
    const input = this.elements.input;

    //
    // `validates` prop overrides everything else.
    //
    if ('validates' in this.props) {
      if (failure && !this.props.validates) {
        return done(failure, false);
      }

      return done(undef, this.props.validates);
    }

    if (!(required || typeof validator === 'function')) {
      return done(undef, null);
    }

    if (input) {
      value = input.value || value;
    } else if (typeof value === 'undefined') {
      value = this.select('value') || this.select('defaultValue');
    }

    if (typeof value === 'string') {
      value = value.trim();
    }

    //
    // No valueÂ provided, but input is required. Only render as invalid if required.
    // Assume `required` is the error message if it is a string.
    //
    if (!value) {
      return done(required, required ? false : null);
    }

    // If a message for failure is provided and the input is invalid
    const isValid = validator && validator.call(this, value);
    if (failure && isValid === false) {
      return done(failure, false);
    }

    return done(undef, validator ? isValid : null);
  }

  /**
   * Render the actual component.
   *
   * @returns {React.DOM} Rendered form element.
   * @private
   */
  render() {
    const { onValidChange, clearable, size } = this.props;
    const data = this.attributes();
    const { isValid: validates, hadInput } = this.state;

    const props = {
      ...data,

      hadInput,
      validates,
      size,
      elements: this.elements,

      error: this._error(),
      notice: this._notice(),
      button: this._button(),
      input: this._input(data),
      required: this._required(),
      hideLabel: this.select('hideLabel'),
      label: this.select('label'),
      grid: this.select('grid'),
      inline: !!this.select('inline'),
      proxy: !!this.select('proxy')
    };

    if (this.isFlip) {
      props.design = this.select('design');
      props.style = this.select('toggleStyle', this.props.style);
      props.action = this.select('action');
      props.checked = !!(this.select('checked', !!this.select('defaultChecked')));
    }

    if (clearable) {
      props.clearable = typeof clearable === 'function' ? clearable : this.clear;
    }

    const Input = this.isFlip
      ? Flip
      : Textual;

    return <Validates name={ data.id || data.name } validates={ validates } onValidChange={ onValidChange }>
      <Input { ...props } />
    </Validates>;
  }
}

/**
 * Allowed Validation properties.
 *
 * @enum {Object} propTypes
 * @public
 */
Base.propTypes = {
  /** A function that is triggered every time that your button is clicked. */
  action: PropTypes.func,
  /** The default value for input element. */
  defaultValue: PropTypes.oneOfType([
    PropTypes.string,
    PropTypes.number,
    PropTypes.bool
  ]),
  /** The name of the input element, so you know under what name your value will be submitted. */
  name: PropTypes.string,
  /** A function that is triggered when the value is updated by the user. */
  onChange: PropTypes.func,
  /** A function that is triggered after the value is updated, by the user or programatically.
   *  Note: Do not use this when wrapping with a Critera.Connect component. */
  onValidation: PropTypes.func,
  /**
   * A boolean or string to indicate if the input field is required. If
   * a string is provided, it will be used as the error message.
   */
  required: PropTypes.oneOfType([
    PropTypes.bool,
    PropTypes.node
  ]),
  /** Indicates if the input is valid.  Overrides the validate function.
   * Note: Use this when the output of validate is the result of higher
   * order properties that are passed in. */
  validates: PropTypes.bool,
  /** A function that returns a boolean as indication for invalid or valid
   * state of the input element. It receives the value as first argument.
   * Note: use this when state is internal to the element, e.g. value or
   * onChange should not be passed in as property. */
  validate: PropTypes.func,
  /** optional styles passed through to flip's button */
  toggleStyle: PropTypes.object
};



// WEBPACK FOOTER //
// ./node_modules/@ux/form-element/element.js