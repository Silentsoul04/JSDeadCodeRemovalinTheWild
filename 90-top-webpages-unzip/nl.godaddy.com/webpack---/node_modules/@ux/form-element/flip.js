import { NamespaceConsumer, withNamespace, NamespaceShape } from '@ux/namespace-component';
import { propTypes, defaultProps } from './enums';
import PropTypes from 'prop-types';
import Fieldset from '@ux/fieldset';
import Button from '@ux/button';
import React from 'react';

/**
 * Renders a radio/checkbox element according to the design specifications.
 *
 * @displayName Flip (Radio / Checkbox) (Web)
 *
 * @class Flip
 * @private
 */
export class Flip extends NamespaceConsumer {
  /**
   * Render the actual component.
   *
   * @returns {React.DOM} The component.
   * @private
   */
  render() {
    const props = this.props;
    const grid = props.grid;

    var currentChecked = !!props.checked;
    if (props.design !== 'base' && typeof props.elements.input !== 'undefined') {
      currentChecked = props.elements.input.checked;
    }

    //
    // This forces the input element to be rendered as a correct checkbox/radio
    // element. If we're going inline, it requires a different class name.
    //
    let className = this.classNames({
      'sr-only': props.hideLabel,
      'form-control-label': !!grid.label,
      'form-check-label': !props.inline,
      'form-check-inline': props.inline,
      'disabled': props.disabled,
      'active': (props.design !== 'base' && currentChecked)
    }, {
      'has-danger': props.validates === false
    }, ['custom-control', `custom-${props.type}`]);

    if (props.design !== 'base') {
      className += ` btn ${Button.designs[props.design]}`;
    }

    className = this.classNames(
      grid.label,
      this.namespace(className)
    );

    const customIndicator = (
      <span className={ this.namespace('custom-control-indicator') }></span>
    );

    const customDescription = (
      <span className={ this.namespace('custom-control-description') }>
        { props.label }
      </span>
    );

    const label = (
      <label htmlFor={ props.id } // eslint-disable-line jsx-a11y/label-has-for
        ref={ r => { props.elements.label = r; } }
        className={ className }
        id={ 'label-' + props.id }>
        { props.input }
        { props.design === 'base' ? customIndicator : null }
        { props.design === 'base' ? customDescription : props.label }
        { props.notice }
        { props.error }
      </label>
    );

    return (
      <Fieldset proxy={ !!props.proxy }>
        { props.inline ? label : <div className={ this.namespace('form-check') }>{ label }</div> }
      </Fieldset>
    );
  }
}

/**
 * PropType validation
 *
 * @type {Object}
 * @private
 */
Flip.propTypes = {
  ...NamespaceShape,
  ...propTypes.input,

  /** The design to use for the input, see @ux/button for design options */
  design: PropTypes.oneOf(Object.keys(Button.designs)),
  /** True if the element (radio or checkbox) is checked */
  checked: PropTypes.bool
};

/**
 * Properties for Flip, design is 'base' by default.
 *
 * @enum {Object} defaultProps
 * @public
 */
Flip.defaultProps = {
  ...defaultProps.input,
  design: 'base'
};

export default withNamespace(Flip);



// WEBPACK FOOTER //
// ./node_modules/@ux/form-element/flip.js