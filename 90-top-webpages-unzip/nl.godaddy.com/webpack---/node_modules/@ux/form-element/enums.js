import PropTypes from 'prop-types';
import Button from '@ux/button';

/**
 * Map to transform types to known React Native keyboardTypes.
 *
 * @type {Object}
 * @public
 */
const types = {
  email: 'email-address',
  number: 'numeric',
  search: 'web-search',
  tel: 'phone-pad',
  url: 'url',
  textarea: 'default'
};

/**
 * Default properties used for both web and native Components.
 *
 * @type {Object}
 * @public
 */
const defaultProps = {
  input: {
    size: 'default',
    value: '',
    grid: {}
  }
};

/**
 * Allowed properties for both the wrapping element and internal input element.
 *
 * @type {Object}
 * @public
 */
const props = {
  /** This indicates that a button has to be rendered on the right side of the label which
   * you can use to hide/show things for a given element. This does require the action property
   * to also be supplied. */
  button: PropTypes.node,
  /** optional secondary form element button to be used in conjunction with button.
   * If href is provided it will be set on navigation instead of button if both are provided.
   * If any action is provided it will be used on button or ignored if no button is supplied. */
  navigation: PropTypes.node,
  elements: PropTypes.object,
  /** An error element that will be rendered */
  error: PropTypes.element,
  /** An object with classNames if you want to render the input elements in a specific grid.
   * It should have a label and input property with the classNames as value. Note: Provide
   * numbers that represent the relative flex property in stead of a className for React Native. */
  grid: PropTypes.object,
  /** Hide the label for the element */
  hideLabel: PropTypes.bool,
  /** The ID of the element, if none is provided, an ID will be generated. It is recommended to provide an ID */
  id: PropTypes.string,
  /** Indication if the element should be rendered as inline element. */
  inline: PropTypes.bool,
  /** A raw input element to be rendered */
  input: PropTypes.element,
  /** The label for the element */
  label: PropTypes.node.isRequired,
  /** Prevent the user from changing the value of the input. */
  readOnly: PropTypes.bool,
  /** Optional small text that needs to be added at the bottom of the input element. Can be used for hints. */
  notice: PropTypes.node,
  /** A change handler triggered whenever the input value changes. */
  onChange: PropTypes.func,
  /** A change handler triggered whenever the component blurs (is deselected). */
  onBlur: PropTypes.func,
  /** Disables the form element */
  disabled: PropTypes.bool,
  /** Do not render the element in a fieldset but use an empty div instead. */
  proxy: PropTypes.bool,
  /** The type of input element that needs to be rendered. If nothing is provided, the default text type is used instead. */
  type: PropTypes.string,
  /** Marks the form element as required for the form */
  required: PropTypes.oneOfType([
    PropTypes.node,
    PropTypes.bool
  ]),
  /** The value for input element. */
  value: PropTypes.oneOfType([
    PropTypes.string,
    PropTypes.number,
    PropTypes.bool
  ])
};

/**
 * Defined seperatly as the UXCore2 bundle will remove propTypes for performance,
 * FormElement._input depends on this data, this reference will keep it around.
 *
 * @type {Object}
 * @public
 */
const propTypes = {
  input: props,
  element: {
    ...props,
    /** A string to specify what, if any, autocomplete data should be used.
     * https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete */
    autoComplete: PropTypes.string,
    /** A string to use as an error message under the input element for invalid input. */
    failure: PropTypes.string,
    /** Indicates if the input is valid.  Overrides the validate function.
     * Note: Use this when the output of validate is the result of higher
     * order properties that are passed in. */
    validates: PropTypes.bool,
    /** A function that returns a boolean as indication for invalid or valid
     * state of the input element. It receives the value as first argument.
     * Note: use this when state is internal to the element, e.g. value or
     * onChange should not be passed in as property. */
    validate: PropTypes.func,
    /** A function that is triggered after the value is updated, by the user or programatically.
      *  Note: Do not use this when wrapping with a Critera.Connect component. */
    onValidation: PropTypes.func,
    /** Optional string, either large or small, that corresponds to a large/small height and font size of the input field. The default sizes will display if no string is given */
    size: PropTypes.string,
    /** Callback for validity changes. See "Validation". */
    onValidChange: PropTypes.func,
    /** The design to use for the input, see @ux/button for design options */
    design: PropTypes.oneOf(Object.keys(Button.designs)),
    /** Adds a small clickable clear button on the element to allow users to easily erase the value from the input. Note: provide keyboardShouldPersistTaps to a wrapping/parent ScrollView for React Native, otherwise the tap event will not propagate. */
    clearable: PropTypes.oneOfType([
      PropTypes.func,
      PropTypes.bool
    ])
  }
};

/**
 * React Native EventListeners can receive a direct value in stead of an Event.
 *
 * @param {SyntheticEvent} event Change event of TextInput or input element.
 * @returns {Boolean} Argument is eventlike.
 * @public
 */
function isEvent(event) {
  return typeof event === 'object' && ('nativeEvent' in event || 'target' in event);
}

/**
 * Return the value from a native or web event.
 *
 * @param {SyntheticEvent} event Change event of TextInput or input element.
 * @returns {String} Input value.
 * @public
 */
function getValue(event) {
  if (!isEvent(event)) {
    return event;
  }

  const native = event.nativeEvent || {};
  const target = event.target || {};

  return 'text' in native ? native.text : target.value;
}

/**
 * Return the type of input element
 *
 * @param {SyntheticEvent} event Change event of TextInput or input element.
 * @returns {String|Undefined} Input type.
 * @public
 */
function getType(event) {
  if (!isEvent(event)) {
    return;
  }

  return event.target.type || 'text';
}

/**
 * Get the property name that should be used to store in state.
 *
 * @param {String} type Input type.
 * @returns {String} Property name.
 * @public
 */
function getStateProperty(type) {
  //
  // For types like checkbox, radio or unknown (i.e. RN Switch) return `checked` as the preferred property
  //
  if (!type || type === 'checkbox' || type === 'radio') {
    return 'checked';
  }

  return 'value';
}

export {
  getStateProperty,
  defaultProps,
  propTypes,
  getValue,
  getType,
  types
};



// WEBPACK FOOTER //
// ./node_modules/@ux/form-element/enums.js