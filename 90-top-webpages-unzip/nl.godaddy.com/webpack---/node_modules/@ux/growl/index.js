import { NamespaceConsumer, withNamespace, NamespaceShape } from '@ux/namespace-component';
import { TransitionGroup, CSSTransition } from 'react-transition-group';
import GrowlMessage from './growl-message';
import PropTypes from 'prop-types';
import React from 'react';

/**
 * The next number for unique message id
 *
 * @type {number}
 * @private
 */
let _msgId = 0;

/**
 * The Growl component.
 *
 * @displayName Growl
 * @class Growl
 * @public
 */
class Growl extends NamespaceConsumer {
  constructor() {
    super(...arguments);

    this._fadeTimers = {};
    this.state = {
      ...this.state,
      messages: []
    };
  }

  componentDidMount() {
    if (!global.growlInstance) {
      global.growlInstance = this;
    } else {
      // eslint-disable-next-line
      try { console.error('Growl can only have one active instance.'); } catch (e) {}
    }
  }

  /**
   * React lifecycle hook invoked when component is about to unmount.
   *
   * @private
   */
  componentWillUnmount() {
    this._clearMessages();

    if (this === global.growlInstance) {
      global.growlInstance = null;
    }
  }

  /**
   * Adds new message based on provided config options.
   *
   * @param {object}  config            Configuration
   * @param {string}  config.title      Title
   * @param {string}  config.content    Description
   * @param {string}  [config.icon]     Icon
   * @param {boolean} [config.fade]     Fade
   * @param {number}  [config.fadeTime] Fade time in milliseconds
   * @private
   */
  _addMessage(config) {
    const msgProps = this._setupMessage(config);

    const messages = this.state.messages.slice(0);
    messages.push(msgProps);
    if (msgProps.fade) {
      this._startFade(msgProps.id, msgProps.fadeTime);
    }

    this.setState({
      messages
    });
  }

  /**
   * Sets up callback and props for new GrowlMessage.
   *
   * @param {object} config Message config
   * @returns {object} msgProps Props used for a GrowlMessage
   * @private
   */
  _setupMessage(config) {
    const id = `GrowlMsg_${_msgId++}`;

    const msgProps = {
      id,
      fade: true,
      onClose: () => {
        this._closeMessage(id);
      }
    };

    this.assign(msgProps, config);

    if (msgProps.fade) {
      msgProps.fadeTime = !msgProps.fadeTime ? this.props.fadeTime : msgProps.fadeTime;

      msgProps.onMouseEnter = () => {
        this._stopFade(id);
      };
      msgProps.onMouseLeave = () => {
        this._startFade(id, msgProps.fadeTime);
      };
    }
    return msgProps;
  }

  /**
   * Cancel a message fade timer.
   *
   * @param {string} msgId Message id for timer to stop
   * @private
   */
  _stopFade(msgId) {
    if (msgId in this._fadeTimers) {
      clearTimeout(this._fadeTimers[msgId]);
      delete this._fadeTimers[msgId];
    }
  }

  /**
   * Start a message fade timer.
   *
   * @param {string} msgId Message id for timer to stop
   * @param {number} fadeTime Time in milliseconds before fade
   * @private
   */
  _startFade(msgId, fadeTime) {
    this._fadeTimers[msgId] = setTimeout(() => {
      this._closeMessage(msgId);
    }, fadeTime);
  }

  /**
   * Clear all the messages.
   *
   * @private
   */
  _clearMessages() {
    this.state.messages.forEach(m => {
      this._stopFade(m.id);
    });

    this.setState({
      messages: []
    });
  }

  /**
   * Close a message.
   *
   * @param {string} msgId Id of message to close
   * @private
   */
  _closeMessage(msgId) {
    let idx = 0;
    for (idx; idx < this.state.messages.length; idx++) {
      if (this.state.messages[idx].id === msgId) break;
    }

    const messages = this.state.messages.slice(0);
    this._stopFade(msgId);

    messages.splice(idx, 1);

    this.setState({
      messages
    });
  }

  /**
   * Get the message elements.
   *
   * @returns {Array} GrowlMessage elements
   * @private
   */
  get _messageElements() {
    const elements = [];

    this.state.messages.forEach((m) => {
      const element = (
        <GrowlMessage
          onClose={ this._closeMessage.bind(this) }
          key={ m.id }
          { ...m }
          onCloseButtonKeyDown={ this._handleMessageKeyDown.bind(this) } />
      );
      elements.push(
        <CSSTransition
          key={ m.id }
          classNames={{
            enter: this.namespace('ux-growl-item-enter'),
            enterActive: this.namespace('ux-growl-item-enter-active'),
            exit: this.namespace('ux-growl-item-exit'),
            exitActive: this.namespace('ux-growl-item-exit-active')
          }}
          timeout={{ enter: 500, exit: 500 }}>
          { element }
        </CSSTransition>
      );
    });

    return elements;
  }

  /**
   * Handle keyboard events for escape key on the close all button.
   *
   * @param {Event} event Browser event.
   * @private
   */
  _handleMessageKeyDown(event) {
    const messageEvent = event.target;
    const growlMessage = messageEvent.parentNode.parentNode;

    if (event.type === 'keydown' && event.key === 'Escape') {
      this._closeMessage(growlMessage.id);
    }
  }

  /**
   * Handle keyboard events for escape key on the close all button.
   *
   * @param {Event} event Browser event.
   * @private
   */
  _handleKeyDown(event) {
    const key = event.key;

    if (this.growlMain) {
      this.closeAllButton = this.growlMain.querySelector(this.namespace('.ux-growl-clear-show'));
    }

    if (event.type === 'keydown' && key === 'Escape' && this.closeAllButton === event.currentTarget) {
      this._clearMessages();
    }
  }

  /**
   * Renders the component.
   *
   * @returns {ReactElement} Rendered Growl element.
   * @private
   */
  render() {
    const { messages = [] } = this.state || {};
    if (!messages.length) return false;

    return (
      <div aria-live='polite' className={ this.namespace('ux-growl') } ref={ r => { this.growlMain = r; } }>
        <button
          type='button'
          aria-label='Close all'
          className={ this.namespace('ux-growl-clear', messages.length >= 2 ? 'ux-growl-clear-show' : '') }
          onClick={ this._clearMessages.bind(this) }
          onKeyDown={ this._handleKeyDown.bind(this) }>
          { this.props.closeLabel }
        </button>
        <div className={ this.namespace('ux-growl-messages') } >
          <TransitionGroup>
            { this._messageElements }
          </TransitionGroup>
        </div>
      </div>
    );
  }
}

/**
 * Adds new message based on provided config options.
 *
 * @param {object}  config            Configuration
 * @param {string}  config.title      Title
 * @param {string}  config.content    Description
 * @param {string}  [config.icon]     Icon
 * @param {boolean} [config.fade]     Fade
 * @param {number}  [config.fadeTime] Fade time in milliseconds
 * @public
 */
function addGrowlMessage(config) {
  if (!global.growlInstance) {
    // eslint-disable-next-line
    try { console.error('No Growl instance.'); } catch (e) {}
  } else {
    global.growlInstance._addMessage(config);
  }
}

/**
 * Adds new message based on provided config options.
 *
 * @param {object}  config            Configuration
 * @param {string}  config.title      Title
 * @param {string}  config.content    Description
 * @param {string}  [config.icon]     Icon
 * @param {boolean} [config.fade]     Fade
 * @param {number}  [config.fadeTime] Fade time in milliseconds
 * @public
 */
Growl.addGrowlMessage = Growl.addMessage = addGrowlMessage;

/**
 * PropType validation.
 *
 * @type {Object}
 * @private
 */
Growl.propTypes = {
  ...NamespaceShape,

  fadeTime: PropTypes.number.isRequired,
  closeLabel: PropTypes.node
};

/**
 * PropType defaults.
 *
 * @type {Object}
 * @private
 */
Growl.defaultProps = {
  fadeTime: 3000,
  closeLabel: '[ close all ]'
};

const namespaced = withNamespace(Growl);

/**
 * Check if Growl has an active instance.
 *
 * @returns {boolean} If an instance exists
 * @public
 */
Object.defineProperty(namespaced, 'hasInstance', {
  get() {
    return global.growlInstance !== null;
  }
});

export {
  namespaced as default,
  addGrowlMessage,
  Growl
};



// WEBPACK FOOTER //
// ./node_modules/@ux/growl/index.js