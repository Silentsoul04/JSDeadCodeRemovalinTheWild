import React from 'react';
import PropTypes from 'prop-types';
import Component, { breakpoints } from '@ux/component';

const blockBreakpoints = ['mobile', 'phablet', 'tablet'];

/**
 * UXCore based ButtonSet. A ButtonSet will always start with
 * an initial state that does not set the `ux-btn-block` class.
 *
 * @displayName Button Set
 * @class ButtonSet
 * @public
 */
export default class ButtonSet extends Component {
  constructor() {
    super();

    //
    // Set blockBreakpoints on this instance so that
    // it is accessible externally.
    //
    this.blockBreakpoints = blockBreakpoints.slice();
    this.state.block = false;
  }

  /**
   * If the breakpoint is supported, checkHeights,
   * otherwise, set block as false.
   *
   * @public
   */
  checkBreakpoint() {
    if (~this.blockBreakpoints.indexOf(breakpoints.breakpoint)) {
      this.checkHeights();
      return;
    }

    this._setBlockState(false);
  }

  /**
   * If set is taller than shortest button,
   * set block as true
   *
   * @public
   */
  checkHeights() {
    const btnSetHeight = this.buttonSet.clientHeight;

    //
    // Find the height of each button & put it in an array.
    // Remark: not using `Array.from` to support IE.
    //
    const btns = [];
    const children = this.buttonSet.children;
    for (let i = 0; i < children.length; i++) {
      btns.push(children[i]);
    }

    const btnHeights = btns.map(function (child) {
      const styles = window.getComputedStyle(child);
      return child.offsetHeight
        + parseInt(styles.marginTop, 10)
        + parseInt(styles.marginBottom, 10);
    });
    this._setBlockState(btnSetHeight > Math.min(...btnHeights));
  }

  /**
   * Only setState if result doesn't match current state
   *
   * @param {boolean} target If true, sets 'ux-btn-block' class.
   * @private
   */
  _setBlockState(target) {
    if (this.state.blockÂ !== target) {
      this.setState({ block: target });
    }
  }

  /**
   * Once the ButtonSet has been rendered, listen to the
   * appropriate changes in Window size
   *
   * @private
   */
  componentDidMount() {
    //
    // List breakpoints that require listening
    //
    this.breakpoint('mobile', 'phablet', 'tablet', 'desktop', 'large');
    this.checkBreakpoint();
  }

  /**
   * When a ButtonSet is rerendered, check to see if the blocking
   * state needs to be updated.
   *
   * @private
   */
  componentDidUpdate() {
    this.checkBreakpoint();
  }

  /**
   * Remove the eventListeners of breakpoints.
   *
   * @private
   */
  componentWillUnmount() {
    this.breakup();
  }

  /**
   * Render the ButtonSet Component.
   *
   * @returns {ReactElement} ButtonSet element.
   * @private
   */
  render() {
    const classNames = this.classNames('ux-btn-set', {
      'ux-btn-block': this.state.block,
      'ux-btn-split': this.props.split
    }, this.props.className);

    return (
      <div className={ classNames } ref={ bSet => { this.buttonSet = bSet; } } role='group'>
        {
          React.Children.map(this.props.children, child => {
            if (!child) { return null; }
            return React.cloneElement(child, {
              className: this.classNames('ux-btn-set-item', child.props.className)
            });
          })
        }
      </div>
    );
  }
}

/**
 * Optional properties: split defines if the ButtonSet's
 * children should split to multiple lines or not.
 *
 * @enum {Object} expected types of properties.
 * @public
 */
ButtonSet.propTypes = {
  /** Classes to set on the element */
  className: PropTypes.string,
  /** Defines whether child elements too wide to fit on screen should drop down to the next line*/
  split: PropTypes.bool,
  /** Child elements to be included in the Button Set*/
  children: PropTypes.node
};



// WEBPACK FOOTER //
// ./node_modules/@ux/button-set/index.js