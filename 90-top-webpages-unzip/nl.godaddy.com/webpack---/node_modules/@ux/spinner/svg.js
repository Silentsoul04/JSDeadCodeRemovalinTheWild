import vars from './definitions';
import platform from 'platform-specific';
import { Svg, Circle, Path } from 'svgs';
import React, { Component } from 'react';
import { tween } from '@godaddy/shifty/tweenable';
import Fulfilling from 'fulfilling';
import PropTypes from 'prop-types';
import design from './design';
import ms from 'millisecond';


/**
 * SVG based Spinner
 *
 * @displayName SVG Spinner
 * @class Spinner
 * @public
 */
export default class Spinner extends Component {
  constructor() {
    super(...arguments);

    this.duration = ms(vars.uxSpinnerDuration);
    this.mounted = false;
    this.state = {
      start: 0,
      end: 0
    };
  }

  /**
   * They key frames of the animation that we iterate over.
   *
   * @returns {Array} Animation specification
   * @private
   */
  keyframes() {
    return [
      {
        duration: 25,
        start: 0,
        end: 90
      }, {
        duration: 25,
        start: 90,
        end: 270
      }, {
        duration: 25,
        start: 270,
        end: 360
      }, {
        duration: 25,
        start: 360,
        end: 360
      }
    ];
  }

  /**
   * Start the animation when the component is mounted.
   *
   * @returns {void}
   * @private
   */
  componentDidMount() {
    this.mounted = true;
    this.animate();
  }

  /**
   * Tricky part here, we could unmount mid-animation frame so we need to set
   * a flag to instruct our animation sequence to stop iterating through our
   * animation key frames and the setState calls
   *
   * @private
   */
  componentWillUnmount() {
    this.mounted = false;
  }

  /**
   * Representation of a single animation cycle
   *
   * @returns {void}
   * @private
   */
  animate() {
    if (!this.mounted) return;

    const self = this;
    const frames = this.keyframes();
    const duration = this.duration;
    const initial = {
      start: 0,
      end: 0
    };

    /**
     * Every step of the animation is an setState for React so we can animate
     * during the render step
     *
     * @param {Object} progress Progress of the animation
     * @private
     */
    const setState = (progress) => {
      if (!this.mounted) return;

      this.setState(progress);
    };

    (function next() {
      const frame = frames.shift();

      if (!self.mounted) return;
      if (!frame) return self.animate();

      tween({
        promise: Fulfilling,

        from: initial,
        to: { start: frame.start, end: frame.end },
        duration: duration / 100 * ms(frame.duration),
        step: setState
      }).then(() => {
        initial.start = frame.start;
        initial.end = frame.end;

        next();
      });
    }());
  }

  /**
   * Calculate the correct coordinates for the arc.
   *
   * @param {Number} x Center x
   * @param {Number} y Center y
   * @param {Number} radius Radius
   * @param {Number} angle Angle in degrees
   * @returns {Object} x/y positions
   * @private
   */
  polarToCartesian(x, y, radius, angle) {
    const angledRad = (angle - 90) * Math.PI / 180.0;

    return {
      x: x + (radius * Math.cos(angledRad)),
      y: y + (radius * Math.sin(angledRad))
    };
  }

  /**
   * Generate an arc based on given start x/y and start/end angle
   *
   * @param {Number} center position of the center
   * @param {Number} radius Radius of the circle
   * @param {Number} startDeg Starting degree of the arc
   * @param {Number} endDeg Ending degree of the arc
   * @returns {String} The generated path
   * @private
   */
  arc(center, radius, startDeg, endDeg) {
    const start = this.polarToCartesian(center, center, radius, endDeg);
    const end = this.polarToCartesian(center, center, radius, startDeg);
    const largeArcFlag = endDeg - startDeg <= 180 ? '0' : '1';

    return [
      'M', start.x, start.y,
      'A', radius, radius, 0, largeArcFlag, 0, end.x, end.y
    ].join(' ');
  }

  /**
   * Renders the component.
   *
   * @returns {ReactElement} Rendered Spinner element.
   * @private
   */
  render() {
    const { inline, shade, size } = this.props;
    const styles = design(size, shade);
    const { width, strokeWidth } = styles.size;
    const center = width / 2;
    const radius = center - strokeWidth;
    const d = this.arc(center, radius, this.state.start, this.state.end);
    const style = {};

    //
    // Notable difference in react-native and browser svg is that browsers
    // render the svg in inline by default while svg's on react-native are block
    // level because layout needs is controlled with flex-boxes.
    //
    if (platform.type !== 'react-native' && inline) {
      style.display = 'block';
    }

    return (
      <Svg width={ width } height={ width } viewBox={ `0 0 ${width} ${width}` } style={ style }>
        <Circle { ...styles.circle } r={ radius } cx={ center } cy={ center } />
        <Path { ...styles.path } d={ d } />
      </Svg>
    );
  }
}

Spinner.propTypes = {
  /** Determines whether the spinner will be displayed inline or not */
  inline: PropTypes.bool,
  /** The label for the spinner */
  label: PropTypes.node,
  /** Defines the shade of the spinner (light, primary, or dark) */
  shade: PropTypes.string.isRequired,
  /** Defines the size of the spinner (sm, md, or lg) */
  size: PropTypes.string.isRequired
};

/**
 * Default properties.
 *
 * @type {Object}
 * @private
 */
Spinner.defaultProps = {
  shade: 'primary',     // Default color.
  size: 'md'            // Default size.
};



// WEBPACK FOOTER //
// ./node_modules/@ux/spinner/svg.js