import React from 'react';
import PropTypes from 'prop-types';
import Close from './tooltip-close';
import Title from './tooltip-title';
import { NamespaceConsumer, withNamespace, NamespaceShape } from '@ux/namespace-component';

/**
 * Render and position the tooltip content.
 *
 * @class TooltipContent
 * @private
 */
export class TooltipContent extends NamespaceConsumer {
  constructor() {
    super(...arguments);
    this.state = {
      anchor: {
        height: 0,
        width: 0,
        top: 0,
        y: 0,
        x: 0
      }
    };
    this.wrapper = React.createRef();
    this.element = React.createRef();
  }

  /**
   * After the initial render the tooltip will need to be re-rendered for
   * correct positioning in the DOM.
   *
   * @private
   */
  componentDidMount() {
    this.on('resize', this.update);
    this.recalculateAnchor();
    if (!this.props.persistent) {
      setTimeout(() => {
        this.outsideHandler = this.outside('click', (e, handler) => {
          this.off('click', handler);
          this.props.close(e);
        }, this.wrapper.current);
      }, 0);
    }
  }

  /**
   * Remove the attached click event listener.
   *
   * @private
   */
  componentWillUnmount() {
    this.off('resize', this.update);
    this.off('click', this.outsideHandler);
  }

  /**
   * Provide the position and dimensions of the anchor element each time the
   * component is about to update the DOM.
   *
   * @private
   */
  componentDidUpdate() {
    this.recalculateAnchor();
  }

  /**
   * Force an update of the component, usually required to update the position.
   *
   * @private
   */
  update() {
    this.forceUpdate();
  }

  anchorsDiffer(prevAnchor, newAnchor) {
    return JSON.stringify(prevAnchor) !== JSON.stringify(newAnchor);
  }

  recalculateAnchor() {
    const { anchor } = this.props;
    const offset = this.offset(anchor);
    const bounding = anchor.getBoundingClientRect();
    const recalculatedAnchor = {
      height: bounding.height,
      width: bounding.width,
      top: bounding.top,
      y: offset.top,
      x: offset.left
    };

    const prevAnchor = this.state.anchor;
    if (this.anchorsDiffer(prevAnchor, recalculatedAnchor)) {
      this.setState({
        anchor: recalculatedAnchor
      });
    }
  }

  /**
   * Get top and left distances of the tooltip. Also return if the tooltip needs
   * to be rendered above or below the anchor.
   *
   * @returns {Array} positional values.
   * @private
   */
  get position() { // eslint-disable-line max-statements
    let left;

    //
    // Deliberately return to top left corner here so the tooltip will get the
    // maximum space to render. Having it elsewhere on the page might cause
    // the message to render with a different width causing errors in the
    // calculation afterwards.
    //
    if (!this.element.current) {
      return [{
        left: 0,
        top: 0
      }];
    }

    const { anchor } = this.state;
    const viewportWidth = window.innerWidth;
    const tooltip = this.element.current.getBoundingClientRect();
    const height = tooltip.height;
    const width = tooltip.width;
    const above = height < anchor.top;

    //
    // Determine x position on the tooltip, attempt to place it centered above
    // the anchor at first.
    //
    left = Math.floor(anchor.x + (anchor.width / 2) - (width / 2));

    const delta = above ? height : -anchor.height;
    const overflow = left + width - viewportWidth;

    const arrowMargin = {
      marginLeft: this.arrowMarginLeft
    };

    //
    // Move the tooltip further to the left if there is not enough space in
    // the viewport to the right side of the anchor. Also move the arrow the
    //
    if (overflow > 0) {
      arrowMargin.marginLeft += overflow;
      left -= overflow;
    }

    //
    // Do not allow for positioning left < 0, respect boundaries of the viewport.
    // Instead move the arrow with margin-left above the anchor.
    //
    if (left < 0) {
      arrowMargin.marginLeft += left;
      left = 0;
    }

    return [{
      top: Math.floor(anchor.y - delta),
      left: left
    }, arrowMargin, above];
  }

  /**
   * Render Tooltip content and store references to the wrapping div and the arrow.
   * Both are required for positional calculations and updates.
   *
   * @returns {ReactElement} div element with Tooltip content.
   * @private
   */
  render() {
    const props = this.props;
    const [style, arrowMargin, above] = this.position;
    const classNames = this.namespace(this.classNames([props.className, 'tooltip', 'show', {
      'bs-tooltip-bottom': above,
      'bs-tooltip-top': !above
    }]));

    //
    // Get and store the arrow's original margin-left
    //
    const arrowMarginRef = r => {
      if (!this.arrowMarginLeft && r) {
        this.arrowMarginLeft = parseInt(window.getComputedStyle(r).getPropertyValue('margin-left'), 10) || 0;
      }
    };

    return (
      <div className={ this.namespace('spaced-group') } ref={ this.wrapper }>
        <div role='tooltip' ref={ this.element } className={ classNames } style={ style }
          onMouseEnter={ props.onMouseEnter } onMouseLeave={ props.onMouseLeave }>
          <div className={ this.namespace('tooltip-arrow') } ref={ arrowMarginRef } style={ arrowMargin }></div>
          <div className={ this.namespace('tooltip-inner') }>
            { props.hideClose || <Close close={ props.dismiss } className={ this.namespace('close') }/> }
            <span role='status' aria-live='assertive'>
              { props.title && <Title className={ this.namespace('tooltip-title') }>{ props.title }</Title> }
              { props.message }
            </span>
          </div>
        </div>
      </div>
    );
  }
}

/**
 * Define required and types of properties.
 *
 * @enum {Object} propTypes
 * @private
 */
TooltipContent.propTypes = {
  ...NamespaceShape,

  anchor: PropTypes.object,
  message: PropTypes.node,
  title: PropTypes.node,
  close: PropTypes.func.isRequired,
  onMouseEnter: PropTypes.func,
  onMouseLeave: PropTypes.func,
  hideClose: PropTypes.bool,
  persistent: PropTypes.bool,
  dismiss: PropTypes.func
};

export default withNamespace(TooltipContent);



// WEBPACK FOOTER //
// ./node_modules/@ux/tooltip/tooltip-content.js