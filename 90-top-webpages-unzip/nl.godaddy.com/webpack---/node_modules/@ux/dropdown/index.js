import { withNamespace, NamespaceShape } from '@ux/namespace-component';
import validateComponents from 'react-component-validator';
import React, { Fragment } from 'react';
import Component, { withEventDistContext } from '@ux/component';
import PropTypes from 'prop-types';
import ReactDOM from 'react-dom';
import Base, { types } from './dropdown';

//
// Import all child components.
//
import DropdownControl from './dropdown-control';
import DropdownDivider from './dropdown-divider';
import DropdownHeader from './dropdown-header';
import DropdownMenu, { alignmentTypes, autoAlignments, menuAlignmentPropType } from './dropdown-menu';
import DropdownItem from './dropdown-item';

/**
 * Track of the current selected value with a hidden input element. Allowing
 * simple POST requests of forms.
 *
 * @class DropdownValue
 * @private
 */
class DropdownValue extends Component {
  render() {
    const allowedTypes = ['select', 'tripledot', 'custom'];
    if (!~allowedTypes.indexOf(this.props.type)) {
      return null;
    }

    return <input { ...this.props } type='hidden' readOnly />;
  }
}

/**
 * PropType validation
 *
 * @enum {Object} propTypes
 * @public
 */
DropdownValue.propTypes = {
  /** Type of dropdown */
  type: PropTypes.oneOf(types)
};

/**
 * Display a Dropdown that works standalone button, as select or multiselect.
 *
 * @displayName Dropdown (Web)
 * @class Dropdown
 * @extends React.Component
 * @public
 */
class DropdownComponent extends Base {
  constructor() {
    super(...arguments);
    this.hideHandle = null;
    this.selectItem = this.selectItem.bind(this);
    this.toggleBackground = this.toggleBackground.bind(this);
  }

  /**
   * Hide the dropdown if clicks are outside the dropdown itself, and select default selected
   *
   * @private
   */
  componentDidMount() {
    /* eslint react/no-find-dom-node: 0 */
    this.hideHandle = this.outside('click', this.hide, ReactDOM.findDOMNode(this.element));
  }

  /**
   * Remove the attached click event listener.
   *
   * @private
   */
  componentWillUnmount() {
    this.off('click', this.hideHandle || this.hide);
    this.hideHandle = null;
  }

  /**
   * Scroll to the active item.
   *
   * @param {object} prevProps - Previous props before update
   * @param {object} prevState - Previous state before update
   * @private
   */
  componentDidUpdate(prevProps, prevState) {
    super.componentDidUpdate(prevProps);
    const activeItem = this.element && this.element.querySelector('.active');
    const { open } = this.state;

    if (open && open !== prevState.open) {
      const { ...bounds } = this.getElementBounds();
      let newState = this.getHorizontalRender(bounds);
      newState = { ...newState, ...this.getVerticalRender(bounds) };

      if (Object.keys(newState).length > 0) {
        this.setState(newState);
      }
    }

    if (open && activeItem) {
      this.scrollIntoViewIfNeeded(activeItem);
    }
  }

  /**
   * Fetches all element bounds to necessary calculations of display
   * @private
   * @returns {object} element bounds
   */
  getElementBounds() {
    // Viewport Bounds
    const viewportBounds = {
      x: window.pageXOffset,
      y: window.pageYOffset,
      width: window.innerWidth,
      height: window.innerHeight
    };

    // Main Dropdown Element
    const elementBounds = this.element && this.element.getBoundingClientRect();

    // Dropdown Menu Element
    const menuBounds = this.menuElement && this.menuElement.wrapper && this.menuElement.wrapper.getBoundingClientRect();

    // Label Element (if one exists)
    const labelBounds = this.componentLabel && this.componentLabel.getBoundingClientRect();

    // Menu Item Element
    const menuItemRef = this.menuElement &&
      this.menuElement.dropdownItem &&
      this.menuElement.dropdownItem.getRef &&
      this.menuElement.dropdownItem.getRef();

    const menuItemBounds = menuItemRef && menuItemRef.getBoundingClientRect();

    // Get Dropdown Item height
    const itemHeight = menuItemBounds && menuItemBounds.height || 45;

    return { viewportBounds, elementBounds, menuBounds, labelBounds, itemHeight };
  }

  /**
   * Compute vertical spacing for menu and determine whether to show above or below the dropdown control.
   *
   * @param {object} bounds - Object containing element bounds calculated in getElementBounds()
   * @returns {obbject} Temporary updated state object
   * @private
   */
  getVerticalRender(bounds) {
    // Temporary object to prevent multiple state updates
    const newState = {};
    const { viewportBounds, elementBounds, menuBounds, labelBounds, itemHeight } = bounds;

    const hasLabel = labelBounds && labelBounds.height > 0;
    if (this.state.hasLabel !== hasLabel) {
      newState.hasLabel = hasLabel;
    }

    if (elementBounds) {
      // Determine to show the menu above or below
      const menuBottomBound = elementBounds.top + elementBounds.height + menuBounds.height - (itemHeight / 2);
      const overflowBelow = viewportBounds.height < menuBottomBound;
      const spaceAbove = elementBounds.top - menuBounds.height > 0;
      const showUp = overflowBelow && spaceAbove;

      if (this.state.showUp !== showUp) {
        newState.showUp = showUp;
      }
    }

    return newState;
  }

  /**
   * Compute horizontal spacing for menu and determine whether to show aligned left or right to the dropdown control.
   *
   * @param {object} bounds - Object containing menu bounds calculated in getElementBounds()
   * @returns {object} Temporary updated state object
   * @private
   */
  getHorizontalRender(bounds) {
    const newState = {};
    if (autoAlignments[this.props.menuAlignment] || !this.props.menuAlignment) {
      const { elementBounds, menuBounds, viewportBounds } = bounds;
      if (elementBounds && menuBounds) {
        const left = elementBounds.right + viewportBounds.x - window.document.documentElement.clientLeft - menuBounds.width;
        const right = elementBounds.left + viewportBounds.x - window.document.documentElement.clientLeft + menuBounds.width;

        let alignmentOverride;
        // The element needs to be right aligned if it's too close or outside the bounds of the viewport
        // and it it small enough to fit inside a viewport, if it's too big we'll leave the default
        if (viewportBounds.width - right < 10 && menuBounds.width < viewportBounds.width) {
          alignmentOverride = alignmentTypes.right;
        } else if (left < 10) {
          // Only force different than the default if the leftmost bounds is outside or too close to the left side of the viewport
          alignmentOverride = alignmentTypes.left;
        }

        // Compare with current state
        if (this.state.alignmentOverride !== alignmentOverride) {
          newState.alignmentOverride = alignmentOverride;
        }
      }
    }
    return newState;
  }

  toggleBackground(isOpen) {
    if (this.props.enableFullscreen) {
      if (isOpen) {
        document.body.classList.add('dropdown-open');
      } else {
        document.body.classList.remove('dropdown-open');
      }
    }

    const { open, selected } = this.state;
    const { required } = this.props;
    if (!open && selected.length === 0 && required) {
      this.setState({ error: true });
    } else if (selected.length > 0 && required) {
      this.setState({ error: false });
    }
  }

  /**
   * Extract DropdownControl from all children.
   *
   * @param {React.Element[]} children - React elements.
   * @returns {React.Element} DropdownControl with children.
   * @private
   */
  control(children) {
    const { placeholder, type, disabled, toggleIcon, content, size, namespace } = this.props;
    const dropdownControl = children.filter(
      child => child.type === DropdownControl
    )[0] || <DropdownControl />;
    return React.cloneElement(dropdownControl, {
      children: dropdownControl.props.children || this.getSelectedItem(children) || placeholder,
      hasPlaceholder: !!(!dropdownControl.props.children && !this.getSelectedItem(children) && placeholder),
      key: 'control',
      toggle: this.show,
      type,
      onKeyDown: this.keyDown.bind(this),
      disabled,
      toggleIcon,
      content,
      size,
      namespace
    });
  }

  /**
   * Returns all children that are not of type DropdownControl.
   *
   * @param {React.Element[]} children - React elements.
   * @returns {React.Element[]} React elements.
   * @private
   */
  items(children) {
    return children.filter(child => {
      return child.type !== DropdownControl
        && child.type !== DropdownHeader
        && child.type !== DropdownDivider;
    });
  }

  /**
   * Render Dropdown component.
   *
   * @returns {React.Element} div element with Dropdown.
   * @private
   */
  render() {
    const { keyboardSelectionIndex, open, showUp, hasLabel, error } = this.state;
    const props = {
      ...this.props,
      keyboardSelectionIndex,
      onChange: this.selectItem,
      onToggle: this.toggle
    };
    const select = ~props.type.indexOf('select');
    const tripledot = props.type === 'tripledot';
    // Use the alignment if set, otherwise tripledot prefersRight by default,
    // Everything else should left align
    props.menuAlignment = props.menuAlignment ||
      (tripledot
        ? alignmentTypes.preferRight
        : alignmentTypes.left);
    const children = React.Children.toArray(props.children);
    const disabled = props.disabled;
    const title = (props.label || props.required) && (
      <Fragment>
        { props.label && <label key='label' ref={ r => { this.componentLabel = r; } }>{ props.label }</label> }
        { props.required && <span className={ props.namespace('text-danger') }>*</span> }
      </Fragment>
    );
    const className = this.classNames(props.className,
      { 'ux-select-dropdown': select },
      props.namespace(this.classNames('dropdown', {
        'triple-dot-dropdown': tripledot,
        'dropdown-disabled': disabled,
        open,
        'menu-up': showUp,
        'has-label': hasLabel,
        'full-screen': this.props.enableFullscreen,
        error
      }))
    );

    const openMenu = open ? 'true' : 'false';
    const ElementType = props.elementType;

    return (
      <ElementType
        ref={ r => this.element = r }
        id={ props.id }
        className={ className }
        role='menubar' aria-expanded={ openMenu } aria-haspopup={ 'true' }>
        { title }
        { this.control(children) }
        <DropdownValue key='value'
          type={ props.type }
          value={ props.value }
          name={ props.name } />
        <DropdownMenu key='menu'
          { ...props }
          ref={ r => { this.menuElement = r; } }
          toggle={ this.toggle }
          selected={ this.selected }
          alignmentOverride={ this.state.alignmentOverride }
          keyboardSelectionIndex={ this.state.keyboardSelectionIndex }>
          {children.filter(child => child.type !== DropdownControl)}
        </DropdownMenu>
        { error && props.required &&
          <span className={ this.props.namespace('form-error') } role='alert'>
            { props.required }
          </span>
        }
      </ElementType>
    );
  }
}

/**
 * Default to button dropdown.
 *
 * @enum {Object} defaultProps
 * @public
 */
DropdownComponent.defaultProps = {
  ...Base.defaultProps,
  type: 'button',
  elementType: 'div',
  enableFullscreen: true
};

/**
 * Define properties and validate the type of children that are passed
 * to the Dropdown.
 *
 * @enum {Object} propTypes
 * @public
 */
DropdownComponent.propTypes = {
  /** Common dropdown props */
  ...Base.propTypes,
  /** Namespace Consumer props */
  ...NamespaceShape,
  /** ID attribute for the dropdown container */
  id: PropTypes.string,
  /** Type of the dropdown */
  type: PropTypes.oneOf(types),
  /** Wrapper element type for the dropdown */
  elementType: PropTypes.string,
  /** Alignment of the dropdown menu */
  alignment: menuAlignmentPropType,
  /** Boolean whether the dropdown menu is fullscreen (mobile only) */
  enableFullscreen: PropTypes.bool,
  /** Children components of a dropdown. Can be a DropdownControl,
   *  DropdownDivider, DropdownHeader, or DropdownItem */
  children: validateComponents([
    DropdownControl,
    DropdownItem,
    DropdownDivider,
    DropdownHeader
  ]),
  /** Error message to show if the dropdown is required */
  required: PropTypes.oneOfType([
    PropTypes.node,
    PropTypes.bool
  ])
};

//
// Attach childs to the main Component for availability without ES6 imports.
//
DropdownComponent.DropdownControl = DropdownControl;
DropdownComponent.DropdownDivider = DropdownDivider;
DropdownComponent.DropdownHeader = DropdownHeader;
DropdownComponent.DropdownItem = DropdownItem;

//
// Export the Class and related children.
//
const Dropdown = withEventDistContext(withNamespace(DropdownComponent));

export {
  Dropdown as default,
  DropdownControl,
  DropdownDivider,
  DropdownHeader,
  DropdownItem
};



// WEBPACK FOOTER //
// ./node_modules/@ux/dropdown/index.js