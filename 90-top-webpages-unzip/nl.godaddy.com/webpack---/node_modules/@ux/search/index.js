import React from 'react';
import PropTypes from 'prop-types';
import DefaultItem from './default-item';
import Component from '@ux/component';
import Button from '@ux/button';
import Icon from '@ux/icon';
import rip from 'rip-out';
import FormElement from '@ux/form-element';
import escapeRegExp from 'lodash.escaperegexp';
import debounce from 'debounce';

const has = Object.prototype.hasOwnProperty;

/**
 * Define propTypes to prevent removal for PROD builds.
 *
 * @type {Object}
 * @private
 */
const propTypes = {
  /** AutoComplete setting for the form element, only applicable if no data is present */
  autoComplete: PropTypes.string,
  /** Button will be included */
  button: PropTypes.bool,
  /** Text to include on button */
  buttonText: PropTypes.node,
  /** Classes applied */
  className: PropTypes.string,
  /** When true, a clear button will be shown when there's content in the searchbox, when Func, the higher order component wrapping searchBox should manage state.value to clear content. */
  clearable: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),
  /** The current filtered subset of props.data being displayed for any filter */
  data: PropTypes.array,
  /** Debounce your inputs for fast react */
  debounce: PropTypes.number,
  /** This flag determines if the results should be shown when the list has been truncated using the maxResults property. When true the flyout will remain hidden until the number of filtered results is less than equal to maxResults */
  hideTruncatedResults: PropTypes.bool,
  /** The active filter of the instance. This will only change after any potential debouncing has occurred.*/
  filter: PropTypes.oneOfType([PropTypes.object, PropTypes.func]),
  /** This indicates that a button has to be rendered on the right side of the searchbox */
  icon: PropTypes.bool,
  /** A string that corresponds to a uxicon class name that should be displayed on the searchbox */
  iconClass: PropTypes.string,
  /** Unique id to pass to the FormElement Component */
  id: PropTypes.string,
  /** A max number of results to return. */
  maxResults: PropTypes.number,
  /** A change handler triggered whenever the input value changes. */
  onChange: PropTypes.func,
  /** Handles onchange event for the searchbox. Sets up states and decides filtered data. */
  onFilter: PropTypes.func,
  /** Callback function that is sent to each rendered item. It is triggered on-select of the item or if `onSearch` is not provided and search is triggered. */
  onSelect: PropTypes.func,
  /** An event handler triggered when the search is triggered. If not provided, `onSelect` is called. */
  onSearch: PropTypes.func,
  /** Placeholder text to be displayed in the searchbox */
  placeholder: PropTypes.string,
  /** If set, will be invoked to render each item in props.data. */
  renderItem: PropTypes.func,
  /** Allow the search to be cleared externally */
  reset: PropTypes.bool,
  /** Provide some results when query returns empty */
  resultsOnEmpty: PropTypes.bool,
  /** Size of the component */
  size: PropTypes.string,
  /** If data is an object, the value of this property determines the name of the property that holds the string to filter through */
  text: PropTypes.string,
  /** Function called on each piece of data to transform it into a string. */
  transform: PropTypes.func,
  /** The value for input. */
  value: PropTypes.string
};

/**
 * Search control creates an input control that filters a provided list of objects.
 *
 * @displayName Search
 * @class Search
 * @public
 */
class Search extends Component {
  constructor() {
    super(...arguments);

    this.onElementValueChange = this.onElementValueChange.bind(this);
    this.onFilterChange = this.onFilterChange.bind(this);
    this.onKeyDown = this.onKeyDown.bind(this);
    this.onSelect = this.onSelect.bind(this);
    this.onSelected = this.onSelected.bind(this);
    this.builtInFilter = this.builtInFilter.bind(this);
    this.builtInTransform = this.builtInTransform.bind(this);
    this.clear = this.clear.bind(this);
    this.onFocus = this.onFocus.bind(this);
    this.onBlur = this.onBlur.bind(this);
    this.setStateAndClose = this.setStateAndClose.bind(this);
    this.preventBlur = this.preventBlur.bind(this);

    if (this.props.debounce) {
      this.onFilterChange = debounce(this.onFilterChange, this.props.debounce);
    }

    // initial state
    this.state = this.state || {};
    this.state = {
      ...this.state,
      data: [],
      filter: '',
      keyboardSelectionIndex: -1,
      open: false,
      preventBlur: false,
      suggestion: '',
      suggestionEnabled: this.shouldEnableSuggestion(this.props),
      value: this.props.value
    };
  }

  /**
   * @returns {function} Transformation function that can be used to transform a datum to a string.
   */
  get transform() {
    return typeof this.props.transform === 'function'
      ? this.props.transform
      : this.builtInTransform;
  }

  /**
   * Apply filtering to data.
   *
   * @param {string} dataArray the data array to filter. It can be an array of string or an array of objects.
   * @param {string} value the string to filter data by. Uses state.filter by default
   * @returns {array} an array containing data that was not filtered out
   * @private
   */
  applyFilter(dataArray, value) {
    if (!value && !this.props.resultsOnEmpty) { return []; }

    const { transform } = this;

    const customFilter = typeof this.props.filter === 'function';
    const { maxResults, hideTruncatedResults } = this.props;
    const results = [];
    let numResults = 0;

    dataArray.every(data => {
      const includeItem = customFilter
        ? this.props.filter(data, value)
        : this.builtInFilter(transform(data), value);

      if (includeItem) {
        results.push(data);
        numResults++;
      }
      return hideTruncatedResults
        ? numResults <= maxResults // allow overrun by one to detect exceeding maxResults
        : numResults < maxResults;
    });

    return (hideTruncatedResults && numResults > maxResults)
      ? []
      : results;
  }

  /**
   * Transform a datum into a string that can be used for rendering and filtering.
   *
   * @param {string|Object} datum The datum to transform.
   * @returns {string} A string representation of the datum, or undefined.
   * @private
   */
  builtInTransform(datum) {
    if (typeof datum === 'string') return datum;
    const key = this.props.text || null;

    if (has.call(datum, key)) {
      return datum[key].toString();
    }
  }

  /**
   * Performs the filter operation on `props.filter` taking into account the default
   * states (startsWith, endsWith, and includes).
   *
   * @param   {string} datum Item within `props.data` to potentially include in results
   * @param   {string} value Current search value
   * @returns {boolean} Value indicating if `datum` should be included in results.
   */
  builtInFilter(datum, value) {
    if (!datum) return false;

    const lowerDatum = datum.toLowerCase();
    const lowerValue = (value || '').toLowerCase();
    let { startsWith, endsWith, includes } = this.props.filter || {};
    if (!startsWith && !endsWith && !includes) {
      startsWith = true;
      endsWith = true;
    }

    const firstIndex = lowerDatum.indexOf(lowerValue);
    if ((startsWith && firstIndex === 0)
      || (includes && ~firstIndex)) {
      return true;
    }

    const lastIndex = lowerDatum.lastIndexOf(lowerValue);
    if (endsWith && lastIndex !== -1 && lastIndex === lowerDatum.length - lowerValue.length) {
      return true;
    }

    return false;
  }

  /**
   * clears the control.
   *
   * @private
   */
  clear() {
    this.filterBy('');
  }

  /**
   * Returns suggestion based on passed in data and filter.
   *
   * @param {string} data the data array to suggest from
   * @param {string} value the string to filter data by. Uses state.filter by default
   * @returns {string} suggested text
   * @private
   */
  getSuggestion(data, value) {
    value = value || this.state.filter;
    if (this.state.keyboardSelectionIndex >= 0) {
      const item = data[this.state.keyboardSelectionIndex];
      return item ? this.transform(item) : '';
    }

    const transformedData = data.map(this.transform);
    const escapedValue = escapeRegExp(value);
    const reg = new RegExp('\\b' + escapedValue + '\\w*\\b', 'gi');
    const lowerValue = value.toLowerCase();

    for (let i = 0; i < transformedData.length; i++) {
      if (!transformedData[i] || transformedData[i].toLowerCase() === lowerValue) continue;
      const matches = transformedData[i].match(reg);

      if (matches) return transformedData[i];
    }
    return '';
  }

  /**
   * Sets up states and decides filtered data.
   *
   * @param {string} value the string to filter data by. Defaults to state.filter
   * @returns {Array} filtered data
   * @private
   */
  filterBy(value) {
    let filteredData = [];
    value = (value || value === '') ? value : this.state.filter;
    if (value || this.props.resultsOnEmpty) {
      filteredData = this.applyFilter(this.props.data, value.toLowerCase());
    }

    const suggestion = this.state.suggestionEnabled
      ? this.getSuggestion(filteredData, value)
      : '';

    this.setState({
      suggestion: suggestion,
      open: filteredData.length > 0,
      data: filteredData,
      filter: value,
      value
    });

    this.props.onFilter(value, filteredData);
    return filteredData;
  }

  /**
   * Prevents the component from triggering onBlur, ie: when you click on a list
   * item.
   *
   * @private
   */
  preventBlur() {
    this.setState({ preventBlur: true });
  }

  /**
   * Invokes `setState` with the `extraState` provided along with the
   * necessary state to close this instance. Reduces duplication of these
   * properties throughout the code.
   *
   * @param {Object} extraState Additional state information to set with close.
   */
  setStateAndClose(extraState) {
    this.setState({
      ...extraState,
      open: false,
      preventBlur: false,
      suggestion: this.state.suggestion
    });
  }

  /**
   * Checks if suggestions should be enabled.
   *
   * @param {Object} props Properties (this.props or nextProps) to determine if suggestion should be enabled.
   * @returns {bool} Returns true only if the filter is startsWith exclusively, otherwise false
   */
  shouldEnableSuggestion(props) {
    const { filter } = props;
    return filter
      && typeof filter === 'object'
      && filter.startsWith
      && !filter.includes
      && !filter.endsWith;
  }

  /**
   * Handles the arrows keyboard action.
   *
   * @param {object} e Event object sent from the browser
   * @private
   */
  onArrowUpDown(e) {
    if (!this.state.open) { return; }

    let { keyboardSelectionIndex } = this.state;
    const delta = e.key === 'ArrowDown' ? 1 : -1;

    if (keyboardSelectionIndex === -1 && e.key === 'ArrowUp') {
      keyboardSelectionIndex = 0;
    }

    keyboardSelectionIndex += delta;

    // Wraparound of keyboardSelectionIndex to be within [0..data.length-1] range
    const dataLength =  this.state.data.length;
    keyboardSelectionIndex = (keyboardSelectionIndex + dataLength) % dataLength;

    this.setState({
      keyboardSelectionIndex,
      suggestion: keyboardSelectionIndex >= 0
        ? this.transform(this.state.data[keyboardSelectionIndex])
        : this.state.suggestion
    });

    if (this.listContainer && this.listContainer.childNodes[keyboardSelectionIndex]) {
      this.scrollIntoViewIfNeeded(this.listContainer.childNodes[keyboardSelectionIndex]);
    }

    e.preventDefault();
  }

  /**
   * A change handler triggered whenever the component blurs (is deselected).
   *
   * @private
   */
  onBlur() {
    setTimeout(() => {
      if (!this.state.preventBlur) {
        this.setStateAndClose({
          suggestion: '',
          keyboardSelectionIndex: -1
        });
      }
    }, 1);
  }

  /**
   * Handles onchange event for the searchbox. Gets the value from the event and calls
   * the actual (possibly debounced) handler onFilterChange()
   *
   * @param {object} ev the event object sent from the browser
   * @private
   */
  onElementValueChange(ev) {
    const value = ev.target.value;
    this.setState({ value });
    this.onFilterChange(value);
  }

  /**
   * Handles onchange event for the searchbox. Sets up states and decides filtered data.
   *
   * @param {string} value new input field value
   * @private
   */
  onFilterChange(value) {
    const filteredData = this.filterBy(value);
    this.setState({ keyboardSelectionIndex: -1 });
    this.props.onChange(value, filteredData);
  }

  /**
   * Handles focus for the searchbox.
   *
   * @private
   */
  onFocus() {
    this.filterBy(this.state.value);
    this.setState({
      open: this.props.resultsOnEmpty || this.state.data.length > 0,
      preventBlur: false
    });
  }

  /**
   * Fill the textbox when the right arrow is clicked and a suggestion exists.
   *
   * @param {object} e Event object sent from the browser
   * @private
   */
  onKeyDown(e) {
    if (!this.formElement) return;
    const suggestion = this.state.suggestion;

    switch (e.key) {

      case 'ArrowRight':
        if (!this.state.suggestionEnabled || !this.state.suggestion) return;
        this.setState({
          suggestion: '',
          value: suggestion
        });
        this.filterBy(suggestion);
        break;

      case 'Enter': {
        const { keyboardSelectionIndex } = this.state;
        if (this.state.keyboardSelectionIndex >= 0) {
          const item = this.state.data[keyboardSelectionIndex];
          const value = this.transform(item);
          this.setStateAndClose({
            value,
            suggestion: ''
          });

          if (this.props.onSelect) {
            this.props.onSelect(value);
          }
        } else {
          this.onSelected();
        }

        break;
      }

      case 'ArrowDown':
      case 'ArrowUp':
        this.onArrowUpDown(e);
        break;

      default:
        break;
    }
  }

  /**
   * Callback function that is sent to each rendered item. It is triggered
   * on-select of the item.
   *
   * @param {string} value the string that was selected
   * @param {bool} isSearch determines whether to call the `onSearch` or `onSelect` callback
   * @private
   */
  onSelect(value, isSearch = false) {
    this.filterBy(value);
    this.setState({
      open: false,
      suggestion: ''
    });

    if (isSearch && this.props.onSearch) {
      this.props.onSearch(value);
    } else if (this.props.onSelect) {
      this.props.onSelect(value);
    }
  }

  /**
   * Called when the button is clicked. This action is equivalent to a selection.
   *
   * @private
   */
  onSelected() {
    this.onSelect(this.state.value, true);
  }

  /**
    * When props change check to see if suggestionEnabled needs to be changed.
    *
    * @param {Object} prevProps All props being set on this instance.
    * @private
    */
  componentDidUpdate(prevProps) {
    const nextState = {};
    let filter;

    if (this.props.value !== prevProps.value) {
      filter = this.props.value;
    }

    if (prevProps.data !== this.props.data) {
      nextState.data = this.props.data;
    }

    if (prevProps.filter !== this.props.filter) {
      nextState.suggestionEnabled = this.shouldEnableSuggestion(this.props);
    }

    if (this.props.reset) {
      filter = '';
    }

    if (Object.keys(nextState).length) {
      this.setState(nextState, () => {
        if (nextState.data || this.props.reset) {
          this.filterBy(filter);
        }
      });
    } else if (this.props.reset && this.state.value) {
      this.filterBy(filter);
    }
  }

  /**
    * Only update on change to props if data, filter, open or reset changed.
    *
    * @param  {Object} nextProps All props being set on this instance.
    * @param  {Object} nextState All state properties for upcoming setState
    * @returns {bool} Returns true if data, filter, open or reset changed
    */
  shouldComponentUpdate(nextProps, nextState) {
    return nextProps.reset
      || this.props.data !== nextProps.data
      || this.props.filter !== nextProps.filter
      || this.state.data !== nextState.data
      || this.state.value !== nextState.value
      || this.state.open !== nextState.open
      || (nextState.open && this.state.keyboardSelectionIndex !== nextState.keyboardSelectionIndex);
  }

  /**
   * Render a button when buttontext or button is defined.
   *
   * @returns {JSX} Button Searchbox button component
   * @private
   */
  renderButton() {
    if (this.props.buttonText || this.props.button) {
      const buttonText = this.props.buttonText || 'Search';
      return (
        <Button
          className={ this.classNames('btn-purchase', { 'btn-filled': this.props.size === 'small' }) }
          type='submit'
          onClick={ this.onSelected }
          size={ this.props.size }
        >
          { buttonText }
        </Button>
      );
    }
  }

  /**
   * Decide and render which icon to render in the right side of the control.
   *
   * @returns {XML} Icon Icon component that's displayed on the right of this control
   * @private
   */
  renderIcon() {
    if (this.props.iconClass || this.props.icon) {
      const icon = this.props.iconClass;
      const iconProps = {};

      return (
        <Button type='submit'
          className={ this.classNames('btn-purchase', 'btn-icon', { 'btn-filled': this.props.size === 'small' }) }
          onClick={ this.onSelected }
          size={ this.props.size }
          { ...iconProps }>
          <Icon name={ this.classNames(icon) } />
        </Button>
      );
    }
  }

  /**
   * Render the list items based.
   *
   * @returns {JSX} the list component
   */
  renderList() {
    if (this.state.open) {
      const { keyboardSelectionIndex } = this.state;
      const { transform } = this;

      return (
        <div className={ this.classNames('ux-search-list-container') }
          onMouseDown={ this.preventBlur }
          ref={ (c) => { this.listContainer = c; } }>
          {
            this.state.data.map((item, index) => {
              if (typeof this.props.renderItem === 'function') {
                return this.props.renderItem(transform(item), index, this.onSelect, item, index === keyboardSelectionIndex);
              }

              return (
                <DefaultItem
                  key={ index }
                  item={ transform(item) }
                  onSelect={ this.onSelect }
                  selected={ index === keyboardSelectionIndex } />
              );
            })
          }
        </div>
      );
    }
  }

  /**
   * Get the suggestion div.
   *
   * @returns {JSX} the lookahead component
   * @private
   */
  renderLookAhead() {
    const filter = this.state.filter || '';
    const suggestion = this.state.suggestion;

    if (!suggestion) return '';

    const remainder = suggestion.substring(filter.length);
    return (
      <div
        onMouseDown={ this.preventBlur }
        onClick={ () => { if (this.formElement) this.formElement.elements.input.focus(); } }
        className={ this.classNames('ux-search-lookahead') }>
        <span style={{ visibility: 'hidden' }}>{ filter }</span>{ remainder }
      </div>
    );
  }

  render() {
    const { placeholder, clearable, className, ...props } = this.props;
    const { suggestion, suggestionEnabled, value, open } = this.state;
    const unknownProps = rip(props, ...Object.keys(propTypes));
    const classNames = this.classNames('input-group', 'ux-search', className, { open });

    const placeholderText = !suggestion.length || !suggestionEnabled
      ? placeholder
      : '';

    const autoComplete = props.autoComplete || (props.data && props.data.length ? 'off' : 'on');

    return (
      <div className={ classNames } { ...unknownProps }  >
        <FormElement
          label=''
          id={ props.id }
          value={ value }
          name='searchText'
          autoComplete={ autoComplete }
          ref={ c => { this.formElement = c; } }
          className={ 'form-control' }
          onChange={ this.onElementValueChange }
          onKeyDown={ this.onKeyDown }
          onFocus={ this.onFocus }
          onBlur={ this.onBlur }
          placeholder={ placeholderText }
          size={ this.props.size }
          clearable={ typeof clearable === 'function' ? clearable : this.clear } />

        { suggestionEnabled && this.renderLookAhead() }
        { this.renderList() }

        <span className='input-group-btn'>
          { this.renderButton() }
          { this.renderIcon() }
        </span>
      </div>
    );
  }
}

/**
 * Property validation.
 *
 * @type {Object}
 * @public
 */
Search.propTypes = propTypes;

/**
 * Default properties of the control
 *
 * @type {Object}
 * @public
 */
Search.defaultProps = {
  button: false,
  buttonText: '',
  className: '',
  clearable: false,
  data: [],
  debounce: 0,
  hideTruncatedResults: false,
  icon: true,
  iconClass: 'magnifying-glass',
  filter: { startsWith: true },
  maxResults: Infinity,
  onChange: function () {},
  onFilter: function () {},
  onSelect: function () {},
  placeholder: '',
  reset: false,
  renderItem: null,
  resultsOnEmpty: false,
  size: 'default',
  text: '',
  value: ''
};

export {
  Search as default,
  DefaultItem
};



// WEBPACK FOOTER //
// ./node_modules/@ux/search/index.js