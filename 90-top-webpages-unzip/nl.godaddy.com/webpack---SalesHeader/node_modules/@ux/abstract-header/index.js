import { URL } from '@ux/util';
import Cart from '@ux/cart';
import { events, traffic2, Customer, shopperDataLoader } from '@ux/header-util';
import { NamespaceConsumer } from '@ux/namespace-component';

/**
 * Super class for @ux/{sales,application,utility, pass}-headers. This module
 * should not be used directly, but rather extended in order to centralize a
 * lot of the shared business logic among the header.
 */
export default class AbstractHeader extends NamespaceConsumer {
  constructor(props) {
    super(...arguments);

    this.events = events;
    this.state = { cartItems: 0 };

    // Expose a method on ux.eldorado.header to updateCart for passing down
    // to UtilityBar's Cart class as props.items
    this.updateCart = Cart.update.bind(this);

    traffic2.init({ type: props.traffic, beacon: true });
    this.customer = this.createCustomer();
  }

  /**
   * @typedef {typeof Customer} Customer
   */
  /**
   * Returns a valid Customer instance using the props associated
   * with this instance. Derived Headers (e.g. ApplicationHeader, SalesHeader, etc.)
   * should override this method to define custom cookie behavior.
   *
   * @returns {Customer} Customer instance from @ux/header-util.
   */
  createCustomer() {
    return new Customer(this.props);
  }

  /**
   * Returns a value indicating if this instance will display no components
   * which themselves would require authentication (and thus a GUI call).
   * @param  {Object} components This has two distinct upstream locations:
   *   - `@ux/sales-header`:  props.components.utilityBar`.
   *   - `@ux/utility-header`: props.components (read from preset.components).
   * @returns {Boolean} Returns true if no auth data is required.
   */
  isUnauthenticated(components) {
    components = components || {};
    return !(components.accountDelegation ||
      components.notifications ||
      components.accountTray ||
      components.cart ||
      components.contactTray); // Federated partner info requires GUI call
  }

  getWindowLocation() {
    return window.location.href;
  }

  /**
   * Read in cookie Data for OrderConfirmation
   */
  getOrderDetails() {
    const orderId = new URL(this.getWindowLocation(), true).query.orderId;
    if (orderId) {
      this.setState({ orderId });
    }
  }

  /**
   * Returns a shallow copy of any state set by the GUI call in
   * this.getCustomerDetails() for ease-of-access.
   * @returns {Object} All state we set from our GUI call for the customer.
   */
  getCustomerState() {
    const { state = {} } = this;

    return {
      displayName: state.displayName,
      federatedPartner: state.federatedPartner,
      items: state.items,
      isInGoCohort: state.isInGoCohort,
      isPro: state.isPro,
      loggedIn: state.loggedIn,
      name: state.name,
      proshopper: state.proshopper,
      rewardPoints: state.rewardPoints,
      shopperId: state.shopperId,
      username: state.username,
      vip: state.vip
    };
  }

  /**
   * Get customer details.
   *
   * @param {Function} [done] Completion callback.
   * @api private
   */
  getCustomerDetails(done) {
    // Start with data from the existing cookie
    this.customer.updateFromCookie();

    if (typeof done !== 'function') {
      done = () => {};
    }

    if (this.state.unauthenticated) {
      // No components visible that use customer data, so we can skip the GUI call
      shopperDataLoader.configureOnly({
        url: this.props.urls.gui.href,
        privateLabelId: this.props.privateLabelId,
        shopperId: this.customer.shopperId
      });

      done();
      return;
    }

    // Next, try to fetch fresh data from the server
    this.customer.fetch({
      gui: this.props.urls.gui.href
    }, error => {
      if (error) {
        const doneWithError = () => {
          events.emit('error', error);
          done(error);
        };

        // We still have some data from the cookie, so just fall back to that.
        // We use the presence of a shopper ID as a weak proxy to login state.
        // This won't actually unlock any real actions -- just tells the header to act
        // like the user is logged in. If they are not really logged in, they'll get
        // sent to SSO when they try to do anything that requires login.
        if (this.customer.shopperId) {
          this.setState({
            displayName: this.customer.displayName(true),
            federatedPartner: this.customer.get('federatedPartner'),
            name: this.customer.displayName(),
            shopperId: this.customer.shopperId,
            loggedIn: true
          }, doneWithError);
        } else {
          doneWithError();
        }

        return;
      }

      const proUser = this.customer.get('proshopper');
      const proshopper = proUser && proUser.status === 1;
      const rewardPoints = proshopper ? proUser.rewardPoints : null;
      const tmsData = this.customer.get('tms');
      const isInGoCohort = tmsData && tmsData.some(split => {
        return split.Name === 'wsb_vnext';
      });

      this.setState({
        displayName: this.customer.displayName(true),
        federatedPartner: this.customer.get('federatedPartner'),
        items: this.customer.cart,
        isInGoCohort,
        isPro: proshopper,
        loggedIn: this.customer.loggedIn,
        name: this.customer.displayName(),
        proshopper,
        rewardPoints,
        shopperId: this.customer.shopperId,
        username: this.customer.get('loginName'),
        vip: this.customer.vip
      }, done);
    }, false);
  }


  /**
   * Query Traffic for the variant result of a given experiment and pipe the result to React state
   * @param {Object} opt Options
   * @param {String} opt.expId The experiment ID
   * @param {Object} [opt.attributes] An optional object to to pass along attributes
   * for Traffic/Split.io to calculate the variant ID. If none pass {}
   * @param {String} opt.stateFieldName The name of the React state field to store the result in
   * @param {StateValueTransformerFn} [opt.stateValueTransformer] An optional function to transform a variant ID into a state
   *   value. If omitted, the state field will contain the variant ID itself
   * @example <caption>Sets the state value to a boolean based on if the variant ID is 'B'</caption>
   * pipeExpVariantToState({'my_experiment', { 'market-id': 'en-US' }, 'myExperiment', variantId => variantId === 'B'}, done)
   * @param {Function} [done] Callback function
   *
   * @callback StateValueTransformerFn
   * @param {String} variantId The variant identifier to transform
   *
   */
  pipeExpVariantToState({ expId, attributes = {}, stateFieldName,  stateValueTransformer = (variantId => variantId) }, done) {
    // During server-rendering, we don't want to access `window`
    if (typeof window === 'undefined') return;

    const expDataLayer = window._expDataLayer = window._expDataLayer || [];
    const pipeVariantToState = variantId => {
      this.setState({
        [stateFieldName]: stateValueTransformer(variantId)
      }, done);
    };

    expDataLayer.push({
      schema: 'get_variant_for_experiment',
      version: 'v1',
      data: {
        experiment_id: expId,
        callback: pipeVariantToState,
        attributes: attributes
      }
    });
  }

  /**
   * Notify listeners the header is mounted and expose the instance.
   */
  componentDidMount() {
    this.events.emit('mount', 'header', this);
    this.events.emit('mount:header', this);

    this.getCustomerDetails();
    this.getOrderDetails();
  }

  /**
   * Notify header was updated.
   */
  componentDidUpdate() {
    events.emit('update:header', this);
  }

  /**
   * Needed to prevent enzyme from complaining about
   * missing inst.render method
   * @returns {undefined}
   */
  render() {
    return null;
  }
}
