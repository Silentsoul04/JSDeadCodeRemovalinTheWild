import React from 'react';
import PropTypes from 'prop-types';
import { NamespaceConsumer, NamespaceShape, withNamespace } from '@ux/namespace-component';
import { IntlProvider, FormattedMessage } from 'react-intl';
import * as bowser from 'bowser';
import { cookie } from '@ux/util';
import { browsers, breakpoints } from './enums';

/**
 * A Banner to be displayed if your browser is too old.
 * @type {BrowserDeprecationBanner}
 */
class BrowserDeprecationBanner extends NamespaceConsumer {
  constructor() {
    super(...arguments);

    this.dismiss = this.dismiss.bind(this);

    let info;
    if (typeof navigator !== 'object') {
      // pretend to be something we support on server side
      // so we don't briefly flash the banner on supported Browsers
      info = { name: 'Chrome', version: '99999999999', mac: false };
    } else {
      info = bowser.detect(navigator.userAgent);
    }

    const { name, version, mac } = info;

    this.state = {
      mac: !!mac,
      name,
      version,
      dismissed: false
    };
  }

  /**
   * Handle a user clicking the X to permanently dismiss this
   * banner. The "permanence" lasts as long as cookie lasts.
   */
  dismiss() {
    cookie.set('_dismissedBDF', 'true');
    this.setState({
      dismissed: true
    });
  }

  /**
   * set breakpoint behavior
   */
  componentDidMount() {
    this.breakpoint(...breakpoints);
  }

  /**
   * Whether or not we recognize this browser. If we do not recognize it,
   * we should not make a decision on whether or not to show this banner.
   * @param {String} browser that is being recognized
   * @returns {String} name of browser that is recognized, otherwise ''
   */
  recognizedBrowser(browser) {
    const { supportMatrix } = this.props;
    const matched = Object
      .keys(supportMatrix)
      .filter(b => browser.match(b));

    return matched.length > 0 ? matched[0] : '';
  }

  /**
   * Whether the whitelist provided contains the current useragent
   * @returns {Boolean} true if the useragent whitelist contains the current browser
   */
  get userAgentIsWhitelisted() {
    const { whitelistedUserAgents } = this.props;
    if (typeof navigator === 'object' && navigator.userAgent && whitelistedUserAgents) {
      return whitelistedUserAgents.some(ua => !!navigator.userAgent.match(ua));
    }
    return false;
  }

  /**
   * Whether the blacklist provided contains the browser in question
   * @param {String} browserName that is being tested
   * @param {String} browserVersion of the browser to check
   * @returns {Boolean} true if the blacklist contains the browser and version specified
   */
  browserIsBlacklisted(browserName, browserVersion) {
    const { blacklistedBrowsers } = this.props;
    return blacklistedBrowsers.some(({ browser, version }) => browser === browserName && version === browserVersion);
  }

  /**
   * Whether the version is at or below the supported matrix threshold
   * @param {String} browserName that is being tested
   * @param {String} browserVersion of the browser to check
   * @returns {Boolean} true if the browser is at or below the threshold
   */
  isUnsupportedBrowser(browserName, browserVersion) {
    const { supportMatrix } = this.props;
    let unsupportedBrowser = false;

    if (supportMatrix && browserName) {
      const newestWithBanner = supportMatrix[browserName][0];
      if (newestWithBanner !== null) {
        unsupportedBrowser = parseFloat(browserVersion) > parseFloat(newestWithBanner);
      } else {
        unsupportedBrowser = true;
      }
    }
    return unsupportedBrowser;
  }

  /**
   * Determines if the banner should NOT be rendered
   * @returns {Boolean} Whether or not the banner should be shown for the current browser
   */
  shouldNotShowbanner() {
    if (this.userAgentIsWhitelisted) {
      return true;
    }

    const { name, version, dismissed } = this.state;
    const { supportMatrix, disableDeprecationBanner } = this.props;

    if (disableDeprecationBanner || dismissed || !supportMatrix || (cookie.get && cookie.get('_dismissedBDF'))) {
      return true;
    }

    const browser = this.recognizedBrowser(name);
    if (!browser || typeof version === 'undefined') {
      return true;
    }

    if (this.browserIsBlacklisted(browser, parseFloat(version))) {
      return false;
    }

    return this.isUnsupportedBrowser(browser, parseFloat(version));
  }

  /**
   * Given that the current browser is supported, render the docs
   * @returns {[ReactElement]} 3 <span> tags that contain recommendations to download
   * Firefox, Chrome, or (Safari/Edge) depending on their OS
   */
  renderBrowsers() {
    const { mac, name } = this.state;
    const { messages } = this.props;

    const filtered = browsers
      .filter(b => b !== (mac ? 'Edge' : 'Safari'))
      .sort(a => a !== name);
    const get = 'Shared:BrowserDeprecationBanner:GetBrowser';
    const update = 'Shared:BrowserDeprecationBanner:UpdateBrowser';

    return filtered.map(browser => (
      <span className={ this.namespace('browser-info') } key={ `name-${browser}` }>
        <a href={ messages[`Shared:BrowserDeprecationBanner:Download${browser}`] }>
          <span className={ this.namespace('browser-text') }>
            <FormattedMessage id={ browser === name ? update : get } values={{ browser }}/>
          </span>
          <span className={ this.namespace('browser-icon', browser.toLowerCase()) }>
            <img alt={ browser } src={ `https://img1.wsimg.com/wrhs-assets/browser-deprecation-warning/${browser}.png` } />
          </span>
        </a>
      </span>
    ));
  }

  render() {
    if (this.shouldNotShowbanner()) {
      return null;
    }

    const props = this.props;

    return (
      <IntlProvider locale={ props.market } messages={ props.messages }>
        <header role='banner'>
          <div className={ this.namespace('row', 'browser-deprecation-banner') }>
            <button tabIndex='0' onClick={ this.dismiss }>
              <span className='uxicon uxicon-x'></span>
            </button>
            <div className='col-xs-12 col-md-5'>
              <p className={ this.namespace('ageism') }>
                <FormattedMessage id='Shared:BrowserDeprecationBanner:HoldingUsBack' />
              </p>
              <p className={ this.namespace('update') }>
                <FormattedMessage id='Shared:BrowserDeprecationBanner:LatestVersion' />
              </p>
            </div>
            <div className={ this.namespace('col-xs-12', 'col-md-7', 'browsers-container') }>
              { this.renderBrowsers() }
            </div>
          </div>
        </header>
      </IntlProvider>
    );
  }
}

/**
 * Allowed browser deprecation values.
 *
 * @enum {Object}
 * @api public
 */
BrowserDeprecationBanner.propTypes = {
  ...NamespaceShape,
  messages: PropTypes.object.isRequired,
  supportMatrix: PropTypes.object.isRequired,
  whitelistedUserAgents: PropTypes.array,
  disableDeprecationBanner: PropTypes.bool,
  blacklistedBrowsers: PropTypes.arrayOf(PropTypes.shape({
    browser: PropTypes.string,
    version: PropTypes.number
  }))
};

BrowserDeprecationBanner.defaultProps = {
  disableDeprecationBanner: false,
  blacklistedBrowsers: []
};

export default withNamespace(BrowserDeprecationBanner);
