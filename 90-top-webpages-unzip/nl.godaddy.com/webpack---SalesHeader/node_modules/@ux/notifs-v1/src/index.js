import { NamespaceProvider, NamespaceConsumer, NamespaceShape, withNamespace } from '@ux/namespace-component';
import { URL, cookie } from '@ux/util';
import React from 'react';
import PropTypes from 'prop-types';

import trfq from 'react-trfq';

import shapes from './shapes';
import * as cache from './cache';
import NotificationBadge from './badge';
import NotificationsList from './list';

const trfqEventDesc = 'click';

export class Notifications extends NamespaceConsumer {
  constructor(props) {
    super(props);

    this.openList = this.openList.bind(this);
    this.closeList = this.closeList.bind(this);
    this.toggleList = this.toggleList.bind(this);
    this.generateEid = this.generateEid.bind(this);

    // A reference to the trigger function that wraps the click handler. We keep a reference
    // to it so we can unbind the event later, when the component unmounts.
    this.clickEventTrigger = null;
    this._isMounted = true;
  }

  dismiss() {
    if (!this._isMounted) return;

    this.setState({ dismissed: true });

    cookie.set('notificationsDismissed', true, {
      domain: '.' + new URL().domain(1)
    });
  }

  componentWillUnmount() {
    this.off('click', this.clickEventTrigger);
    this._isMounted = false;
  }

  openList(event) {
    event.preventDefault();

    const { isLoaded } = this.state;
    if (!isLoaded || !this._isMounted) {
      return;
    }

    this.setState({ isOpen: true }, function badgeOpened() {
      this.bellClickLogImpressions();
      this.dismiss();
    }.bind(this));
  }

  closeList() {
    const { isLoaded } = this.state;
    if (!isLoaded || !this._isMounted) {
      return;
    }

    this.setState({ isOpen: false });
  }

  toggleList(e) {
    const { isOpen } = this.state;
    const { openList, closeList } = this;
    isOpen ? closeList(e) : openList(e);
  }

  generateEid(suffix) {
    const manifest = this.props.manifest.toLowerCase();
    return `uxp.hyd.${manifest}.${suffix}`;
  }

  bellClickLogImpressions() {
    let eid = this.generateEid('notifications.unseencounterbell.click');
    const { notifications, dismissed } = this.state;
    if (notifications && notifications.length > 0) {
      if (dismissed) {
        eid = this.generateEid('notifications.seencounterbell.click');
      }
      trfq.logEvent(eid, trfqEventDesc);
      notifications.forEach(function (n) {
        trfq.logImpression(n.eids.impression);
      });
    } else {
      eid = this.generateEid('notifications.emptybell.click');
      trfq.logEvent(eid, trfqEventDesc);
    }
  }

  notesLoadLogImpressions() {
    let eid = this.generateEid('notifications.emptybell.impression');
    const { notifications, dismissed } = this.state;
    if (notifications && notifications.length > 0) {
      if (dismissed) {
        eid = this.generateEid('notifications.seencounterbell.impression');
      } else {
        eid = this.generateEid('notifications.unseencounterbell.impression');
      }
    }
    trfq.logImpression(eid);
  }

  componentDidMount() {
    const props = this.props;
    const { api, privateLabelId, shopperId, market } = props;
    const dismissed = cookie.get('notificationsDismissed') === 'true';

    this.clickEventTrigger = this.outside('click', this.closeList, this.domNode);

    cache.get(
      props.cache.href, this.namespace('notification-cache'),
      api, privateLabelId, shopperId, market,
      function notifRequestSuccess(response) {
        if (!this._isMounted) return;
        const { badge, notifications } = response;
        this.setState({ isLoaded: true, isOpen: false, badge, notifications, dismissed });
        this.notesLoadLogImpressions();
      }.bind(this),
      function notifRequestFailed() {
        if (!this._isMounted) return;
        this.setState({ failed: true, isLoaded: true, dismissed });
      }.bind(this)
    );
  }

  render() {
    const { closeList, toggleList } = this;
    const { className, sso, messages, tooltip } = this.props;
    const { failed, isOpen, dismissed, badge, notifications } = this.state;

    const refHandler = function refHandler(domNode) {
      this.domNode = domNode;
    }.bind(this);

    const classes = this.classNames(
      className, this.namespace('notifications', 'dropdown'),
      {
        [this.namespace('open')]: isOpen,
        [this.namespace('has-notifications')]: notifications && notifications.length > 0 && sso
      }
    );

    // eslint-disable-next-line  jsx-a11y/click-events-have-key-events, jsx-a11y/no-static-element-interactions
    return <div ref={ refHandler } className={ classes } onClick={ toggleList }>
      <NotificationBadge messages={ messages } dismissed={ dismissed } { ...badge } tooltip={ tooltip } />
      { isOpen
        ? <NotificationsList
          failed={ failed }
          notifications={ notifications }
          messages={ messages }
          sso={ sso }
          closeList={ closeList } />
        : null
      }
    </div>;
  }
}

Notifications.propTypes = {
  ...NamespaceShape,
  manifest: PropTypes.string.isRequired,
  cache: PropTypes.shape({
    href: PropTypes.string.isRequired
  }).isRequired,
  api: PropTypes.shape({
    href: PropTypes.string.isRequired
  }).isRequired,
  sso: shapes.sso.isRequired,
  privateLabelId: PropTypes.number,
  shopperId: PropTypes.string,
  market: PropTypes.string.isRequired,
  messages: shapes.messages.isRequired,
  className: PropTypes.string,
  tooltip: PropTypes.string
};

export default withNamespace(Notifications);

export function Container(props) {
  const { namespace, ...rest } = props;
  return <NamespaceProvider namespace={ namespace }>
    <Notifications { ...rest } />
  </NamespaceProvider>;
}

Container.propTypes = {
  namespace: PropTypes.string
};
