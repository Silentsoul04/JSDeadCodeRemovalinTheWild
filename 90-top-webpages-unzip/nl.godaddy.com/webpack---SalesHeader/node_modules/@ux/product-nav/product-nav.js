import { IntlProvider, FormattedHTMLMessage, FormattedMessage } from 'react-intl';
import { NamespaceConsumer, NamespaceShape, withNamespace } from '@ux/namespace-component';
import { URL } from '@ux/util';
import { default as AllProductsNav } from '@ux/mobile-nav';
import React from 'react';
import PropTypes from 'prop-types';
import Link from '@ux/link';
import { breakpoints } from './enums';
import {
  urlMatches,
  linkListBuilder,
  trayMenusBuilder,
  defaultComponents
} from './utils';

/**
 * Render and expose the Product navigation as a Component.
 *
 * @param {Object} props Properties
 * @returns {ReactElement} Namespaced Product Nav.
 * @public
 */
export class ProductNavComponent extends NamespaceConsumer {
  constructor(props) {
    super(...arguments);

    this.components = this.mergeComponents(props);
    this.state = {
      ...this.state,
      ...this.nextStateFromProps(props)
    };
  }

  /**
   * Update component settings based on incoming props
   *
   * @param {Object} nextProps Incoming new props
   * @private
   */
  componentWillReceiveProps(nextProps) {
    this.components = this.mergeComponents(nextProps);
  }

  /**
   * Merge components from props into default components
   *
   * @param {Object} props Props
   * @param {Object} props.components Component settings passed in from props
   * @returns {Object} Merged component settings
   * @private
   */
  mergeComponents(props) {
    return {
      ...defaultComponents,
      ...props.components
    };
  }

  /**
   * Initialize current href and active heading.
   *
   * @param {Object} props received
   * @returns {Object} Object containing currentHref and activeHeading
   * @private
   */
  nextStateFromProps(props) {
    let { currentHref, activeCaption } = props;

    if (this.isBrowser) {
      activeCaption = window.sessionStorage.getItem('activeCaption');
      currentHref = document.location.href;
    }

    if (currentHref) {
      const currentUrl = new URL(currentHref, true);
      const qsCurrentHref = currentUrl.query.currentPage;
      if (qsCurrentHref) {
        currentHref = qsCurrentHref;
      } else {
        currentHref = currentUrl.href;
      }
    }

    const active = this.findParent({
      url: currentHref,
      caption: activeCaption,
      items: props.secondaryNav,
      firstMatch: false
    });

    return {
      currentHref,
      activeHeading: active && active.activeHeading
    };
  }

  /**
   * Perform a recursive search through the navs data structure looking for
   * the specific URL and caption. When found return the parent object that contains it
   * so we can get all of it's sibling links.
   *
   * @param {Object} opts Options for findParent
   * @param {String} opts.url The url to match against
   * @param {String} opts.caption The caption or id to check against
   * @param {Object[]} opts.items The child items for which to find the parent
   * @param {Object} opts.firstMatch The parent object containing the first matching url
   * @param {Object} [opts.parent] The parent returned from the previous call to findParent
   *
   * @returns {Object} Parent object containing url
   * @private
   */
  findParent(opts) { // eslint-disable-line complexity, max-statements
    const { url, caption, items, parent } = opts;
    let { firstMatch } = opts;

    if (!url || !items) {
      return;
    }

    if (Array.isArray(items)) {
      for (let i = 0, len = items.length; i < len; i++) {
        const result = this.findParent({
          url,
          caption,
          items: items[i],
          firstMatch,
          parent
        });
        if (result) {
          if (result.isFullMatch) {
            return result;
          }
          if (i === len - 1) {
            return result;
          } else if (!firstMatch) {
            firstMatch = result.activeHeading;
          }
        }
      }
    } else {
      if (items.href && urlMatches(url, items.href, true)) {
        // save the first url match in case there is no caption match
        if (!firstMatch) {
          firstMatch = parent || items;
        }
        if (!caption || caption === items.caption || caption === items.id) {
          return {
            isFullMatch: true,
            activeHeading: parent || items
          };
        }
      }

      if (items.children) {
        return this.findParent({
          url,
          caption,
          items: items.children,
          firstMatch,
          parent: items
        });
      }

      if (firstMatch) {
        return {
          isFullMatch: false,
          activeHeading: firstMatch
        };
      }
    }
  }

  /**
   * Build the primary navigation links from the passed in nav data structure.
   *
   * @returns {Array} nav items
   * @private
   */
  buildMainNav() {
    const { props } = this;
    const navs = [];
    props.navigation.forEach(item => {
      if (item.title || item.caption) {
        if (item.children || item.href) {
          if (!item.onlyMobile) {
            navs.push(item);
          }
        }
      }
    });

    return trayMenusBuilder(navs, {
      urlArgs: props.urlArgs,
      className: this.namespace('topnav-item'),
      classes: {
        isPro: this.namespace('flag-pro'),
        isFree: this.namespace('flag-free'),
        isNew: this.namespace('flag-new'),
        onSale: this.namespace('flag-sale'),
        tout: this.namespace('flag-sale'),
        h5: this.namespace('h5')
      },
      namespace: this.namespace.bind(this)
    });
  }

  /**
    * Build the primary navigation links to be displayed on the right side
    * of the header.
    *
    * @param {String} navRightClassName class name for the right navigation
    * @returns {Array} nav items
    * @private
    */
  buildNavRight(navRightClassName) {
    const { props } = this;
    if (!props.navigationRight) {
      return null;
    }

    // navigationRight can have links or menus
    return trayMenusBuilder(props.navigationRight, {
      namespace: this.namespace.bind(this),
      className: this.classNames(navRightClassName, this.namespace('topnav-item')),
      classes: {
        isPro: this.namespace('flag-pro'),
        isFree: this.namespace('flag-free'),
        isNew: this.namespace('flag-new'),
        onSale: this.namespace('flag-sale'),
        tout: this.namespace('flag-sale'),
        h5: this.namespace('h5')
      },
      eidPrefix: 'uxp.hyd.product_nav',
      urlArgs: props.urlArgs
    });
  }

  /**
   * Build the secondary navigation links from the passed in nav data structure.
   *
   * @param {number} category index of selected primary nav
   * @returns {Array} nav items
   * @private
   */
  buildSecondaryNav() { // eslint-disable-line max-statements, complexity
    const { props, state } = this;
    const { activeHeading: data, currentHref } = state;
    let active;

    if (!data || !data.children) {
      return [];
    }

    // determine which child link is active
    for (let i = 0; i < data.children.length; i++) {
      const item = data.children[i];
      if (urlMatches(currentHref, item.href, true)) {
        if (item.options && item.options.hideSecondaryNav) {
          return [];
        }
        active = item.caption || item.id;
      }
    }

    const subnav = linkListBuilder(data.children, {
      className: this.namespace('secondarynav-item'),
      activeClass: this.namespace('active'),
      active,
      eidPrefix: 'uxp.hyd.secondary_nav',
      urlArgs: props.urlArgs
    });

    const caption = data.title || data.caption;

    if (caption) {
      const normalizedCaption = data.caption && data.caption.replace(/:/g, '_');
      subnav.unshift((
        <li
          key={ caption }
          id={ normalizedCaption || data.id }
          className={ this.namespace('secondarynav-item') }>
          { data.caption ? <FormattedHTMLMessage id={ caption } /> : data.title }
        </li>
      ));
    }

    return subnav;
  }

  /**
   * Add eventListeners for breakpoints.
   *
   * @private
   */
  componentDidMount() {
    this.breakpoint(...breakpoints);
  }

  /**
   * Remove the eventListeners of breakpoints.
   *
   * @private
   */
  componentWillUnmount() {
    this.breakup();
  }

  /**
   * Renders the desktop primary & secondary navigation
   *
   * @returns {ReactElement} the desktop nav
   * @private
   */
  renderDesktop() {
    return (
      <section>
        { this.renderDesktopPrimaryNav() }
        { this.renderDesktopSecondaryNav() }
      </section>
    );
  }

  /**
   * Renders the desktop primary navigation
   *
   * @returns {ReactElement} primary navigation
   * @private
   */
  renderDesktopPrimaryNav() {
    const { props, components } = this;
    const { partnersIcon, pro } = components;

    if (!props.showPrimaryNav) {
      return null;
    }

    const topNavList = this.buildMainNav();
    const navRight = this.buildNavRight();

    const emptyNavRight = (!Array.isArray(props.navigationRight) || props.navigationRight.length === 0) ? 'topnav-pro-gap' : '';
    return (
      <nav className={ this.namespace(this.classNames('topnav', {
        'reseller': props.isReseller,
        'sticky-product-nav': props.sticky && !props.sticky.productNav
      })) }>
        <div className={ this.namespace('container') } ref={ r => { this.topNav = r; } }>
          <div className={ this.namespace('flex-row') }>
            <ul className={ this.namespace('topnav-items') } ref={ r => { this.topNavItems = r; } }>
              { topNavList }
            </ul>
            <ul className={ this.namespace('topnav-right') }>
              { navRight }
              { partnersIcon && this.renderPartnersIcon(partnersIcon) }
              { pro &&
                <li className={ this.namespace('topnav-item', 'topnav-pro-icon', emptyNavRight) }>
                  <Link className={ this.namespace('pro-icon') }
                    urlArgs={ props.urlArgs }
                    href={ props.urls.proHome.href }
                    data-eid='uxp.hyd.product_nav.go_daddy_pro.icon.click'>
                  </Link>
                </li>
              }
            </ul>
          </div>
        </div>
      </nav>
    );
  }

  /**
   * Renders the desktop secondary navigation
   *
   * @returns {ReactElement} secondary navigation
   * @private
   */
  renderDesktopSecondaryNav() {
    const { props } = this;
    const secondaryNavList = this.buildSecondaryNav();

    if (!secondaryNavList.length) {
      return null;
    }

    return (
      <nav className={ this.namespace(this.classNames('secondarynav', {
        'sticky-green-nav': props.sticky && !props.sticky.productNav
      })) }>
        <div className={ this.namespace('container') } ref={ r => { this.secondaryNav = r; } }>
          <div className={ this.namespace('row') }>
            <div className={ this.namespace('col-sm-12') }>
              <ul className={ this.namespace('secondarynav-items') } ref={ r => { this.secondaryNavItems = r; } }>
                { secondaryNavList }
              </ul>
            </div>
          </div>
        </div>
      </nav>
    );
  }

  renderFeaturedNav() {
    const { props } = this;
    const desktopNavs = [];
    const mobileNavs = [];
    props.featuredNav && props.featuredNav.forEach(item => {
      if (item.title || item.caption) {
        if (item.children || item.href) {
          if (item.onlyMobile) {
            mobileNavs.push(item);
          } else if (item.onlyDesktop) {
            desktopNavs.push(item);
          } else {
            mobileNavs.push(item);
            desktopNavs.push(item);
          }
        }
      }
    });

    const desktop = trayMenusBuilder(desktopNavs, {
      urlArgs: props.urlArgs,
      className: this.namespace('topnav-item', 'd-none', 'd-sm-flex', 'desktop-featured-nav'),
      namespace: this.namespace.bind(this)
    });

    const mobile = trayMenusBuilder(mobileNavs, {
      urlArgs: props.urlArgs,
      className: this.namespace('topnav-item', 'd-sm-none', 'mobile-featured-nav'),
      namespace: this.namespace.bind(this),
      classNames: this.classNames
    });

    return (
      <ul className={ this.namespace('featured-nav') }>
        { mobile }
        { desktop }
      </ul>
    );
  }

  /**
   * Renders the mobile navigation
   *
   * @returns {ReactElement} mobile navigation
   * @private
   */
  renderMobile() {
    const { state, props } = this;
    const { pro, partnersIcon } = this.components;
    const { growthnav } = props;

    if (!props.showPrimaryNav) {
      return null;
    }

    const navs = [];
    const navRight = this.buildNavRight(this.namespace('topnav-promos-link-mobile'));

    props.navigation.forEach(item => {
      // convert `leftnav` to `href` to match expected data structure of `@ux/mobile-nav`
      if (item.leftnav && item.leftnav.href) {
        if (!item.href) {
          item.href = item.leftnav.href;
        }
      }

      if (item.title || item.caption) {
        navs.push(item);
      }
    });

    const proIcon = pro &&
      <li className={ this.namespace('topnav-item', 'topnav-pro-icon') }>
        <Link urlArgs={ props.urlArgs } className={ this.namespace('pro-icon') }
          href={ props.urls.proHome.href }
          data-eid='uxp.hyd.product_nav.go_daddy_pro.icon.click'>
        </Link>
      </li>;

    return (
      <div>
        <nav className={ this.namespace('topnav', 'clearfix', props.isReseller && 'reseller') } style={{ overflow: 'visible' }}>
          <div className={ this.namespace('container') }>
            <div className={  this.namespace('row') }>
              <div className={ this.namespace('flex-row') }>
                <AllProductsNav
                  className={ this.classNames({ [this.namespace('growth-nav')]: growthnav }) }
                  growthnav2={ props.growthnav2 }
                  nav={ navs }
                  menuTitle={ growthnav ? 'Sales:ProductNav:Products' : 'Shared:ProductNav:AllProducts' }
                  market={ props.market }
                  messages={ props.messages }
                  urls={ props.urls }
                  currentHref={ state.currentHref }
                  activeHeading={ state.activeHeading }
                  showHomeLink={ props.isReseller }
                  eidPrefix='uxp.hyd.product_nav'
                  urlArgs={ props.urlArgs }
                  menuButtonEid={ growthnav ?
                    'uxp.hyd.all_products_verticalmenu_open.button.click' :
                    'uxp.hyd.all_products_menu_open.button.click' }
                />
                { growthnav && this.renderFeaturedNav() }
                <ul className={ this.namespace(this.classNames('mobile-nav-right', {
                  'd-none': growthnav,
                  'd-sm-flex': growthnav,
                  'growth-nav-right': growthnav
                })) }>
                  { navRight }
                  { partnersIcon && this.renderPartnersIcon(partnersIcon) }
                  { proIcon }
                </ul>
              </div>
            </div>
          </div>
        </nav>
      </div>
    );
  }

  /**
   * Renders partners icon
   * @param {Object} partnersIcon Details about the partners icon
   * @param {String} partnersIcon.href Url for partners page
   * @param {String} partnersIcon.caption Translation key for partners icon
   * @param {String} partnersIcon.title Pretranslated alt text for partners icon
   * @returns {React.ReactElement} The <li> containing the partners Link and img
   */
  renderPartnersIcon(partnersIcon) {
    const { caption, href, title } = partnersIcon;
    const icon = (altText) => <img
      className={ this.namespace('partners-icon') }
      src={ `${this.props.urls.cdn.href}ux/sales-header/partners-icon.svg` }
      alt={ altText }></img>;
    return <li id={ caption } className={ this.namespace('topnav-item') }>
      <Link urlArgs={ this.props.urlArgs }
        href={ href }
        data-eid='uxp.hyd.product_nav.partners.icon.click'>
        { caption ? <FormattedMessage id={ caption }>
          { icon }
        </FormattedMessage> : icon(title) }
      </Link>
    </li>;
  }

  /**
   * Renders complete nav.
   *
   * @returns {ReactElement} The rendered header
   * @private
   */
  render() {
    const { props } = this;
    let content = null;
    if (props.growthnav || (this.isMobile || this.state.breakpoint === 'tablet')) {
      content = this.renderMobile();
    } else {
      content = this.renderDesktop();
    }
    return (
      <IntlProvider locale={ props.market } messages={ props.messages }>
        <div className={ this.namespace('top') }>
          { content }
        </div>
      </IntlProvider>
    );
  }
}

/**
 * Property definitions.
 *
 * @type {Object}
 * @public
 */
ProductNavComponent.propTypes = {
  ...NamespaceShape,
  components: PropTypes.shape({
    pro: PropTypes.bool,
    partnersIcon: PropTypes.oneOfType([
      PropTypes.object,
      PropTypes.bool
    ])
  }),
  currentHref: PropTypes.string,
  featuredNav: PropTypes.array,
  growthnav: PropTypes.bool,
  growthnav2: PropTypes.bool,
  market: PropTypes.string,
  messages: PropTypes.object.isRequired,
  navigation: PropTypes.array.isRequired,
  navigationRight: PropTypes.array,
  secondaryNav: PropTypes.array,
  showPrimaryNav: PropTypes.bool,
  showCountryNameOnLogo: PropTypes.bool,
  specialNav: PropTypes.array,
  isReseller: PropTypes.bool
};

/**
 * Default property values.
 *
 * @type {Object}
 * @public
 */
ProductNavComponent.defaultProps = {
  components: defaultComponents,
  country: '',
  currentHref: '',
  growthnav: false,
  growthnav2: false,
  market: 'en-US',
  navigationRight: [],
  showCountryNameOnLogo: true,
  showPrimaryNav: true,
  isReseller: false
};

export default withNamespace(ProductNavComponent);
