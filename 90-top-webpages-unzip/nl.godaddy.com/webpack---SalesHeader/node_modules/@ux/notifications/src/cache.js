import { request } from '@ux/util';

function isValid(cache, shopperId, market) {
  return cache
    && cache.shopperId
    && cache.shopperId === shopperId
    && cache.market
    && cache.market === market
    && cache.timestamp
    && (Date.now() - cache.timestamp) < 1000 * 60 * 60 * 24; // 24 hours
}

const cacheSet = 'Notification_Set';
const cacheReq = 'Notification_Req';
const cacheRecv = 'Notification_Get';
const header = 'notify:';

let iframeCache = null;
let getCacheTimer = null;
let getCacheHandler = null;

function initCache(iframeCacheUrl, iframeClasses) {
  iframeCache = document.createElement('iframe');
  iframeCache.src = iframeCacheUrl;
  iframeCache.className = iframeClasses;

  // backwards compatibility with eldorado
  iframeCache.id = 'notificationCacheFrame';

  document.body.appendChild(iframeCache);
}

function postMessage(obj) {
  if (iframeCache && iframeCache.contentWindow) {
    iframeCache.contentWindow.postMessage(header + JSON.stringify(obj), '*');
  }
}

function deserializeMessage(msg) {
  if (typeof msg === 'object') {
    return msg;
  } else if (typeof msg === 'string' && msg.substr(0, header.length) === header) {
    return JSON.parse(msg.substr(header.length));
  }
}

function setCache(setObj) {
  postMessage({ type: cacheSet, payload: setObj });
}

function getCache(successCb, errorCb) {
  let timeoutCount = 0;
  getCacheTimer = setTimeout(function cacheTimeout() {
    if (timeoutCount < 1) {
      timeoutCount++;
      postMessage({ type: cacheReq });
      getCacheTimer = setTimeout(cacheTimeout, 1000);
      return;
    }

    getCacheCleanup();
    errorCb();
  }, 1000);

  getCacheHandler = function (e) {
    getCacheCleanup();

    const data = deserializeMessage(e.data);
    if (data && data.type === cacheRecv) {
      return successCb(data.payload);
    }

    errorCb();
  };

  window.addEventListener('message', getCacheHandler, false);
}

function getCacheCleanup() {
  if (getCacheTimer) {
    clearTimeout(getCacheTimer);
    getCacheTimer = null;
  }

  if (getCacheHandler) {
    window.removeEventListener('message', getCacheHandler);
    getCacheHandler = null;
  }
}

// eslint-disable-next-line max-params
function requestNotifications(href, privateLabelId, shopperId, market, successCb, errorCb) {
  request.get(href, {
    headers: {
      'Content-Type': 'application/json',
      'X-App-Key': 'customerexperience'
    }
  }, function notifCacheResponseHandler(error, notifications) {
    if (error || !Array.isArray(notifications)) {
      return errorCb(error || new Error(`expected an array but got ${notifications}`));
    }

    const response = {
      notifications,
      shopperId,
      market,
      timestamp: Date.now()
    };
    setCache(response);
    successCb(response);
  });
}

// eslint-disable-next-line max-params
export function get(cache, iframeClasses, api, privateLabelId, shopperId, market, successCb, errorCb) {
  function cacheGetError() {
    requestNotifications(api.href, privateLabelId, shopperId, market, successCb, errorCb);
  }

  function cacheGetSuccess(obj) {
    if (isValid(obj, shopperId, market)) {
      successCb(obj);
      return;
    }

    cacheGetError();
  }

  getCache(cacheGetSuccess, cacheGetError);

  // The cache sends its notifications as soon as it loads, so do this *after* setting up the cache receive handlers in getCache
  if (!iframeCache) {
    initCache(cache, iframeClasses);
  }
}

export function reset() {
  if (iframeCache) {
    iframeCache.parentNode.removeChild(iframeCache);
    iframeCache = null;
  }

  getCacheCleanup();
}
