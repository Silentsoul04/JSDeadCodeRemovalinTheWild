'use strict';

var cookieHelper = require('./cookie');
var object = require('./object');
var cryptoHelper = require('./crypto');

var _authInfoToken = {};

var _authRealms = ['idp', 'jomax'];

var _authRealmIdMap = {
  idp: 'info_shopperId',
  jomax: 'info_accountName'
};

function _isTokenEmpty(token) {
  return Object.keys(token).length < 1;
}

// Fetch the info_token for a particular realm from the browser
function _getInfoTokenClaims(realm) {
  var claims = {};
  var cookieName = 'info_' + realm;
  var cookie = cookieHelper.findCookie(cookieName);
  if (cookie) {
    try {
      claims = JSON.parse(cookie);
    } catch (err) {} // eslint-disable-line no-empty
  }
  return claims;
}

// Finds/updates _authInfoToken with the newest auth token.
// If none are found, the _authInfoToken variable is cleared.
function updateAuthTokens() {
  var token = {};
  for (var i = 0; i < _authRealms.length; i++) {
    var realm = _authRealms[i];
    var infoToken = _getInfoTokenClaims(realm);

    // Update the info token if its newer or not currently defined
    if (!_isTokenEmpty(infoToken) && (_isTokenEmpty(token) || token.iat < infoToken.iat)) {
      token = infoToken;
    }
  }

  _authInfoToken = token;
}

function isAuthenticated() {
  return !_isTokenEmpty(_authInfoToken);
}

// boolean value of whether the authenticated
// user is in a delegation scenario
function isDelegated() {
  if (!isAuthenticated()) {
    return false;
  }

  var authType = _authInfoToken.auth;
  return authType && authType !== 'basic';
}

// Boolean value of whether an employee token is found
// on the browser or the newest token is an employee
// delegation scenario
function isEmployee() {
  if (!isAuthenticated()) {
    return false;
  }

  var tokenType = _authInfoToken.typ;
  var authType = _authInfoToken.auth;
  // Check if the latest token is for jomax
  if (tokenType && tokenType === 'jomax') {
    return true;
  }

  // Check if the latest token is an employee impersonation
  if (authType && authType !== 'basic' && authType.charAt(0) === 'e') {
    return true;
  }

  // Check if there is a jomax token on the browser
  var jomaxToken = _getInfoTokenClaims('jomax');
  return !_isTokenEmpty(jomaxToken);
}

// Returns the delegate's (parent's) claims, if found.
function _getDelegationClaims(currentClaims) {
  if ('del' in currentClaims) {
    return _getDelegationClaims(currentClaims.del);
  }
  return currentClaims;
}

function _cryptOrUndefined(encrypt, value) {
  if (!encrypt) {
    // If we're not encrypting... just return the value
    return value;
  }

  if (value) {
    // Return encrypted value
    return cryptoHelper.sha256(value);
  }
}

// Fetch a claim from a delegation token
// (This will parse the token recursively)
function getDelegateClaim(claim, encrypt) {
  if (isAuthenticated()) {
    var authType = _authInfoToken.auth;
    if (authType !== 'basic') {
      var delegationClaims = _getDelegationClaims(_authInfoToken);
      return _cryptOrUndefined(encrypt, delegationClaims[claim]);
    }
  }
}

// Returns the employee id if a jomax token is found
// If the newest token is an employee delegation token,
// the employee id will be returned.
function getEmployeeId(encrypt) {
  if (isAuthenticated()) {
    var tokenType = _authInfoToken.typ;
    var authType = _authInfoToken.auth;
    var idClaimName = _authRealmIdMap.jomax;

    // Check if the latest token is for jomax
    if (tokenType && tokenType === 'jomax') {
      return _cryptOrUndefined(encrypt, _authInfoToken[idClaimName]);
    }

    // Check if the latest token is an employee impersonation
    if (authType && authType !== 'basic' && authType.charAt(0) === 'e') {
      return getDelegateEmployeeId(encrypt);
    }

    // Check if there is a jomax token on the browser
    var jomaxToken = _getInfoTokenClaims('jomax');
    if (!_isTokenEmpty(jomaxToken)) {
      return _cryptOrUndefined(encrypt, jomaxToken[idClaimName]);
    }
  }
}

// Fetch the jomax (employee) username from the current token
function getDelegateEmployeeId(encrypt) {
  return getDelegateClaim(_authRealmIdMap.jomax, encrypt);
}

// Search an auth token for a particular claim
function _getInfoTokenClaim(tokenClaims, claim, type) {
  var tokenType = tokenClaims.typ;
  if (typeof type !== 'undefined' && tokenType && tokenType !== type) {
    return;
  }

  var rVal = void 0;
  var authType = tokenClaims.auth;
  // If this is a delegation token, search
  // sub claims recursively
  if (authType && authType !== 'basic') {
    var subClaims = tokenClaims[authType];
    rVal = _getInfoTokenClaim(subClaims, claim, type);
  } else {
    rVal = tokenClaims[claim];
  }

  return rVal;
}

// Get the customer id for the user who is delegated into
// the current user.
function getDelegateCustomerId(encrypt) {
  return getDelegateClaim('info_cid', encrypt);
}

// Get the customer id from the newest auth token
function getCustomerId(encrypt) {
  if (isAuthenticated()) {
    // Search the info token for the customer id claim
    return _cryptOrUndefined(encrypt, _getInfoTokenClaim(_authInfoToken, 'info_cid'));
  }
}

// Fetches the appropriate ID for the newest auth token.
// If it's a delegation token, the subordinate's
// (child's) ID will be returned.
function getUserId(encrypt) {
  if (isAuthenticated()) {
    var tokenType = _authInfoToken.typ;

    // For the auth type (idp vs pass vs jomax), lookup the
    // name of the claim that holds the customer id
    var claimToLookup = _authRealmIdMap[tokenType];

    // Search the info token for the customer id claim
    return _cryptOrUndefined(encrypt, _getInfoTokenClaim(_authInfoToken, claimToLookup));
  }
}

// Fetches the shopper ID for the newest auth token.
// If it's a delegation token, the subordinate's
// (child's) ID will be returned.
function getShopperId(encrypt) {
  if (isAuthenticated()) {
    var tokenType = _authInfoToken.typ;
    if (tokenType === 'idp') {
      return _cryptOrUndefined(encrypt, _getInfoTokenClaim(_authInfoToken, 'info_shopperId'));
    }
  }
}

// Fetches the claim for the newest auth token.
// If it's a delegation token, the subordinate's
// (child's) claim will be searched.
function getClaimFromInfoToken(claimName) {
  if (isAuthenticated()) {
    return _getInfoTokenClaim(_authInfoToken, claimName);
  }
}

// First tries to fetch the fpid for the newest auth tokken.
// If not found, fallback/fetch the fpid from the brand cookie
function getFederationPartnerId() {
  if (isAuthenticated()) {
    var fpid = _getInfoTokenClaim(_authInfoToken, 'fpid');
    if (!fpid) {
      var tokenType = _authInfoToken.typ;
      if (typeof tokenType !== 'undefined') {
        fpid = cookieHelper.findCookie('brand_' + tokenType);
      }
    }
    return fpid;
  }
}

// Fetches the realm for the newest auth token.
// If it's a delegation token, the subordinate's
// (child's) realm will be returned.
function getUserRealm() {
  if (isAuthenticated()) {
    return _getInfoTokenClaim(_authInfoToken, 'typ');
  }
}

var internalExports = {};
if (process.env.NODE_ENV !== 'production') {
  internalExports = {
    _getInfoTokenClaims: _getInfoTokenClaims,
    _getInfoTokenClaim: _getInfoTokenClaim,
    _getDelegationClaims: _getDelegationClaims,
    _cryptOrUndefined: _cryptOrUndefined
  };
}

module.exports = object.merge({
  getClaimFromInfoToken: getClaimFromInfoToken,
  getDelegateCustomerId: getDelegateCustomerId,
  getDelegateEmployeeId: getDelegateEmployeeId,
  getEmployeeId: getEmployeeId,
  getFederationPartnerId: getFederationPartnerId,
  getCustomerId: getCustomerId,
  getUserRealm: getUserRealm,
  getShopperId: getShopperId,
  isAuthenticated: isAuthenticated,
  isDelegated: isDelegated,
  isEmployee: isEmployee,
  updateAuthTokens: updateAuthTokens,
  getUserId: getUserId
}, internalExports);