import { throttle, debounce } from 'lodash';
import { requestFullscreen, addFullscreenChangeListener,
  exitFullscreen, isFullscreen } from '../../../js/services/polyfill-fullscreen/index';
import template from './video-player-skin.html';

const CONTROLS = [
  'muteButton', 'currentTime', 'duration', 'fullscreenButton',
  'playButton', 'progressBar', 'progressHandle', 'progressPlayed'
];
const CONTROLS_AUTOHIDE_MS = 2000;

class VideoPlayerSkin {

  /**
   * Creates a new VideoPlayerSkin instance
   * @param {Object} context - the t3 Context
   */
  constructor({ video, container }) {
    this.video = video;
    this.controls = {};
    this.container = container;
    try {
      this.container.insertAdjacentHTML('beforeend', template.render());
      this.setElementReferences();
      this.initUIState();
      this.show();
    } catch(e) {
      // TODO: instrument this silent fail
      return;
    }
    this.video.controls = false;
    this.addListeners();
  }

  /**
   * Collects references to the custom element nodes
   * For use by the event handlers
   */
  setElementReferences() {
    const controlHandlers = {
      muteButton: {
        clickHandler: this.onMuteToggle
      },
      fullscreenButton: {
        clickHandler: this.onFullscreenButtonClick
      },
      progressBar: {
        clickHandler: this.onManualProgressUpdate,
        mousedownHandler: this.onProgressMouseDown,
        touchstartHandler: this.onProgressMouseDown
      },
      playButton: {
        clickHandler: this.onPlayToggle,
      }
    };
    if (!this.container) {
      throw new Error('VPS Custom UI - Did not find container');
    }
    CONTROLS.forEach(name => {
      const element = this.container.querySelector(`[data-name="${name}"]`);
      if (!element) {
        throw new Error(`VPS Custom UI - Did not find ${name}`);
      }
      this.controls[name] = Object.assign({ element }, controlHandlers[name]);
    });
  }

  /**
   * Make any changes to the skin state necessary to represent the initial video state
   */
  initUIState() {
    // video could load in muted state
    if (this.video.muted) {
      this.container.dataset.muted = '';
    }
    this.container.dataset.autohide = '';
  }

  /**
   * Show the custom controls
   */
  show() {
    const controlsContainer = this.container.querySelector('[data-name="customUI"]');
    if (!controlsContainer) {
      throw new Error(`VPS Custom UI - Did not find element with [data-name="customUI"]`);
    }
    controlsContainer.removeAttribute('hidden');
  }

  /**
   * Toggle mute status
   */
  onMuteToggle() {
    this.video.muted = !this.video.muted;
    this.onSetMuteData();
  }

  /**
   * Toggle mute data
   */
  onSetMuteData() {
    if (this.video.muted) {
      this.container.dataset.muted = '';
    } else {
      this.container.removeAttribute('data-muted');
    }
  }

  /**
   * Toggle playing status
   */
  onPlayToggle() {
    if (this.video.paused) {
      this.video.play();
    } else {
      this.video.dataset.userPaused = '';
      this.video.pause();
    }
  }

  /**
   * Update the UI elements to represent the provided time
   * @param {Number} time - the time to update the UI to
   */
  updateProgressUI(time) {
    const duration = isNaN(this.video.duration) ? 0 : this.video.duration;
    const playedPercent = time / duration * 100;
    // update time labels
    this.controls.currentTime.element.textContent = this.secondsToTimeStamp(time);
    this.controls.duration.element.textContent =
      `-${this.secondsToTimeStamp(duration - time)}`;
    // update progress elements
    this.controls.progressHandle.element.style.left = `${playedPercent}%`;
    this.controls.progressPlayed.element.style.width = `${playedPercent}%`;
  }

  /**
   * Triggered by the timeupdate event listener
   */
  onAutoProgressUpdate() {
    if (!this.adjustingProgress) {
      if (!isNaN(this.video.currentTime)) {
        this.updateProgressUI(this.video.currentTime);
      }
    }
  }

  /**
   * Triggered by user interaction with the progress bar
   * @param {Event} e - the native browser event
   */
  onManualProgressUpdate(e) {
    if (!this.adjustingProgress) {
      return;
    }
    const eventX = (e.changedTouches && e.changedTouches[0].clientX) || e.clientX;
    const barOffset = this.controls.progressBar.element.getBoundingClientRect().left;
    const barWidth = this.controls.progressBar.element.clientWidth;
    const progress = (eventX - barOffset) / barWidth;
    const boundedProgress = Math.max(Math.min(progress, 1), 0);
    const boundedTime = this.video.duration * boundedProgress;
    this.updateProgressUI(boundedTime);
    this.video.currentTime = boundedTime;
  }

  /**
   * Triggered by mousedown and touchdown events
   */
  onProgressMouseDown() {
    this.adjustingProgress = true;
  }

  /**
   * Triggered by a global mouseup or touchend event
   * @param {Event} e - the native browser event
   */
  onMouseUp(e) {
    this.onManualProgressUpdate(e);
    this.adjustingProgress = false;
  }

  /**
   * Sets [data-autohide] attribute when mouse has not moved
   * in the last CONTROLS_AUTOHIDE_MS milliseconds
   */
  addControlsAutoHideListener() {
    const debouncedHideControls = debounce(() => {
      this.container.dataset.autohide = '';
    }, CONTROLS_AUTOHIDE_MS);
    this.container.addEventListener('mousemove', () => {
      this.container.removeAttribute('data-autohide');
      debouncedHideControls();
    });
  }

  /**
   * Update the data-state attribute for the player
   * @param {String} value - the new state
   */
  updateStateAttribute(value) {
    this.container.dataset.state = value;
  }

  /**
   * Toggle Fullscreen status
   */
  onFullscreenButtonClick() {
    if (isFullscreen()) {
      exitFullscreen();
    } else {
      requestFullscreen(this.container);
    }
  }

  /**
   * Triggered on onFullscreenChange event
   * We have a separate listener to tell if we really entered fullscreen
   * as the user is able to cancel it.
   */
  onFullscreenChange() {
    if (isFullscreen()) {
      this.container.dataset.fullscreen = '';
    } else {
      this.container.removeAttribute('data-fullscreen');
    }
  }

  /**
   * Delegate an event on the player to the appropriate handler
   * @param {Event} e - the native browser event
   */
  delegate(e) {
    const targetControl = this.controls[e.target.dataset.name];
    if (targetControl && targetControl[`${e.type}Handler`]) {
      return targetControl[`${e.type}Handler`].call(this, e);
    }
    // Default a click anywhere on the video to play/pause
    if (e.type === 'click' && e.target === this.video) {
      return this.onPlayToggle();
    }
    return null;
  }

  // NOTE: this method will overflow for times greater than 24 hours
  secondsToTimeStamp(seconds) {
    seconds = Math.max(seconds, 0); // IE can have a negative currentTime
    const isoString = new Date(seconds * 1000).toISOString();
    let timePart = isoString.substr(11, 8); // 00:00:00;
    if (seconds < 3600) {
      timePart = timePart.substr(3, 5); // 00:00
    }
    return timePart.replace(/^0+(\d:)/, '$1'); // strip more than 1 leading 0
  }

  /**
   * Add all listeners to the custom DOM
   */
  addListeners() {
    // *** Delegated Listeners ***
    this.container.addEventListener('click', this.delegate.bind(this));
    this.container.addEventListener('mousedown', this.delegate.bind(this));
    this.container.addEventListener('touchstart', this.delegate.bind(this));

    // *** Video Event Listeners ***
    this.video.addEventListener('waiting', this.updateStateAttribute.bind(this, 'loading'));
    this.video.addEventListener('playing', this.updateStateAttribute.bind(this, 'playing'));
    this.video.addEventListener('pause', this.updateStateAttribute.bind(this, 'paused'));
    this.video.addEventListener('timeupdate', throttle(this.onAutoProgressUpdate.bind(this), 50));
    this.video.addEventListener('volumechange', this.onSetMuteData.bind(this));
    // IE does not correctly fire 'playing' after a seek, so we use the following two listeners
    this.video.addEventListener('seeking', () => {
      if(this.container.dataset.state !== 'init') {
        this.updateStateAttribute('loading');
      }
    });
    this.video.addEventListener('seeked', () => {
      if (this.container.dataset.state !== 'init') {
        this.updateStateAttribute(this.video.paused ? 'paused' : 'playing');
      }
    });
    this.addControlsAutoHideListener();

    // *** Global Listeners ***
    document.addEventListener('mouseup', this.onMouseUp.bind(this));
    document.addEventListener('touchend', this.onMouseUp.bind(this));
    document.addEventListener('mousemove', this.onManualProgressUpdate.bind(this));
    document.addEventListener('touchmove', this.onManualProgressUpdate.bind(this));
    addFullscreenChangeListener(this.onFullscreenChange.bind(this));
  }
}

export default function addSkin({ video, container }) {
  return new VideoPlayerSkin({ video, container });
}
