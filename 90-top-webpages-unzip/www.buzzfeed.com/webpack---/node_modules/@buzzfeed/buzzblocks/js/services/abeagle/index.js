import { getUserId } from '@buzzfeed/bf-utils/lib/userid';
import { queryStringToObject } from '@buzzfeed/bf-utils/lib/query-string';
import { ABEAGLE_REQUEST_ROUTE, ABEAGLE_ROUTE_PREFIX } from './tracking';
import ajax from '../ajax';
import cookies from '../cookies';
import speedtrack from '../performance';
import { isNil } from 'lodash';

// Array of experiments set by clients via registerExperiments function
let experiments = [];

// Object of form {experimentName: [{request, reject}, {request, reject}], ..}
// Updated when clients request the bucketing for a particular experiment with
// `getExperimentVariant`
let variantPromises = {};

// Object of form {experimentName: bucketedVariantName, ..}
// Used to store the result from abeagle_public
let variants = {};

// Promise for ajax request to abeagle_public
let requestPromise;

// Object to hold errors return by the call to abeagle_public
let experimentErrors = {};

const abFlags = (() => {
  const queryParams = queryStringToObject(window.location.search);
  return queryParams.abflags || queryParams.abdebug;
})();

const cookieDomain = cookies.getBuzzfeedSubdomainOrWildcard(window.location.hostname);

// value to store for unbucketed users
const DEFAULT_VARIANT = null;

/**
 * Sets value in *variants* and resolves all promises for the experiment in
 * variantPromises.
 * @param {String} experiment - experiment name.
 * @param {String} variant - varation name.
 * @return {void}
 */
function resolveVariant(experiment, variant) {
  variants[experiment] = variant;
  if (variantPromises[experiment]) {
    variantPromises[experiment].forEach(promise => promise.resolve(variant));
  }
}

/**
 * Fires control variation for every eligible abtest.
 * @return {void}
 */
function resolveAllToDefault() {
  experiments.forEach(function(experiment) {
    if (experiment.isEligible()) {
      resolveVariant(experiment.name, DEFAULT_VARIANT);
    }
  });
}

/**
 * Set tracked experiment cookie.
 * @param {String} name - name of cookie
 * @param {String} value - value of cookie
 * @return {void}
 */
function setCookie(name, value) {
  const domain = window.location.hostname.replace('www', '');
  // Remove the wildcarded cookie, if it exists.
  // TODO: this is only needed as a temporary measure
  // until the wildcarded abeagle cookies have naturally expired
  cookies.remove(name, `.${domain}`);

  // Production cookies last 14 days. Stage and dev cookies last 1 day
  const days = cookieDomain === `www.${domain}` ? 14 : 1;

  // Set the new cookie
  cookies.set({
    name,
    value,
    days,
    domain: cookieDomain
  });
}


/**
 * Send experiment variation to BFA.
 * @param {String} endpoint - endpoint to send variation
 * @param {Object} data - variation data
 * @return {void}
 */
function track(endpoint, data) {
  window.bfa(endpoint, { data });
}


/**
 * Proceses variant events.
 * @param {Object} experimentsMap - map of experiment names.
 * @return {void}
 */
function processVariantEvents(experimentsMap) {
  Object.keys(experimentsMap).forEach(experimentName => {
    const versionCookieName = `${experimentName}_version`;
    const experiment = experimentsMap[experimentName];
    let { value, version, error, resolved } = experiment;

    if (error) {
      let errObj = {
        type: 'ExperimentServerError',
        name: experimentName,
        error: error
      };
      experimentErrors[experimentName] = errObj;
      if (variantPromises[experimentName]) {
        variantPromises[experimentName].forEach(promise => promise.resolve(DEFAULT_VARIANT));
      }
      return;
    }

    // When experiment is resolved with NULL - save 'control' to user cookies.
    if (resolved) {
      value = value || 'control';
    }

    resolveVariant(experimentName, value);

    // At this point NULL value means that a user is not bucketed into any
    // variant.  Nothing should be tracked or saved in that case.  Additionally
    // remove any cookies which may be set for this experiment.
    if (value === null) {
      cookies.remove(experimentName, cookieDomain);
      cookies.remove(versionCookieName, cookieDomain);
      return;
    }

    // Track only if experiment version or value in the response are different
    // from what's stored in cookies
    const isVariantSame = (cookies.get(experimentName) === String(value));
    const isVersionSame = (cookies.get(versionCookieName) === String(version));
    if (isVariantSame && isVersionSame) {
      return;
    }

    setCookie(experimentName, value);
    setCookie(versionCookieName, version);
    track(`${ABEAGLE_ROUTE_PREFIX}/${experimentName}`, {
      experiment: experimentName,
      variation: experiment
    });
  });
}


/**
 * Stores complete abeagle response in _metadata cookie.
 * @param {Array} experimentNames - array with experiments.
 * @param {Object} experimentsMap - map of experiment names.
 * @return {void}
 */
function storeAbeagleResponses(experimentNames, experimentsMap) {
  var experimentsToStore = [];

  experiments.forEach(function(experiment) {
    if (typeof experiment.storeResponse === 'boolean') {
      if (experiment.storeResponse) {
        experimentsToStore.push(experiment.name);
      }
    }
  });

  if (experimentsToStore.length === 0) {
    return;
  }

  experimentNames.forEach(function(experimentName) {
    if (experimentsToStore.indexOf(experimentName) !== -1) {
      var variant = experimentsMap[experimentName];

      if (!variant || variant.error || variant.value === null) {
        resolveVariant(experimentName, DEFAULT_VARIANT);
      } else {
        var cookieName = experimentName + '_metadata';
        var cookieValue = variant;

        cookieValue = JSON.stringify(cookieValue);
        cookieValue = escape(cookieValue);
        if (cookies.get(cookieName) !== cookieValue) {
          setCookie(cookieName, cookieValue);
        }
      }
    }
  });

}

/**
 * Overrides experiment variations from ABeagle API with user-supplied values.
 * Debugging purposes only.
 * @return {void}
 */
function overrideVariations() {
  experiments.forEach(function(experiment) {
    if (!experiment.isEligible()) {
      return;
    }
    var value = cookies.get(experiment.name);
    resolveVariant(experiment.name, value);
  });
}

function logError(e) {
  if (e instanceof Error) {
    throw e;
  }

  if (window.BZFD.Config.env === 'prod') {
    return;
  }

  switch(e.type) {
  case 'ExperimentNotFound':
    console.log(`Experiment "${e.name}" is not registered`);
    break;
  case 'ExperimentNotEligible':
    console.log(`Experiment "${e.name}" is not eligible`);
    break;
  case 'ExperimentServerError':
    console.log(`Experiment ${e.name} error: ${e.error}`);
    break;
  }
}

// match query parameters like `abeagle_$experiment=$value`, e.g.
// `abeagle_ADSGROUP-380_outbrain_zergnet=outbrain`
function getVariantFromQueryParameters(experimentName) {
  return queryStringToObject(window.location.search)[`abeagle_${experimentName}`];
}

export default {
  registerExperiments(exps = []) {
    experiments = exps;
    requestPromise = null;
  },

  /**
 * Return json data of meta data for all tests names passed
 * @param {Array} experimentNames - list of test names
 * @return {Object}
 */
  getExperimentMetaData(experimentNames) {
    var metaData = {};

    experimentNames.forEach(function(testName) {
      var cookieValue = cookies.get(testName + '_metadata');

      try {
        cookieValue = unescape(cookieValue);
        cookieValue = JSON.parse(cookieValue);
        metaData[testName] = cookieValue;
      } catch (e) {
        return;
      }
    });

    return metaData;
  },

  /**
   * Called by clients. Returns promise of variant value.
   * If the call to abeagle_public hasn't returned, then
   * update variantPromises obj with [{resolve, reject}] array
   *
   * The *options* object contains two options:
   *
   * If *rejectErrors* is true, then return a rejected promise if
   * - Experiment/featureflag doesn't exist
   * - User is ineligible for experiment/featureflag
   * - abeagle returned an error for expeirment/featureflag
   *
   * *defaultVariantIfUnbucketed* allows clients to specify a value other than null
   * to use for unbucketed users. (This is typically "control", the default value)
   *
   * @param {string} experimentName
   * @param {string} options {rejectErrors (bool), defaultVariantIfUnbucketed (string or null)}
   * @returns {Promise}
   **/
  getExperimentVariant(experimentName, { rejectErrors = true, defaultVariantIfUnbucketed = 'control', errorVariant = DEFAULT_VARIANT } = {}) {
    const queryParamVariant = getVariantFromQueryParameters(experimentName);
    // if experiment name/variant in query params, use that value
    if (queryParamVariant) { return Promise.resolve(queryParamVariant); }

    let matchedExperiment = experiments.filter(experiment => experiment.name === experimentName)[0];

    // if abeagle_public returned an error prior to `getExperimentVariant` call,
    // an error will be stored in *experimentErrors*
    let err = experimentErrors[experimentName];
    let result;

    if (!matchedExperiment) {
      err = {
        type: 'ExperimentNotFound',
        name: experimentName
      };
    } else if (!matchedExperiment.isEligible()) {
      err = {
        type: 'ExperimentNotEligible',
        name: experimentName
      };
    }

    if (err) {

      if (rejectErrors === false) {
        this.defaultErrorHandler(err);
        result = Promise.resolve(errorVariant);
      } else {
        result = Promise.reject(err);
      }

    } else if (experimentName in variants) {
      // if abeagle_public returned a variant prior to
      // `getExperimentVariant` call, it will be stored in *variants*
      result = Promise.resolve(variants[experimentName]);

    } else {
      result = new Promise((resolve, reject) => {
        if (!variantPromises[experimentName]) {
          variantPromises[experimentName] = [{ resolve, reject }];
        } else {
          variantPromises[experimentName].push({ resolve, reject });
        }
      });
    }

    // If defaultVariantIfUnbucketed is something other than DEFAULT_VARIANT (null),
    // then replace the null values with defaultVariantIfUnbucketed before returning
    // to the client
    if (defaultVariantIfUnbucketed !== DEFAULT_VARIANT) {
      result = result.then((val) => val === DEFAULT_VARIANT ? defaultVariantIfUnbucketed : val);
    }

    return result;
  },

  /**
   * Called by clients.
   * Returns a promise resolved to true if:
   * - *ffName* has a variant named *onValue*
   *   ABeagle feature flags have a single variant named "on"
   *   But some teams use experiments to act like feature flags,
   *   and the variant used to signify on is often a different value
   * - the user was bucketed into the *onValue* variant
   *
   * Returns a promise resolved to false if:
   * - *ffName* doesn't have a variant named *onValue*
   * - user not bucketed into variant named *onValue*
   * - user not eligible
   * - *ffname* does not exist in abeagle
   * - abeagle returned an error for *ffName*
   *
   * @param {string} ffName, name of experiment/featureflag
   * @param {string} onValue, name of the variant signifying "on"
   * @returns Promise
   **/
  isOn(ffName, onValue = 'on') {
    if (isNil(onValue)) {
      return Promise.reject('onValue cannot be null or undefined');
    }

    return this.getExperimentVariant(ffName, { rejectErrors: false })
      .then(val => (val === onValue));
  },

  defaultErrorHandler: logError,

  /**
   * Hits abeagle_public endpoint which returns experiment variants for the current user.
   * - filters *experiments* array to return only those experiments where the
   *   current user is eligible
   * - sends client id of the users to abeagle_public
   *
   * If abeagle_public request is successful, process results and store cookies
   * If  abeagle_public request fails: falls back to control variants.
   *
   */
  getVariants() {
    const performanceMetric = 'abeagle.getVariants';
    speedtrack.eventStart(performanceMetric);
    if (abFlags) {
      overrideVariations();
      return Promise.resolve();
    }

    // ABeagle API request should only be sent once
    if (requestPromise) {
      return Promise.resolve();
    }

    const experimentNames = experiments
      .filter(experiment => experiment.isEligible())
      .map(experiment => experiment.name);

    if (!experimentNames.length) {
      return Promise.resolve();
    }

    const startRequestTime = new Date().getTime();
    return getUserId({ env: BZFD.Config.env }).then(userId => {
      requestPromise = ajax.get(`${window.BZFD.Config.abeagle.url}/public/v2/experiment_variants`, {
        data: {
          'experiment_names': experimentNames.join(';'),
          'user_id': userId,
          'client_id': 'buzz_web'
        },
        timeout: 1500
      })
        .then(experimentsMap => {
          speedtrack.mark(`${performanceMetric}_fetched`);
          track(ABEAGLE_REQUEST_ROUTE, {
            responseTime: Date.now() - startRequestTime
          });
          processVariantEvents(experimentsMap);
          storeAbeagleResponses(experimentNames, experimentsMap);
          speedtrack.eventEnd(performanceMetric);
        })
        .catch(resolveAllToDefault);

      return requestPromise;
    });
  },

  saveExperiments(data) {
    if (typeof data['experimentsMap'] !== 'undefined' && typeof data['experimentNames'] !== 'undefined') {
      processVariantEvents(data.experimentsMap);
      storeAbeagleResponses(data.experimentNames, data.experimentsMap);
    }
  },

  /**
   * Entry point.
   * Processes experiment variants stored in user's cookie,
   * and calls `getVariants`
   * @return {void}
   */
  start() {
    this.getVariants();

    if (abFlags) {
      import('../ab-flipper')
        .then(function (flipper) {
          flipper.start(experiments);
        });
      return;
    }

    experiments.forEach(experiment => {
      if (!experiment.isEligible()) {
        resolveVariant(experiment.name, DEFAULT_VARIANT);

        return;
      }
      var storedValue = cookies.get(experiment.name);
      if (storedValue) {
        resolveVariant(experiment.name, storedValue);
      }
    });
  },

  /**
   * For tests only
   */
  reset() {
    experiments = [];
    variantPromises = {};
    experimentErrors = {};
    variants = {};
    requestPromise = null;
  }
};
