import { debounce } from 'lodash';

import {
  bfaTrack,
  getScreenOrientation
} from '../util/standalone';
import scrollListener from '../../../js/services/scroll-listener';

const VIEW_SEGMENT_PAUSE_TIMEOUT = 1000;
const SCRUB_DEBOUNCE_RATE = 1000;
const SECS_TO_MS = 1000;
const DUMMY_HLS_INSTANCE = { currentLevel: -1, streamController: { stats: { bwEstimate: 'unknown' } } };
const getWindow = () => window;

class Analytics {

  /**
   * Create a new Video Analytics instance
   * @param {Element} video - the video element to instrument
   * @param {Object} [config={}] - optional configuration
   */
  constructor(video, config = {}) {
    this.video = video;
    this.config = config;
    this.sessionVars = {};
    this.defaultToBFA();
    this.initVideoAttributes(video);
    this.initSessionVars();
    this.addListeners();
    this.hls = this.config.hls || DUMMY_HLS_INSTANCE;
    this.bufferStartTime = 0;
    this.bufferTotalTime = 0;
    this.bufferCounter = 0;

    this.scrollListenerId = scrollListener.add({ callback: this.verifyImpression.bind(this) });
  }

  /**
   * Set class variables for tracking video state
   */
  initVideoAttributes() {
    this.videoIsMuted = this.video.muted;
    this.videoCurrentTime = this.video.currentTime;
  }

  /**
   * Set tracking attributes that last for whole session
   */
  initSessionVars() {
    this.sessionVars = Object.assign(
      this.sessionVars,
      {
        'source': 'buzz_web',
        'page_url': this.location,
        'player': 'vps',
        'target': 'video_player',
        'platform': this.platform,
        'player_location': this.playerLocation,
        'video_type': this.currentSrcType,
        'video_title': this.config.videoTitle || 'unknown',
        'position': this.position,
        'dimensions': this.dimensions,
        'play_start_type': this.video.dataset.autoplay === '' ? 'autoplay' : 'click_to_play',
        'length': this.config.videoDuration || 'unknown',
        'author': 'Buzzfeed Video',
        'releasedAt': this.config.releasedAt
      },
      this.resourcePair
    );

    // if all metadata was not ready, set sessionVars again once it is
    this.video.addEventListener('loadedmetadata', this.initSessionVars.bind(this));
  }

  /**
   * Set default tracking callbacks to BFA
   * bfaTrack is a safe noop if BFA does not exist
   */
  defaultToBFA() {
    if (!this.config.track) {
      this.config.track = data => bfaTrack(`track/videoplayer/${data.type}`, { data });
      this.config.flush = () => bfaTrack(`track/videoplayer/flush`, {});
    }
  }

  /**
   * Adds custom tracking attributes
   * @param {Object} attributes - Attribute key/value pairs
   */
  addCustomAttributes(attributes) {
    this.sessionVars = Object.assign(
      {},
      this.sessionVars,
      attributes
    );
  }

  /**
   * Returns a key/value pair representing the current video:
   * @returns {Object}
   * e.g.
   * video_id: x
   * transcoder_path: y
   */
  get resourcePair() {
    const key = this.config.videoId ? 'video_id' : 'transcoder_path';
    const val = this.config.videoId ? this.config.videoId : this.config.transcoderPath;
    return { [key]: val || 'unknown' };
  }
  /**
   * Returns the current player location:
   * @returns {String}
   */
  get playerLocation() {
    return this.config.playerLocation;
  }
  /**
   * Returns the current platform:
   * @returns {String}
   */
  get platform() {
    return this.config.platform || 'buzzblocks';
  }
  /**
   * Returns the current window location:
   * @returns {String}
   */
  get location() {
    return this.config.origin || (window.location.origin + window.location.pathname);
  }
  /**
   * Returns the position of this video-player instance
   * as a 1-based index of all video-player instances on the page
   * @returns {Number}
   */
  get position() {
    const videos = Array.prototype.slice.call(document.querySelectorAll('.video-player'));
    return videos.indexOf(this.video) + 1;
  }
  /**
   * Returns the bandwidth of user
   * @returns {Number}
   */
  get bandwidth() {
    if(this.hls && this.hls.streamController && this.hls.streamController.stats) {
      return this.hls.streamController.stats.bwEstimate;
    }
    return 'unknown';
  }
  /**
   * Returns the type of the source chosen by the native player:
   * @returns {String}
   */
  get currentSrcType() {
    const currentSrc = this.video.currentSrc;
    if (!currentSrc) {
      return null;
    }
    if (currentSrc.match(/^blob/)) {
      return 'hls-polyfilled';
    }
    if (currentSrc.match(/m3u8$/)) {
      return 'hls';
    }
    return 'mp4';
  }

  get dimensions() {
    if(this.currentSrcType === 'mp4' && this.video.videoWidth && this.video.videoHeight) {
      return this.video.videoWidth + 'x' + this.video.videoHeight;
    }
    return undefined;
  }

  /**
   * Fires a tracking event
   * @param {string} event - The name of the event.
   * @param {Object} [meta={}] - Optional extra attributes to send.
   */
  track(event, meta = {}) {
    this.config.track(Object.assign(
      {},
      this.sessionVars,
      {
        'type': event,
        'value': event,
        'video_ts': Math.round(this.video.currentTime * SECS_TO_MS),
        'audio_volume': this.videoIsMuted ? 'muted' : 'unmuted',
        'orientation': getScreenOrientation(),
        'buffer_count': this.bufferCounter,
        'buffer_duration': this.bufferTotalTime,
        'bandwidth': this.bandwidth,
        'hls_level': this.hls.currentLevel
      },
      meta));
  }

  /**
   * Immediately flush any pending events
   */
  flush() {
    this.config.flush();
  }

  /**
   *  Track which parts of the video were watched and for how long
   *  See:
   *  https://github.com/buzzfeed/data-guide/blob/master/guide/schemas/pixiedust/video_player.md
   */
  startNewViewSegment() {
    if (this.segmentStartTime !== undefined) {
      this.track('video_view_segment', {
        'video_ts': Math.round(this.segmentStartTime * SECS_TO_MS),
        duration: Math.round((this.video.currentTime - this.segmentStartTime) * SECS_TO_MS)
      });
    }
    this.segmentStartTime = this.video.currentTime;
  }

  /**
   * Update the total buffer seconds
   */
  updateBuffer() {
    if (this.bufferStartTime) {
      var now = new Date();
      this.bufferTotalTime += Math.round(now - this.bufferStartTime);
      this.bufferStartTime = null;
    }
  }

  /**
   *  The first play event is counted as a 'video_view'
   *  Subsequent plays count as 'resume' events
   */
  onFirstPlay() {
    this.startNewViewSegment();
    this.initSessionVars();
    this.track('video_view');
    this.video.removeEventListener('play', this.listeners['play']);
    this.listeners['play'] = this.onResume.bind(this);
    this.video.addEventListener('play', this.listeners['play']);
  }

  /**
   *  Only track scrubs greater than 1 second
   *  This avoids an issue where HLS.js moves the video forward 43ms on load
   */
  onSeeked() {
    if (Math.abs(this.video.currentTime - this.videoCurrentTime) >= 1) {
      this.startNewViewSegment();
      this.videoCurrentTime = this.video.currentTime;
      this.track('scrub');
    }
  }

  /**
   *  Fires a pause event
   *  Pauses longer than 1 second should trigger a new view segment
   */
  onPause() {
    this.updateBuffer();
    this.viewSegmentTimeout = setTimeout(
      this.startNewViewSegment.bind(this), VIEW_SEGMENT_PAUSE_TIMEOUT
    );
    this.track('pause');
  }

  /**
   * Fires a resume event
   */
  onResume() {
    clearTimeout(this.viewSegmentTimeout);
    this.track('resume');
  }

  /**
   * Fires a waiting event
   * Start a buffer timer and increment counter
   */
  onWaiting() {
    var now = new Date();
    this.bufferStartTime = now;
    this.bufferCounter += 1;
  }

  /**
   * Fires a playing event
   */
  onPlaying() {
    this.updateBuffer();
  }

  /**
   * Fires a mute event
   * Trigger tracking for videos that are not collateral of automute
   */
  onVolumeChange() {
    // only if muted state has changed
    if (this.video.muted !== this.videoIsMuted) {
      // would have the following attribute if it's a casualty of automute
      if (!this.video.hasAttribute('data-automuted')) {
        this.startNewViewSegment(); // order is important here
        this.videoIsMuted = !this.videoIsMuted;
        this.track('mute');
      } else {
        this.videoIsMuted = !this.videoIsMuted;
      }
    }
  }

  /**
   * Verify if the video is visible and trigger impression if yes
   */
  verifyImpression() {
    const requiredVisible = 0.75; // 75% visible
    const rect = this.video.getBoundingClientRect();
    const max = getWindow().innerHeight - rect.height * requiredVisible;
    if(rect.top >= 0 && rect.top < max) {
      this.track('impression');
      scrollListener.remove(this.scrollListenerId);
      this.scrollListenerId = null;
    }
  }

  /**
   * Ends the current view segment and flushes pending events
   */
  onUnload() {
    this.startNewViewSegment();
    this.flush();
  }

  /**
   * Add all event listeners
   */
  addListeners() {
    this.listeners = {};
    this.handlerMap = {
      volumechange: this.onVolumeChange,
      seeked: debounce(this.onSeeked, SCRUB_DEBOUNCE_RATE),
      pause: this.onPause,
      play: this.onFirstPlay,
      playing: this.onPlaying,
      waiting: this.onWaiting
    };
    Object.keys(this.handlerMap).forEach(event => {
      this.listeners[event] = this.handlerMap[event].bind(this);
      this.video.addEventListener(event, this.listeners[event]);
    });
    // If the user navigates away, we want to end the current view segment
    window.addEventListener('beforeunload', this.onUnload.bind(this));
  }
}

export default function addVideoEvents(video, config) {
  return new Analytics(video, config);
}
