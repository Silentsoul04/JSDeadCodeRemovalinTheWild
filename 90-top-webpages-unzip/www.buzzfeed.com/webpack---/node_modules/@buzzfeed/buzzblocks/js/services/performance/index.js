import timing from 'timing.js';
import { performanceMapPath, customMarkMapPath } from './mapping';
import { isEmpty } from 'lodash';

// handles the marks added by the `mark()` method
let marks = {};

function sendData(mapPath, data) {
  if (typeof window.bfa !== 'function') {
    if (typeof window.raven !== 'undefined') {
      window.raven.captureException(new Error('Performance tracking issue: BFA is not available'));
    }
    return;
  }

  if (isEmpty(data)) {
    return;
  }

  window.bfa(mapPath, { data: data });

}

function trackPagePerformance() {
  function onLoad() {
    setTimeout(function() {
      sendData(performanceMapPath, timing.getTimes());
    }, 0);
  }
  if (document.readyState === 'complete') {
    onLoad();
  } else {
    window.addEventListener('load', onLoad);
  }
}

function getTiming(markName, originMarkName) {
  let time = timing.getTimes()[originMarkName];
  let value;

  if (!originMarkName || (marks[originMarkName])) {
    value = window.performance.now() - (marks[originMarkName] || 0);
  } else if (time) {
    value = window.Date.now() - time;
  } else {
    value = null;
  }

  return value;
}

/**
 * SpeedTrack API
 * O&O Web Performance Data Gathering
 * @see https://github.com/buzzfeed/mono/blob/master/qr_speedtrack for available metrics and tags.
*/
export default {

  // Marks Method ---------------------------
  /**
   * Creates:
   * 1. an entry in marks object with current timestamp;
   * 2. a performance.mark(markName) for third parties;
   * Allows a second argument if you want to change the time origin (default: `navigationStart`)
   * @see https://www.w3.org/TR/user-timing/ for recommended mark names
   * @param {String} markName - describes what is being timed.
   * @param {String} originMarkName - (optional) changes time origin.
   * @returns {void}
   * @example speedtrack.mark('mark_foo');
   * @example speedtrack.mark('mark_foo', 'mark_fonts_fully_loaded');
   */
  mark(markName, originMarkName) {
    if (window.performance === undefined) {
      return;
    }

    let markValue = getTiming(markName, originMarkName);
    if (markValue || markValue === 0) {
      marks[markName] = markValue;
      sendData(customMarkMapPath, { markName, markValue });
    } else {
      console.error(`${originMarkName} is not a known event.`);
      return;
    }

    if (window.performance.mark !== undefined) {
      window.performance.mark(markName);
    }
  },


  // Events Methods ---------------------------

  /**
   * Creates:
   * 1. an entry in events object with current timestamp;
   * 2. a performance.mark(eventName) for third parties;
   * @see https://www.w3.org/TR/user-timing/ for recommended mark names
   * @param {String} eventName - describes what is being timed.
   * @returns {void}
   * @example speedtrack.eventStart('foo');
   */
  eventStart(eventName) {
    if (window.performance === undefined) {
      return;
    }

    marks[eventName + '_start'] = window.performance.now();

    if (window.performance.mark !== undefined) {
      window.performance.mark(eventName + '_start');
    }
  },

  /**
   * Creates:
   * 1. an entry in events object with current timestamp;
   * 2. saves the duration of the event in `marks`
   * 3. a performance.mark(eventName) for third parties;
   * @see https://www.w3.org/TR/user-timing/ for recommended mark names
   * @param {String} eventName - describes what is being timed.
   * @returns {void}
   * @example speedtrack.eventEnd('foo');
   */
  eventEnd(eventName) {
    if (window.performance === undefined) {
      return;
    }

    if (marks[eventName + '_start']) {
      marks[eventName + '_end'] = window.performance.now();

      marks[eventName] = marks[eventName + '_end'] - marks[eventName + '_start'];

      sendData(customMarkMapPath, { markName: eventName, markValue: marks[eventName] });
    }

    if (window.performance.mark !== undefined) {
      window.performance.mark(eventName + '_end');
    }
  },

  /**
   * Sends already-measured timings to Datadog.
   * @param {String} eventName - name of the event
   * @param {Int|Float} eventValue - value of the event in ms.
   * @returns {void}
   * @example speedtrack.histrogram('mark_instragam_loaded', 3398);
   */
  histogram(eventName, eventValue) {
    marks[eventName] = eventValue;
    sendData(customMarkMapPath, { markName: eventName, markValue: marks[eventName] });
  },

  start() {
    trackPagePerformance();
  },

};
