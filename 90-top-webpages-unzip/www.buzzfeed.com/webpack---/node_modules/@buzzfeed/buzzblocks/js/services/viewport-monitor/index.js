/**
 * Parameters for viewport detection.
 * @typedef {Object} WatchParams
 * @property {HTMLElement} target - watched element.
 * @property {Number} renderLookahead - the number of pixels to look ahead
 * when detecting viewport position.
 * @property {Function} callback - a function to fire when viewport condition satisfied.
 * @property {Boolean} watchOnce - if the element should be removed from watching
 * after first callback fire.
 */

import { getViewPosition } from '../dom';
import scrollListener from '../scroll-listener';


// namespace for easier testing
const dom = { getViewPosition };


let monitors = {};
let identifier = 0;

class ViewportMonitor {
  constructor({ throttleTimeout }) {
    this.watching = {};

    this.fireCallback = this.fireCallback.bind(this);
    this.trigger = this.trigger.bind(this);
    this.add = this.add.bind(this);
    this.remove = this.remove.bind(this);

    scrollListener.add({
      throttleTimeout,
      callback: this.trigger,
    });
  }
  /**
   * Checks viewport position of the registered element and fires callback if condition satisfied.
   * @param {WatchParams} item - current subscriber.
   * @param {Number} [offset] - offset for viewport position.
   * @return {void}
   */
  fireCallback(item, offset) {
    var pos = dom.getViewPosition(item.target, item.renderLookahead, offset);

    if (pos.isHidden()) {
      return;
    }
    if (pos.isPartiallyInViewport() || pos.isPartiallyInLookahead() || pos.isWithinLookahead()) {
      item.callback();
      item.inViewport = true;
      if (item.watchOnce) {
        this.remove(item.target);
      }
    } else if (item.exitCallback && item.inViewport) {
      item.inViewport = false;
      item.exitCallback();
    }
  }
  /**
   * Scroll event handler. Fires registered callbacks.
   * @param {Number} [offset] - offset for viewport position.
   * @return {void}
   */
  trigger(offset) {
    for (let id in this.watching) {
      if (this.watching.hasOwnProperty(id)) {
        this.fireCallback(this.watching[id], offset);
      }
    }
  }
  /**
   * Watch for an element's position in the viewport
   * @param {WatchParams} params - watching params.
   * @returns {void}
   */
  add(params) {
    this.watching[identifier++] = params;
    this.fireCallback(params);
  }
  /**
   * Stops watching for an element's position in the viewport
   * @param {HTMLElement} elem - watched element.
   * @returns {void}
   */
  remove(elem) {
    if (elem instanceof HTMLElement) {
      for (let id in this.watching) {
        if (this.watching.hasOwnProperty(id) && this.watching[id].target === elem) {
          delete this.watching[id];
          break;
        }
      }
    }
  }
}

export default {
  /**
   * Creates viewport monitor instance
   * @param {Object} params - instance parameters.
   * @param {Number} params.throttleTimeout - number of milliseconds before executing callbacks.
   * @return {ViewportMonitor} - monitor instance.
   */
  create({ throttleTimeout }) {
    let monitor = monitors[throttleTimeout];
    if (!monitor) {
      monitor = monitors[throttleTimeout] = new ViewportMonitor({ throttleTimeout });
    }

    return monitor;
  },
  /**
   * Triggers all callbacks of all created monitors.
   * @param {Number} [offset] - offset for viewport position.
   * @return {void}
   */
  triggerAll(offset) {
    for (let key in monitors) {
      if (monitors.hasOwnProperty(key)) {
        monitors[key].trigger(offset);
      }
    }
  }
};
