import bzfd from '../bzfd';
import util from '../util/standalone';
import client from '../client';
import solid from '../solid/standalone';
import amazonTests from '../amazon-tests';
import fbAccounts from './fb-accounts';
import webview from '../webview/';

const _w = window;
const _d = document;
const _amazonSubtagIndices = {
  buzzId: 0,
  subbuzzPos: 1,
  subbuzzCount: 2,
  platform: 3,
  module: 4,
  rank: 5,
  origin: 6,
  experiment: 7
};

export default {

  /**
   * Flag to dump data in the console
   * @return {Boolean} - updated src url
   */
  _debug() {
    return document.location.search.indexOf('affiliatedebug=true') > -1;
  },

  /**
   * Update URL strings that are generated by  link_editor.py, specifically for
   * skimlinks flavored links
   *
   * Updated tag:
   *   - xcust[1] = Device/platform (mobile/desktop)
   *   - xcust[2] = Referrer
   *   - xcust[3] = AB Test Experiement values
   * @param {String} url - url string pickup from HTML
   * @returns {String} prefix - domain prefix of URL (ie. https://)
   */
  _modifySkimlinksURL(url, prefix = '') {

    var _escapedPrefix = this._escapeStrRegex(prefix);
    var _fullREStrV1 = _escapedPrefix + '/?\\?id=(.*)&site=(.*)&xs=(.*)&url=(http.*)';
    var _fullREStrV2 = _escapedPrefix + '/?\\?id=(.*)&sref=(.*)&url=(http.*)&xs=(.*)';
    var _prefixReg = new RegExp('^//');
    var _fullREV1 = new RegExp(_fullREStrV1);
    var _fullREV2 = new RegExp(_fullREStrV2);
    var _qs = '';
    var _qsObj = {};
    var _xcustArr = [];

    if (url.match(_prefixReg)) {
      url = 'https:' + url;
    }

    if (_fullREV1.test(url) || _fullREV2.test(url)) {
      _qs = util.getQueryString(url);
      _qsObj = util.queryStringToObject(_qs.substr(1, _qs.length));
      _xcustArr = decodeURIComponent(_qsObj['xcust']).split('|') || '';

      _xcustArr[1] = this._getSource();
      _xcustArr[2] = this._getReferrer();
      _xcustArr[3] = this._getExperiments();

      if (this._debug()) {
        console.log('Skimlinks Debug: ', _xcustArr);
      }

      _qsObj['xcust'] = encodeURIComponent(_xcustArr.join('|'));
      url = prefix + util.objectToQueryString(_qsObj);
    }

    return url;
  },

  /**
   * Update properly "affiliated" Amazon product URLs with extra client-side subtag information
   * This will update the href attribute for any of these links
   * Currently added info:
   *   - Referrer
   *   - ABeagle (variant)
   * @param {HTMLElement} link - link element
   * @returns {void}
   */
  _modifyAmazonURL(url, params = {}) {
    var _amazonMatch = url.match(/(https?:\/\/www\.amazon\..*\?)(.*?tag=.*)/);
    var _paramsObj = {};
    var _newParamsStr = '';
    var _updatedURL = url;

    //Match amazon.com links that also have search params attached
    if (_amazonMatch && _amazonMatch.length > 2 && _amazonMatch[2].length) {
      _paramsObj = util.queryStringToObject(_amazonMatch[2]);
      if ('ascsubtag' in _paramsObj && _paramsObj['ascsubtag'].trim().length) {
        const toUpdate = Object.assign(
          params.subtags || {}, { // update with subtags from params by default
            platform: this._getSource(), //get platform (m, d),
            origin: this._getReferrer(params), //get referrer label,
            experiment: this._getExperiments(), //get label for Shopping AB tests
          }
        );
        // hack if buzzid is not passed from backend
        const buzzIdIndex = _amazonSubtagIndices.buzzId;
        const current = this._decodeAmazonSubtags(_paramsObj.ascsubtag);
        if (current.length > buzzIdIndex && current[buzzIdIndex] === 'buzzid') {
          toUpdate.buzzId = bzfd.buzzId;
        }
        _paramsObj.ascsubtag = this._updateAmazonSubtags(_paramsObj.ascsubtag, toUpdate);
      }

      _newParamsStr = util.objectToQueryString(_paramsObj);
      _updatedURL = util.getBaseUrl(url) + _newParamsStr;
    }

    return _updatedURL;
  },

  /**
   * Get normalized referrer label from document.referrer
   * or T3 client service to add to subtag data
   * or object params
   * @return {String} - list of object's keys.
   */
  _getReferrer(params) {
    var _r = _d.referrer;
    var _qs = _w.location.search;
    var _qsObj = (_qs.length ? util.queryStringToObject(_qs.substr(1, _qs.length)) : false);
    var _label = '0';

    //add origin data (e.g.  ?origin=ts) from params
    //update bf label with an origin tag (e.g. bf-ts)
    if (params && params['origin'] && typeof params['origin'] !== 'undefined' && params['origin'].length) {
      _label = params['origin'];
    } else if (_qsObj && 'origin' in _qsObj && _qsObj['origin'].length) {
      // update bf label with an origin tag if there is an origin url param
      _label = 'bf-' + _qsObj['origin'];
    } else if (client.referrer.length) {
      // lookup referrer through the client t3 service first
      _label = client.referrer === 'tweet' ? 'twitter' : client.referrer;
    } else if (_r.match(/buzzfeed.com/i)) {
      // if internal (buzzfeed.com), tag as buzzfeed and extra point of origin (if any)
      _label = 'bf'; //internal label
    } else if (_r.match(/(facebook.com)|(fb.me)/i) && _qsObj.ref.match(/^bffb/i)) {
      // if facebook, pull referrer page from URL and use account ID from PDA (fb_accounts.js)
      var fbRefPage = _qsObj.ref.substr(4);
      _label = 'bffb_' + (fbAccounts[fbRefPage] ? fbAccounts[fbRefPage] : '99999');
    } else if (_r) {
      // unlisted referrer (google, yahoo, etc)
      // extract domain and truncate it down to 10chars
      _label = _r.match(/^(?:https?:\/\/)?(?:[^@\n]+@)?(?:www\.)?([^:/\n]+)/);
      _label = _label &&
                                  _label[1] &&
                                  _label[1].length ?
        _label[1].slice(0, 10) : _label;
    }

    return _label.trim();
  },

  /**
   * Retrieve a list of Shopping related experiments and their respective
   * variant and experiment IDs  and prep them to be added to Amazon
   * subtags.
   * Example:
   *   Shopping experiments with IDs 12345 and 98765 were running and
   *   user is bucketed in variant IDs 1 and 2 (respective to the experiment IDs).
   *   Combine these IDs into a subtag friendly format, experiment/variant grouped
   *   by colon and multiple experiments separated by semicolon:
   *     Result: 12345:1;98765:2
   *
   * @return {String} - experiment/variant groups
   */
  _getExperiments() {

    var experimentsSubtag = '0:0';
    var currentExperiments = amazonTests.getTestValues();

    if (Array.isArray(currentExperiments) && currentExperiments.length) {
      let experimentsArray = currentExperiments.map(function(ids) {
        return ids.experimentid + ':' + ids.variantid;
      });
      experimentsSubtag = experimentsArray.join(';');
    }

    return experimentsSubtag;
  },

  /**
   * Get shortened name of experiment/variant
   * to include extra amazon subtag info
   * @return {String} - updated src url
   */
  _getSource() {
    let source = solid.isAny(['xs', 'sm']) ? 'm' : 'd';
    if (webview.isIOS()) {
      source = 'ios';
    } else if(webview.isAndroid()) {
      source = 'andr';
    }
    return source;
  },

  /**
   * Escape an arbitrary string to use in regexp
   * @param {String} str  - str to be used in regex
   * @return {String} - escaped string for regex
   */
  _escapeStrRegex(str) {
    return str.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
  },

  /**
   * Replace encoded subtags with updated data
   *
   * Subtag example: 4902451,2,22,d,tp,3,bf-fil-am,578:1
   * 4902451 = Buzz ID of the post
   * 2 = Position of the subbuzz containing this link
   * 22 = Total amount of subbuzzes in the post
   * d = platform, in this case d = desktop
   * tp = module, e.g. tp for trending-product
   * 3 = rank, e.g. the rank of the subbuzz in the trending-product module
   * bf-fil-am = origin value, this can be “0” too if the origin isn’t defined
   * 578:1 = Abeagle ID, first number is the experiment ID, second is the variant ID
   *
   * @param {String} encodedOriginal - a url-encoded comma-separated string representing subtags
   * @param {Object} update - an object referencing which encoded values to replace
   */
  _updateAmazonSubtags(encodedOriginal, update) {
    if (!encodedOriginal || !encodedOriginal.trim().length || !update) {
      return encodedOriginal;
    }
    let subtags = this._decodeAmazonSubtags(encodedOriginal);
    util.each(update, (key, value) => {
      let index = _amazonSubtagIndices[key];
      if ('undefined' !== typeof index) { // key found in indices
        while (subtags.length < index) { // pad array if < index
          subtags.push(0);
        }
        subtags[index] = value;
      }
    });
    const encodedResult = this._encodeAmazonSubtags(subtags);
    if (this._debug()) {
      console.log('Amazon Debug: ', encodedResult);
    }
    return encodedResult;
  },

  _decodeAmazonSubtags(encoded) {
    if (!encoded || !encoded.trim().length) {
      return [];
    }
    return decodeURIComponent(encoded).split(',');
  },

  _encodeAmazonSubtags(decoded) {
    if (!decoded || !decoded.length) {
      return '';
    }
    return encodeURIComponent(decoded.join(','));
  },
};
