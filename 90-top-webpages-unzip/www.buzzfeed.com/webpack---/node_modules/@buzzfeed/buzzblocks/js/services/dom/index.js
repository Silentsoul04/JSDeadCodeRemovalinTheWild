import client from '../client';
/**
 * Finds the closest parent that matches a selector.
 * @see https://github.com/ForbesLindesay/closest
 */
import closest from 'closest';

/**
 * Polyfills the `classList` functionality in IE
 */
function _patchClassList() {
  // polyfill the whole `classList` on SVG elements
  (function() {
    if (document.createElementNS('http://www.w3.org/2000/svg', 'g').classList instanceof DOMTokenList) {
      return;
    }
    try {
      Object.defineProperty(
        SVGElement.prototype,
        'classList',
        Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'classList')
        || Object.getOwnPropertyDescriptor(Element.prototype, 'classList')
      );
    } catch (exc) {}
  })();

  // polyfill multiple arguments to `add` and `remove`
  (function() {
    try {
      const test = document.createElement('div');
      test.classList.add('foo', 'bar');
      if (test.classList.contains('bar')) {
        return;
      }
      const add = DOMTokenList.prototype.add;
      const remove = DOMTokenList.prototype.remove;
      DOMTokenList.prototype.add = function(...tokens) {
        tokens.forEach((token) => add.call(this, token));
      };
      DOMTokenList.prototype.remove = function(...tokens) {
        tokens.forEach((token) => remove.call(this, token));
      };
    } catch (exc) {}
  })();
}
_patchClassList();


function _patchNodeList() {
  if (!NodeList.prototype.forEach) {
    NodeList.prototype.forEach = Array.prototype.forEach;
  }
}
_patchNodeList();


export { closest };

/**
 * Subscribes to `transitionend` event, returns a promise that is resolved when
 * animations on all requested properties have finished.
 * Note that the event will not fire (and so the promise will not resolve)
 * if the final property value is the same as initial
 * or if the transition is aborted before it's completed:
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Transitions/Using_CSS_transitions#Detecting_the_start_and_completion_of_a_transition
 * @param {Element} element - element to be animated
 * @param [options.properties=[]] - array of CSS properties being animated
 * @return {Promise} - promise that is resolved with `TransitionEvent` when animation completes;
 * the promise has additional method `unsubscribe` to remove the event listener
 */
export function detectTransitionEnd(element, {properties = ['any']} = {}) {
  const transitionendEvents = ['transitionend', 'webkitTransitionEnd', 'mozTransitionEnd', 'oTransitionEnd'];
  const resolvers = {};
  const transitions = [];
  properties.forEach((prop) => {
    let resolve;
    const promise = new Promise((r) => resolve = r);
    transitions.push(promise);
    resolvers[prop] = resolve;
  });
  function listener(ev) {
    if ('any' in resolvers) {
      resolvers.any(ev);
      return;
    }
    if (ev.propertyName in resolvers) {
      resolvers[ev.propertyName](ev);
    }
  }
  transitionendEvents.forEach((ev) => element.addEventListener(ev, listener));
  const transition = Promise.all(transitions);
  transition.unsubscribe = function() {
    transitionendEvents.forEach((ev) => element.removeEventListener(ev, listener));
  };
  transition.then(transition.unsubscribe);
  return transition;
}

/**
 * Returns module's config script
 * @param {HTMLElement} element - module's element
 * @param {Boolean} returnElement - whether to return string or HTMLElement
 * @returns {String|HTMLElement} module's config script
 */
export function getModuleConfig(element, returnElement) {
  const configScript = element.querySelector('script');
  if (returnElement) {
    return configScript;
  }
  return configScript ? JSON.parse(configScript.text) : null;
}

export function getViewPosition(el, lookahead, viewportOffset) {
  var rect = el.getBoundingClientRect();
  var viewportHeight = client.getViewportHeight();
  lookahead = lookahead || 0;
  viewportOffset = viewportOffset || 0;

  var lookaheadRange = {
    top: 0 - lookahead,
    bottom: viewportHeight + lookahead,
  };
  var elementPosition = {
    top: rect.top - viewportOffset,
    bottom: rect.bottom - viewportOffset,
  };

  return {
    isHidden: function() {
      return !el.offsetParent;
    },

    isWithinViewport: function() {
      return elementPosition.top >= 0 && elementPosition.bottom <= viewportHeight;
    },

    isWithinLookahead: function() {
      return elementPosition.top >= lookaheadRange.top &&
        elementPosition.bottom <= lookaheadRange.bottom;
    },

    isPartiallyInViewport: function() {
      return (elementPosition.top >= 0 && elementPosition.top <= viewportHeight) ||
        (elementPosition.bottom > 0 && elementPosition.bottom < viewportHeight);
    },

    isPartiallyInLookahead: function() {
      if (elementPosition.top > 0) {
        return elementPosition.top < lookahead + viewportHeight;
      }
      if (elementPosition.bottom > 0) {
        return true;
      }
      return Math.abs(elementPosition.bottom) < lookahead;
    },
    isNearBottom: function() {
      return parseInt(rect.bottom, 10) <= lookahead;
    },
  };
}

export default {
  /**
   * Converts string to DOM nodes.
   * @param {String} string - input HTML string.
   * @returns {NodeList} - list of DOM nodes.
   */
  stringToHTML(string) {
    var container = document.createElement('div');
    container.innerHTML = string;
    return container.childNodes;
  },

  /**
  * Turns a NodeList into a proper array and returns the array.
  * @param {NodeList} nodeList - NodeList to turn into array
  * @returns {Element[]}
  */
  arrayFromNodeList(nodeList) {
    return [].slice.call(nodeList);
  },

  /**
   * Allows a function to be execute over a list of nodes, a node, or a string
   * which will be converted to a node
   * @param {String|NodeList|HTMLElement[]} content - content to be added
   * @param {Function} fn - Function to execute, takes a HTMLElement as an argument
   * @returns {Object} - service object
   */
  withNodeList(content, fn) {
    if (typeof content === 'string') {
      content = this.stringToHTML(content);
    }

    if (content instanceof HTMLElement) {
      content = [content];
    }

    if (content instanceof NodeList || Array.isArray(content)) {
      Array.prototype.slice.call(content).forEach(el => fn(el));
    }
    return this;
  },

  /**
   * Insert content, specified by the parameter, to the end of parent element.
   * @param {HTMLElement} parent - element to add content to
   * @param {String|NodeList|HTMLElement[]} content - content to be added
   * @returns {Object} - service object
   */
  append(parent, content) {
    if (typeof content === 'undefined') {
      content = parent;
      parent = document.body;
    }
    let fn = (el) => parent.appendChild(el);
    return this.withNodeList(content, fn);
  },

  /**
   * Prepend content into the parent after the nth child
   * @param {HTMLElement} parent - element to add content to
   * @param {String|NodeList|HTMLElement[]} content - content to be added
   * @param {Integer} nth - Position to insert after
   * @returns {Object} - service object
   */
  prepend(parent, content, nth = 0) {
    if (typeof content === 'undefined') {
      content = parent;
      parent = document.body;
    }
    let child = parent.children[nth];
    let fn = (el) => parent.insertBefore(el, child);
    return this.withNodeList(content, fn);
  },

  /**
   * Remove elements from DOM
   * @param {...Element} element - elements that need to be removed
   * @returns {Element[]} - array of removed elements
   */
  remove(...elements) {
    let removed = [];
    elements.forEach((el) => {
      if (!(el instanceof Element) || !el.parentNode) {
        return;
      }
      removed.push(el.parentNode.removeChild(el));
    });
    return removed;
  },

  /**
   * Returns child nodes of the element, that match selector.
   * @param {HTMLElement|String} element - parent element.
   * @param {String} selector - filter for child elements.
   * @returns {HTMLElement[]} - matched elements.
   */
  find(element, selector) {
    return Array.prototype.slice.call(element.querySelectorAll(selector));
  },

  /**
   * Returns first child node of the `element`, that match `selector`.
   * @param {HTMLElement|String} element - parent element.
   * @param {String} selector - filter for child element.
   * @returns {HTMLElement} - matched element
   */
  findOne(element, selector) {
    return element.querySelector(selector);
  },

  /**
   * Gets the first element that matches the selector.
   * Tests the element itself and traverses up through its ancestors.
   * @param {HTMLElement} element - starting element.
   * @param {String} selector - selector to match elements against.
   * @returns {HTMLElement[]} - matched elements.
   */
  closest(element, selector) {
    // third argument is a flag to test the target element itself
    return closest(element, selector, true);
  },

  /**
   * Adds class to specified element(s).
   * @param {HTMLElement|HTMLElement[]} elements - target node(s).
   * @param {String} className - class name to add. Multiple classes are separated by space.
   * @returns {void}
   */
  addClass(elements, className) {
    if (!Array.isArray(elements)) {
      elements = [elements, ];
    }
    let classNames = className.split(' ');
    elements.forEach(
      // not using `el.classList.add(...classNames)` as it's not supported by IE
      el => classNames.forEach((cls) => el.classList.add(cls))
    );
  },

  /**
   * Removes class from specified element(s).
   * @param {HTMLElement|HTMLElement[]} elements - target node(s).
   * @param {String} className - class name to remove. Multiple classes are separated by space.
   * @returns {void}
   */
  removeClass(elements, className) {
    if (!Array.isArray(elements)) {
      elements = [elements, ];
    }
    let classNames = className.split(' ');
    elements.forEach(
      // not using `el.classList.remove(...classNames)` as it's not supported by IE
      el => classNames.forEach((cls) => el.classList.remove(cls))
    );
  },

  /**
   * Determine whether any of elements are assigned the given class.
   * @param {HTMLElement|HTMLElement[]} elements - target node(s).
   * @param {String} className - class name to check.
   * @returns {Boolean} - whether any of elements are assigned the given class.
   */
  hasClass(elements, className) {
    if (!Array.isArray(elements)) {
      elements = [elements, ];
    }

    return elements.some(el => el.classList.contains(className));
  },

  /**
   * Add or remove one or more classes from each element in the set of matched elements.
   * @param {HTMLElement|HTMLElement[]} elements - target element(s).
   * @param {String} className - one or more class names (separated by spaces).
   * @param {Boolean} state - determines whether the class should be added or removed
   * @return {void}
   */
  toggleClass(elements, className) {
    if (!Array.isArray(elements)) {
      elements = [elements, ];
    }

    if (typeof elements === 'string') {
      // @todo this route should not be used
      elements = this.find(elements);
    }

    className.split(' ').forEach(name => elements.forEach(el => el.classList.toggle(name)));
  },

  /**
   * Returns `true` if the element would be selected by the specified selector string; otherwise, returns `false`
   * @param {Element} element - element to test
   * @param {String} selector - selector to apply
   * @param {Boolean} whether element matches selector
   */
  matches: (() => {
    const elProto = Element.prototype;
    const matches = (
      elProto.matches
      || elProto.webkitMatchesSelector
      || elProto.mozMatchesSelector
      || elProto.msMatchesSelector
      || function(selector) {
        return [].indexOf.call(document.querySelectorAll(selector), this) > -1;
      }
    );
    return (element, selector) => matches.call(element, selector);
  })(),

  getViewPosition,

  /**
   * Adds event listener.
   * @param {EventTarget} target - target for event listening.
   * @param {String} ev - event name. Multiple event names are separated by space.
   * @param {Object} data - object containing data that the callback can use.
   * @param {Function} handler - event handler.
   * @return {void}
   */
  on(target, ev, data, handler) {
    if (typeof data === 'function' && typeof handler === 'undefined') {
      handler = data;
      data = null;
    }

    ev.split(' ').forEach(e => target.addEventListener(e, handler));
  },

  /**
   * Adds event listener.
   * @param {EventTarget} target - target for event listening.
   * @param {String} ev - event name. Multiple event names are separated by space.
   * @param {Object} data - object containing data that the callback can use.
   * @param {Function} handler - event handler.
   * @return {Function} handler wrapper to pass to `dom.off` if need be
   */
  one(target, ev, data, handler) {
    const self = this;
    if (typeof data === 'function') {
      handler = data;
      data = null;
    }

    const once = function(e) {
      handler.call(this, e);
      self.off(target, ev, once);
    };

    self.on(target, ev, once);

    // in case the event didn't fire and removing the listener manually is needed
    return once;
  },

  /**
   * Removes event listener.
   * @param {EventTarget} target - target for event listening.
   * @param {String} ev - event name. Multiple event names are separated by space.
   * @param {Function} handler - event handler.
   * @return {void}
   */
  off(target, ev, handler) {
    ev.split(' ').forEach(e => target.removeEventListener(e, handler));
  },

  /**
   * Triggers event listener.
   * Fails silently if document.createEvent or event.initEvent are not available
   * @param {EventTarget} target - target for event listening.
   * @param {String} ev - event name. Multiple event names are separated by space.
   * @return {void}
   */
  trigger(target, ev) {
    if (document.createEvent) {
      ev.split(' ').forEach(e => {
        let event = document.createEvent('Event');
        if (event.initEvent) {
          event.initEvent(e, false, true);
          target.dispatchEvent(event);
        }
      });
    }
  },

  /**
   * Hide `el` element.
   * @param {HTMLElement} el - element to hide
   * @param {String} [selector] - if set - result of `.find(el, selector)` will be used as `el`
   * @returns {Object} service object for chaining
   */
  hide(el, selector) {
    var element = selector ? this.find(el, selector) : el;
    this.addClass(element, 'js-hidden');
    return this;
  },

  /**
   * Display `el` element.
   * @param {HTMLElement} el - element to show
   * @param {String} [selector] - if set - result of `.find(el, selector)` will be used as `el`
   * @returns {Object} service object for chaining
   */
  show(el, selector) {
    var elements = selector ? this.find(el, selector) : el;
    if (this.hasClass(elements, 'js-hidden')) {
      this.removeClass(elements, 'js-hidden');
    } else {
      if (!Array.isArray(elements)) {
        elements = [elements];
      }
      elements.forEach(elem => this.setStyle(elem, { display: 'block' }));
    }
    return this;
  },

  /**
   * Returns value of data in given element.
   * @param {HTMLElement|String} element - element.
   * @param {String} str - name of data parameter.
   * @returns {String} - value of data-attr.
   */
  getData(element, str) {
    if (typeof element === 'string') {
      element = this.stringToHTML(element)[0];
    }
    return element.getAttribute(`data-${str}`);
  },

  /**
   * Sets value for data in given element.
   * @param {HTMLElement|String} element - element.
   * @param {String} str - name of data parameter.
   * @param {String} val - value of data parameter.
   * @returns {Bool} - TRUE if success, FALSE on error
   */
  setData(element, str, val) {
    if (typeof element === 'string') {
      element = this.stringToHTML(element)[0];
    }
    element.setAttribute(`data-${str}`, val);
    return true;
  },

  /**
   * @description Gets value of specific style property
   * @param {HTMLElement} el - Element to get style property for
   * @param {String} styleName - Style property key
   * @returns {String} - Style property value
   */
  getStyle(el, styleName) {
    return el.style[styleName];
  },

  /**
   * @description Sets styles on an element
   * @param {HTMLElement} el - Element to set style for
   * @param {Object} styles An object which maps CSS style names to values
   * @returns {Object} - service object
   */
  setStyle(el, styles) {
    for (let key in styles) {
      if (styles.hasOwnProperty(key)) {
        el.style[key] = styles[key];
      }
    }
    return this;
  },

  /**
   * Get the value of an attribute for `el` element
   * @param {HTMLElement} el - Element to get attribute from
   * @param {String} attributeName - The name of the attribute to get.
   * @returns {String} - attribute value
   */
  getAttr(el, attributeName) {
    return el.getAttribute(attributeName);
  },

  /**
   * Set one or more attributes for `el` element
   * @param {HTMLElement} el - Element to set attributes for
   * @param {Object} attributes - An object of attribute-value pairs to set.
   * @returns {Object} - service object
   */
  setAttr(el, attributes) {
    for (let key in attributes) {
      if (attributes.hasOwnProperty(key)) {
        el.setAttribute(key, attributes[key]);
      }
    }
    return this;
  },

  /**
   * Delete an attribute for `el` element
   * @param {HTMLElement} el - Element to delete attributes for
   * @param {Object} attributeName - the name of the attribute to rename.
   * @returns {Object} - service object
   */
  removeAttr(el, attributeName) {
    el.removeAttribute(attributeName);
    return this;
  },

  /**
   * Indicates whether a specified element has a specified attribute or not.
   * @param {HTMLElement} el - target element.
   * @param {String} attributeName - the name of the attribute to check.
   * @return {Boolean} - result.
   */
  hasAttr(el, attributeName) {
    return el.hasAttribute(attributeName);
  },

  /**
   * Get text of `el` element or its child(if `selector` is set)
   * @param {HTMLElement} el - element to set text to
   * @param {String} [selector] - if set - result of `.find(el, selector)` will be used as `el`
   * @returns {String} text of element
   */
  getText(el, selector) {
    var element = selector ? this.findOne(el, selector) : el;
    return element ? element.textContent : '';
  },

  /**
   * Set text for `el` element or its child(if `selector` is set)
   * @param {HTMLElement} el - element to set text to
   * @param {String} text - text to be set
   * @param {String} [selector] - if set - result of `.find(el, selector)` will be used as `el`
   * @returns {Object} service for chaining
   */
  setText(el, text, selector) {
    var element = selector ? this.findOne(el, selector) : el;
    if (element) {
      element.textContent = text;
    }
    return this;
  },

  /**
   * Set HTML for `el` element or its child(if `selector` is set)
   * @param {HTMLElement} el - element to set text to
   * @param {String} html - HTML to be set
   * @param {String} [selector] - if set - result of `.find(el, selector)` will be used as `el`
   * @returns {Object} service for chaining
   */
  setHTML(el, html, selector) {
    var element = selector ? this.findOne(el, selector) : el;
    if (element) {
      element.innerHTML = html;
    }
    return this;
  },

  /**
   * Get parent elements filtered by slector
   * @param {HTMLElement} el - element to search parents for
   * @param {String} selector - selector to match parent elements against
   * @returns {HTMLElement[]} - matched elements.
   */
  parent(el, selector) {
    return closest(el, selector);
  },

  getModuleConfig,

  /**
   * Creates HTML element.
   * @param {String} tag - tag name for the HTML element.
   * @param {Object} [attributes] - map of attribute names/values for the element.
   * @return {*|Element} - new HTML element.
   */
  createElement(tag, attributes) {
    var el = document.createElement(tag);
    this.setAttr(el, attributes);
    return el;
  },

  /**
   * Scrolls specified HTML element into view.
   * @param {HTMLElement} element - target HTML element.
   * @param {Number} [delay] - time in ms before scroll occurs.
   * @return {void}
   */
  scrollIntoView(element, delay) {
    const self = this;
    if (delay) {
      setTimeout(function() {
        self.scrollIntoView(element);
      }, delay);
    } else if (element.scrollIntoView) {
      element.scrollIntoView();
    } else {
      window.scrollTo(0, element.offsetTop);
    }
  },

  offset(el, selector) {
    var element = selector ? this.findOne(el, selector) : el;
    if (!element) {
      return {};
    }

    return {
      top: element.offsetTop,
      left: element.offsetLeft
    };
  },

  /**
   * Returns the size of element.
   * @param {HTMLElement} element - normalized dom element.
   * @returns {Object} - size of element {width, height}
   */
  size(element) {
    return {
      width: element.offsetWidth,
      height: element.offsetHeight
    };
  },

  detectTransitionEnd,
};
