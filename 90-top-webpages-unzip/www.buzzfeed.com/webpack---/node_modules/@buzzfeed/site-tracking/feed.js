import solid from '@buzzfeed/buzzblocks/js/services/solid';
import localization from '@buzzfeed/buzzblocks/js/services/localization';

// unit fields exist to ensure consistent naming between our tags and what BFA
// expects when mapping
const UNIT_FIELDS = {
  id: 'id',
  type: 'type',
  contentCategory: 'contentCategory',
  unit: 'unit',
  unitType: 'unitType',
  unitName: 'unit_name',
  // TODO: Remove `position` once we have transitioned to v2 schema (becomes `position_in_unit`)
  position: 'position',
  positionInUnit: 'position_in_unit',
  dataSource: 'dataSource',
  subUnit: 'subUnit',
  variationId: 'variationId',
};

/**
 * mapIsFeed is used in the condition for createConfigForRoute to determine if
 * a given tracked element is a 'Feed'
 *
 * @param {Object} a src object
 * @returns {bool} if the router is a feed
 */
const mapIsFeed = src => src.l === 'Feed' && src.n === 'FeedItem';

/**
 * bfaTagger should be called within an open element, it will inject two
 * attributes that will prepare it for tracking
 *
 * @param {string} unitType - the name of the unit's type (for added context when tracking)
 * @param {string} unit - the name of the unit (for tracking)
 * @param {Object} item - the item
 * @param {string} unitName - the name of the unit and subunit (for added context when tracking new pixiedust events)
 */
export const bfaTagger = (unitType, unit, item, unitName) => {
  if (!unit) {
    throw new Error('unit must be specified for tracking');
  }

  // variationId is set here:
  // https://github.com/buzzfeed/mono/blob/master/packages/frontend/buzzblocks/js/services/flexpro/index.js#L17
  return `
    data-bfa-impressions="true"
    data-bfa="@a:FeedItem; @e:{ ${UNIT_FIELDS.id}:${item.id},
                                ${UNIT_FIELDS.type}:${item.type || 'buzz'},
                                ${UNIT_FIELDS.contentCategory}:${item.category || ''},
                                ${UNIT_FIELDS.unit}:${unit},
                                ${UNIT_FIELDS.unitType}:${unitType},
                                ${UNIT_FIELDS.unitName}:${unitName},
                                ${UNIT_FIELDS.position}:${item.number || item.position || -1},
                                ${UNIT_FIELDS.positionInUnit}:${item.position},
                                ${UNIT_FIELDS.dataSource}:${item.dataSource || item.data_source},
                                ${UNIT_FIELDS.subUnit}:${item.sub_unit || ''},
                                ${UNIT_FIELDS.variationId}:${item.variationId || ''}
                              };"
  `;
};

/**
 * pixiedustFeedTrackingMapper takes a bfa mapper and sets up click and
 * impression events on feeds
 *
 * @param {Object} mapper (BFA mapper)
 */
export const pixiedustFeedTrackingMapper = mapper => {
  let feedTmpl = mapper.createMapTemplate('feedTmpl');

  // items tracked from page and inferred attributes
  feedTmpl.addMapTo('page_edition', localization.getEdition());
  feedTmpl.addMapTo('page_type').mapFrom('data.page.type');
  feedTmpl.addMapTo('page').mapFrom('data.page.type'); // same as page_type
  feedTmpl.addMapTo('page_url').mapFrom('data.page.uri.path');
  feedTmpl.addMapTo('author').mapFrom('data.page.post.author');
  feedTmpl.addMapTo('author_id').mapFrom('data.page.post.authorId');
  feedTmpl.addMapTo('post_category').mapFrom('data.page.category');
  feedTmpl.addMapTo('mode', solid.isXsmall() || solid.isSmall() ? 'mobile' : 'desktop');

  const data = prop => ev => ev.data[prop];

  // items tracked from the BFA tags on each feed element
  feedTmpl.addMapTo('content_id').mapFrom(src => `${src.data[UNIT_FIELDS.type] || 'buzz'}:${src.data[UNIT_FIELDS.id]}`);
  feedTmpl.addMapTo('content_category').mapFrom(data(UNIT_FIELDS.contentCategory));
  feedTmpl.addMapTo('unit').mapFrom(data(UNIT_FIELDS.unit));
  feedTmpl.addMapTo('unitType').mapFrom(data(UNIT_FIELDS.unitType));
  feedTmpl.addMapTo('position').mapFrom(data(UNIT_FIELDS.position));
  feedTmpl.addMapTo('data_source').mapFrom(data(UNIT_FIELDS.dataSource));
  feedTmpl.addMapTo('sub_unit').mapFrom(data(UNIT_FIELDS.subUnit));
  feedTmpl.addMapTo('variation_id').mapFrom(data(UNIT_FIELDS.variationId));

  let feedClickMapper = mapper.getOrCreateRouter('track/click').createConfigForRoute(mapIsFeed);
  feedClickMapper.applyTemplateByName('feedTmpl');
  feedClickMapper.addMapTo('type', 'unit_click');

  let feedImpressionMapper = mapper.getOrCreateRouter('track/scroll/impression').createConfigForRoute(mapIsFeed);
  feedImpressionMapper.applyTemplateByName('feedTmpl');
  feedImpressionMapper.addMapTo('type', 'unit_impression');
};

/**
 * gaFeedTrackingMapper takes a bfa mapper and sets up click and
 * impression events on feeds
 *
 * @param {Object} mapper (BFA mapper)
 * @param {Bool} impressions (defaults to false, if true will track impressions under "impression" action)
 */
export const gaFeedTrackingMapper = (mapper, impressions = false) => {
  let gaFeedTmpl = mapper.createMapTemplate('gaFeedTmpl');

  gaFeedTmpl.addMapTo('category').mapFrom(src => `${src.data[UNIT_FIELDS.unitType]}:${src.data[UNIT_FIELDS.unit]}`);
  gaFeedTmpl.addMapTo('label').mapFrom(src => `${src.data[UNIT_FIELDS.type] || 'buzz'}:${src.data[UNIT_FIELDS.id]}`);
  gaFeedTmpl.addMapTo('value').mapFrom(src => src.data[UNIT_FIELDS.position]);

  let feedClickMapper = mapper.getOrCreateRouter('track/click').createConfigForRoute(mapIsFeed);
  feedClickMapper.applyTemplateByName('gaFeedTmpl');
  feedClickMapper.addMapTo('action', 'click');

  if (impressions) {
    let feedImpressionMapper = mapper.getOrCreateRouter('track/scroll/impression').createConfigForRoute(mapIsFeed);
    feedImpressionMapper.applyTemplateByName('gaFeedTmpl');
    feedImpressionMapper.addMapTo('action', 'impression');
  }
};
