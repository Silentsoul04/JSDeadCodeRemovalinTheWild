import defaults from 'lodash/defaults';
import uniq from 'lodash/uniq';
import flatten from 'lodash/flatten';
import extend from 'lodash/extend';
import settings from '../settings';

var DELIMITER = '\v';

// replaces null or undefined values with empty string
function replaceEmptyValues(obj) {
    return Object.keys(obj).reduce(function(dest, key) {
        var val = obj[key];
        val = val === null || val === undefined ? '' : val;
        dest[key] = val;
        return dest;
    }, {});
}

export function PixelDispatch() {

    var sessionVars = {};

    return {
        queue: [],
        timeout: null,
        history: [],

        /**
         * push() is used to track a single event. It takes an object with a
         * `type` key along with any other metadata to collect about the event
         * as keys of the object. Returns true if there are no problems with the
         * data (i.e. the data doesn't create a too long of a URL)
         *
         * @param {Object} data
         * @return {Boolean}
         */
        push: function(_data) {
            var data = defaults({}, _data, sessionVars);

            if (!this.validateData(data)) {
                return false;
            }

            // Simple way to batch by `type`. If the type of the current
            // event doesn't match the event before it, send the existing batch
            // and then push the current event
            var lastData = this.queue[this.queue.length - 1];
            if (lastData && lastData['type'] !== data['type']) {
                this.sendData();
                this.push(data);
                return true;
            }

            this.queue.push(data);
            var url = this.getURL(this.queue);
            if (url.length > settings.get('urlLengthLimit')) {
                this.queue.pop();
                this.sendData();
                this.push(data);
                return true;
            }

            if (!settings.get('batch')) {
                this.sendData();
            } else if (!this.timeout) {
                this.timeout = setTimeout(this.sendData.bind(this), settings.get('delay'));
            }

            return true;
        },

        /**
         * validateData() ensures that all required fields are present before adding
         * to the queue, that all fields are acceptable data types, and that the event
         * does not cause the resulting URL to exceed the length limit
         *
         * @param {Object} data
         * @return {Boolean}
         */
        validateData: function(data) {
            var requiredFields = settings.get('requiredFields');
            for (var i = 0, len = requiredFields.length; i < len; i++) {
                if (!(requiredFields[i] in data)) {
                    if (settings.get('debug')) {
                        throw new Error('Pixiedust required event field: ' + requiredFields[i]);
                    }
                    return false;
                }
            }

            var acceptedTypes = settings.get('acceptedDataTypes');
            for (var field in data) {
                var value = data[field];
                var dataType = typeof data[field];
                if (!(value === null) && !(value === undefined)
                    && acceptedTypes.indexOf(dataType) === -1) {
                    if (settings.get('debug')) {
                        throw new Error('Pixiedust: field "' + field + '" is invalid data type: ' + dataType); // eslint-disable-line max-len
                    }
                    return false;
                }
            }

            var url = this.getURL([data]);
            if (url.length > settings.get('urlLengthLimit')) {
                if (settings.get('debug')) {
                    throw new Error('Pixiedust: single event exceeds url length limit', data);
                }
                return false;
            }

            return true;
        },

        /**
         * sendData() sends the data in the queue, clears the timeout,
         * and resets the queue
         */
        sendData: function() {
            var url;
            if (this.queue && this.queue.length) {
                url = this.getURL(this.queue);
                this.createPixel(url);
                this.history.push(url);
            }
            this.queue = [];
            clearTimeout(this.timeout);
            this.timeout = null;
        },

        /**
         * createPixel() makes a GET request to the given url by creating an
         * `img` element in memory and setting its src to the url
         *
         * @param {String} url
         */
        // TODO: listen for errors
        createPixel: function(url) {
            (new Image()).src = url;
        },


        /**
         * getURL() creates a URL where event metadata is grouped by query param
         * and is comma-separated for batched requests.
         *
         * @param {Array} events
         * @return {String}
         */
        getURL: function(events) {
            var keys = uniq(flatten(events.map(Object.keys)));

            events.forEach(function(event) {
                Object.keys(event).forEach(function(key) {
                    var val = event[key];
                    if (val === null || val === undefined) {
                        event[key] = '';
                    }
                });
            });
            events = events.map(replaceEmptyValues);

            var queryParams = keys.reduce(function(dest, key) {
                dest[key] = events.map(function(event) { return event[key]; });
                return dest;
            }, {});

            queryParams['_z'] = Date.now();
            queryParams['_d'] = DELIMITER;
            queryParams['_n'] = events.length;

            var params = Object.keys(queryParams).map(function(param) {
                var values = queryParams[param];
                values = Array.isArray(values) ? values : [values];
                return encodeURIComponent(param) + '=' + encodeURIComponent(values.join(DELIMITER));
            });

            return this.url() + '?' + params.join('&');
        },

        /**
         * setSessionVars() is used to set attributes that should be passed in
         * with every event that is tracked.
         *
         * @param {Object}
         */
        setSessionVars: function(attrs) {
            // set null and undefined vals to empty string
            Object.keys(attrs).forEach(function(key) {
                var val = attrs[key];
                if (val === null || val === undefined) {
                    attrs[key] = '';
                }
            });
            sessionVars = extend(sessionVars, replaceEmptyValues(attrs));
        },

        url: function() {
            return settings.get('trackingURL') + '/v' + settings.get('apiVersion') + '.gif';
        },

        getHistory: function() {
            return this.history.slice();
        }
    };
}
