import { XDomainCookieManager, uuid4 } from '@buzzfeed/bf-utils';
import settings from './settings';
import version from './version';
import { PixelDispatch } from './dispatch/index';

var Pixiedust = function({ dispatch } = {}) {
    this.enabled = false;
    this.started = false;
    this.version = version;
    this.dispatch = dispatch || new PixelDispatch();

    // queue stores events until pixiedust is enabled with start()
    this.queue = [];
};

/**
 * push() is used to track a single event. It takes an object with a
 * `type` key along with any other metadata to collect about the event
 * as keys of the object. Returns true if there are no problems with the
 * data (i.e. the data doesn't create a too long of a URL)
 *
 * @param {Object}
 * @return {Boolean}
 */
Pixiedust.prototype.push = function(data) {

    if (this.started && this.enabled) {
        // Everytime we push, we should see if the session needs updating
        // This is a non-ideal implementation where the session ID will lag
        // behind one event potentially, but prevents our dispatch from being
        // asynchronous.
        this.updateSessionUuid();
        data['visit_id'] = this.sessionUuid;
        return this.dispatch.push(data);
    }
    this.queue.push(data);
    return true;
};

/**
 * start() is used to set up `env` and `samplingRate` and to indicate that
 * the pixiedust instance may start sending data to the Pixiedust API. The
 * pixiedust instance may be used for pushing events before start() is called.
 * The instance will send any queued event data on start(). This method may
 * only be called once.
 *
 * @param {Object}
 */
Pixiedust.prototype.start = function(opts, startedHandler) {
    if (this.started) {
        if (settings.get('debug')) {
            throw new Error('Pixiedust instance may only be started once');
        }
        return;
    }

    opts = opts || {};
    settings.init(opts['env']);
    settings.set({
        'samplingRate': opts['sampling_rate'],
        'requiredFields': opts['required_fields']
    });

    // use sampling rate to decide if this session should be tracked
    this.enabled = Math.random() < settings.get('samplingRate');

    if (settings.get('debug')) {
        this.setupTestMethods();
    }

    if (this.enabled) {
        let xDomainEnv = opts['env'] === 'live' ? 'prod' : opts['env'];
        this.sessionUuidCookieManager = new XDomainCookieManager({
            env: xDomainEnv,
            namespace: 'bf-xdomain-tracking',
            cookieName: 'bf-xdomain-session-uuid',
            daysExpiry: 0.5 / 24, // Half hour
            throttleTimer: 1000 * 60 * 3, // 3 minutes
        });
        this.updateSessionUuid().then(() => {
            this.started = true;
            while (this.queue.length) {
                this.push(this.queue.shift());
            }
            if (startedHandler) {
                startedHandler();
            }
        });
    }
};

Pixiedust.prototype.updateSessionUuid = function() {
    return this.sessionUuidCookieManager.get().then((sessionUuid) => {
        this.sessionUuid = sessionUuid || uuid4();
        // Anytime we update, we should reset to refresh the expiry
        this.sessionUuidCookieManager.set(this.sessionUuid);
    }).catch((error) => {
        console.log(`Error getting session UUID: ${error}`);
    });
};

Pixiedust.prototype.setupTestMethods = function() {
    this.__testHistory = function() {
        if (!this.enabled) {
            if (settings.get('debug')) {
                throw new Error('Pixiedust is not enabled (perhaps due to sampling)');
            }
        }
        return this.dispatch.getHistory();
    };
};

Pixiedust.prototype.setSessionVars = function(attrs) {
    return this.dispatch.setSessionVars(attrs);
};

Pixiedust.prototype.flush = function() {
    return this.dispatch.sendData();
};

export default Pixiedust;
