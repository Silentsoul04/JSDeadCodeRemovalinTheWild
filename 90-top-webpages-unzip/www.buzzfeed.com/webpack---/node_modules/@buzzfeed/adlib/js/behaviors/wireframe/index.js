import { Application } from 't3js';
import { detectTransitionEnd } from '@buzzfeed/buzzblocks/js/services/dom';
import ads from '../../../core/ads';
import { thumbnailReady } from '../../services/thumbnail-ready';


/**
 * Behavior for ad wireframes.
 */
class AdWireframe {
  constructor(context) {
    this.context = context;
    this.element = context.getElement();
    this.config = context.getConfig() || {};
    const wid = this.wid = this.config.wid;

    this.onmessage = {
      [`ad-wireframe-collapse-start-${wid}`]: this._onCollapseStart,
      [`ad-wireframe-no-collapse-${wid}`]: this._onNoCollapse,
      [`ad-content-rendered-${wid}`]: this._loadAd
    };

    // fix max width and height for programmatic wireframes
    if (
      (!this.config.platform || this.config.platform === 'autodetect')
      && this.element.parentElement
      && this.element.parentElement.classList.contains('ad-wireframe-wrapper')
    ) {
      let viewportWidth = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
      let sizes = this.config.size.filter(s => Array.isArray(s) && s[0] <= viewportWidth);
      this._setWireframeSizes({
        width: Math.max.apply(null, sizes.map(s => s[0])),
        height: this.config.forceWireframeHeight || Math.max.apply(null, sizes.map(s => s[1]))
      });
    }
  }

  /**
   * Set data-wireframe-width and data-wireframe-height to adjust size of programmatic wireframes
   * @param {Object} width (max wireframe width), height (max wireframe height)
   * @returns {Void}
   */
  _setWireframeSizes({width, height}) {
    const wireframeElement = this.element.parentElement;
    if (
      !wireframeElement.classList.contains('ad-wireframe-wrapper')
      || (width === 1 && height === 1)
      || !Number.isInteger(width)
      || !Number.isInteger(height)
    ) {
      return;
    }
    wireframeElement.dataset.wireframeWidth = width;
    wireframeElement.dataset.wireframeHeight = height;
  }

  /**
   * Removes wireframe if ad will not be collapsed.
   * @memberOf behavior:ad-wireframe
   * @return {void}
   */
  _onNoCollapse() {
    this._thumbnailReady = thumbnailReady(this.element);
    this._thumbnailReady.then(() => this._loadAd());
  }

  /**
   * Fades in ad and removes wireframe when ad is loaded.
   * @memberOf behavior:ad-wireframe
   * @return {void}
   */
  _loadAd() {
    if (this._thumbnailReady) {
      this._thumbnailReady.unsubscribe();
    }
    this._loadAdProgress = detectTransitionEnd(this.element);
    this._loadAdProgress.then(() => {
      Application.broadcast(`ad-wireframe-fadein-finish-${this.wid}`);
    });

    this._adFadeIn();
    this._removeWireframe();
    this.element.classList.add('ad--loaded');
  }

  /**
   * Initiates wireframe collapse and removal.
   * @memberOf behavior:ad-wireframe
   * @return {void}
   */
  _onCollapseStart() {
    if (this.element.parentElement && this.element.parentElement.classList.contains('ad-wireframe-wrapper')) {
      this.element.parentElement.classList.add('ad-wireframe-wrapper--hidden');
      return;
    }
    this._setUpTransitionDetection();
    // collapse wireframe horizontally
    if (this.element.classList.contains('ad-fadeleft')) {
      this._collapseLeft();

    // collapse wireframe vertically by default
    } else {
      this.element.classList.add('ad-fadeup');
      this._collapseUp();
    }
  }

  /**
   * Collapses wireframe horizontally.
   * @memberOf behavior:ad-wireframe
   * @return {void}
   */
  _collapseLeft() {
    this.element.classList.add('ad-wireframe--collapse-horizontal');
  }

  /**
   * Collapses wireframe vertically.
   * @memberOf behavior:ad-wireframe
   * @return {void}
   */
  _collapseUp() {
    this.element.classList.add('ad-wireframe--collapse-vertical');
  }

  /**
   * Fades in ad data.
   * @memberOf behavior:ad-wireframe
   * @returns {Promise}
   */
  _adFadeIn() {
    // hide ad-wireframe-text elements
    this.element.querySelectorAll('.ad-wireframe-text').forEach((textElem) => {
      textElem.style.display = 'none';
    });
    // show ad-fade elements
    this.element.querySelectorAll('.ad-fade').forEach((fadeElem) => {
      if (fadeElem.offsetParent === null) {
        fadeElem.classList.remove('ad-fade');
      } else {
        const transition = detectTransitionEnd(fadeElem, {properties: ['opacity']});
        const onTransitionEnd = () => {
          fadeElem.classList.remove('ad-fade');
          transition.unsubscribe();
        };
        transition.then(onTransitionEnd);
        fadeElem.style.opacity = 1.0;
        // Force trigger event in case transitionend event does not fire
        setTimeout(onTransitionEnd, 500);
      }
    });
  }

  /**
   * Sets up event listener to detect wireframe-related css transitions.
   * @memberOf behavior:ad-wireframe
   * @returns {void}
   */
  _setUpTransitionDetection() {
    detectTransitionEnd(this.element, {properties: ['opacity']}).then(() => {
      this._removeWireframeAndHide();
    });
  }

  /**
   * Removes and hides wireframe after transitions have completed.
   * @memberOf behavior:ad-wireframe
   * @returns {void}
   */
  _removeWireframeAndHide() {
    this._removeWireframe(true);
  }

  /**
   * Removes wireframe after transitions have completed.
   * @memberOf behavior:ad-wireframe
   * @param {boolean} collapse - whether or not wireframe is being collapsed
   * @returns {void}
   */
  _removeWireframe(collapse = false) {
    this._removeWireframeClasses(this.element, collapse);
    if (collapse) {
      this.element.classList.add('js-hidden');
      Application.broadcast(`ad-wireframe-collapse-finish-${this.wid}`);
    }
  }

  /**
   * Removes wireframe classes beginning with ad-wireframe* or ad-fade*.
   * @memberOf behavior:ad-wireframe
   * @param {HTMLElement} element - element for whom classes should be removed
   * @param {boolean} collapse - whether or not the ad is being collapsed
   * @returns {void}
   */
  _removeWireframeClasses(element, collapse) {
    if (typeof element.className === 'string') {
      // remove ad-wireframe* classes
      element.className = element.className.replace(/\bad-wireframe[-\S]*/g, '');
      // remove ad-fade* classes
      element.className = element.className.replace(/\bad-fade[-\S]+/g, '');
      if (collapse) {
        element.className = element.className.replace(/\bad-fade/g, '');
      }
    }
    // processes child nodes recursively
    if (element.children) {
      for (let i = 0; i < element.children.length; i++) {
        let child = element.children[i];
        this._removeWireframeClasses(child, collapse);
      }
    }
  }

  /**
   * Initiates broadcast to collapse wireframe when slot is rendered.
   * @memberOf behavior:ad-wireframe
   * @return {void}
   */
  _broadcastOnRender(gptEv) {
    const wid = this.wid;
    if (gptEv.isEmpty) {
      Application.broadcast(`ad-wireframe-collapse-start-${wid}`);
    } else {
      Application.broadcast(`ad-wireframe-no-collapse-${wid}`);
    }
  }

  /**
   * Behavior's initialization logic
   * @ignore
   * @returns {void}
   */
  init() {
    if (!this.wid) {
      this.destroy();
      return;
    }

    this._broadcastOnRenderBound = this._broadcastOnRender.bind(this);
    ads.addSlotRenderEndedHandler(this.wid, this._broadcastOnRenderBound);
    ads.detectAdBlock().then(blocked => {
      if (blocked) {
        this._onCollapseStart();
      }
    }).catch(() => this._onCollapseStart());
  }

  /**
   * Cleanup
   * @ignore
   * @returns {void}
   */
  destroy() {
    ads.removeSlotRenderEndedHandler(this.wid, this._broadcastOnRenderBound);
    delete this._broadcastOnRenderBound;
    if (this._thumbnailReady) {
      this._thumbnailReady.unsubscribe();
    }
    if (this._loadAdProgress) {
      this._loadAdProgress.unsubscribe();
    }
    this.element = null;
    this.config = null;
    this.wid = null;
    this.onmessage = {};
  }
}

Application.addBehavior('ad-wireframe', context => new AdWireframe(context));

export const name = 'ad-wireframe';

export default AdWireframe;
