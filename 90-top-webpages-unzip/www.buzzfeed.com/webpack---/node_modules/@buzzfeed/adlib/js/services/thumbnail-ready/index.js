import { getBaseUrl } from '@buzzfeed/bf-utils/lib/query-string';

// js-ad-thumbnail is preferred, but also support userwidget classes for now
const thumbnailSelector = [
  '.js-ad-thumbnail',
  '.bf-image',
  '.bf-image-big',
  '.bf-image-dblbig',
  '.bf-mobile-image',
  '.bf-bg-image',
  '.bf-image-bigstory',
  '.bf-image-dblwidestory',
  '.bf-image-dblbigstory',
  '.bf-image-widestory'
].join(',');

export function checkImgReady(img) {
  // treating `data:image` src as a 1x1 transparent placeholder
  if (!img.src || /^data:image/.test(img.src)) {
    return null;
  }

  let onLoad;
  let unsubscribeRoutine = [];

  // remove query params (like `resize`, `output-quality` etc.) from src
  const format = getBaseUrl(img.src)
    // get file extension
    .split('.').pop();

  const ready = new Promise(function checker(resolve) {
    // if image is already loaded, resolve immediately
    if (img.complete) {
      resolve();
    // if it's a GIF, resolve as soon as image dimensions are known (do not wait for complete `load`)
    } else if (/^gif$/i.test(format)) {
      if (img.naturalHeight) {
        resolve();
      } else {
        // have to use `setTimeout` as images don't have `readystatechange` event or anything like that
        let timeoutId = setTimeout(() => { checker(resolve); }, 100);
        unsubscribeRoutine.push(() => clearTimeout(timeoutId));
      }
    // if image is not loaded and `load` handler is not yet attached, wait for `load` event
    } else if (!onLoad) {
      onLoad = () => {
        resolve();
        img.removeEventListener('load', onLoad);
        img.removeEventListener('error', onLoad);
      };
      img.addEventListener('load', onLoad);
      img.addEventListener('error', onLoad);
      unsubscribeRoutine.push(() => {
        img.removeEventListener('load', onLoad);
        img.removeEventListener('error', onLoad);
      });
    }
  });

  ready.unsubscribe = () => {
    unsubscribeRoutine.forEach((fn) => fn());
    unsubscribeRoutine = [];
  };

  return ready;
}

export function checkVideoReady(video) {
  let onMetadata;
  const ready = new Promise((resolve) => {
    if (video.readyState >= HTMLVideoElement.HAVE_METADATA) {
      resolve();
      return;
    }
    onMetadata = () => {
      resolve();
      video.removeEventListener('loadedmetadata', onMetadata);
    };
    video.addEventListener('loadedmetadata', onMetadata);
  });
  ready.unsubscribe = () => video.removeEventListener('loadedmetadata', onMetadata);
  return ready;
}

export function checkBgImgReady() {
  // there is no way to determine when background image loads,
  // but it shouldn't be an issue since elements with background images usually have sizes set with CSS,
  // so it's fine to treat those elements as "ready"
  const ready = Promise.resolve();
  ready.unsubscribe = () => {}; // no-op function
  return ready;
}

export function checkReady(element, state) {
  const thumbnailNodes = element.querySelectorAll(thumbnailSelector);
  thumbnailNodes.forEach((node) => {
    const thumbnailIdx = state.thumbnails.indexOf(node);
    // exit if we're already watching that thumbnail
    if (thumbnailIdx > -1) {
      return;
    }
    let ready;
    if (node.nodeName === 'IMG') {
      ready = checkImgReady(node);
    } else if (node.nodeName === 'VIDEO') {
      ready = checkVideoReady(node);
    } else {
      const bgImage = getComputedStyle(node).backgroundImage;
      if (/^url/.test(bgImage)) {
        ready = checkBgImgReady(node);
      }
    }
    if (ready) {
      state.thumbnails.push(node);
      state.thumbnailsReady.push(ready);
    }
  });
  if (state.thumbnailsReady.length === 0) {
    return null;
  }
  const ready = Promise.all(state.thumbnailsReady);
  ready.unsubscribe = () => {
    // remove references to DOM nodes
    // (which may even have been detached from DOM since they were saved to the list)
    state.thumbnails = [];
    state.thumbnailsReady.forEach((thReady) => {
      thReady.unsubscribe();
    });
    state.thumbnailsReady = [];
  };
  return ready;
}

/**
 * Use this function to determine when ad thumbnail has been loaded enough for its dimensions to be known.
 *
 * Elements with class `js-ad-thumbnail` are considered thumbnails.
 * It's not necessary for the thumbnail to be present in DOM by the time this function is called.
 * - If the thumbnail is an image that is already loaded, the promise will resolve immediately;
 * - If it's a GIF image, the promise will resolve as soon as image dimensions are known;
 * - For other image types the promise will resolve as soon as image loads;
 * - If the thumbnail is a video, the promise will resolve as soon as video metadata loads.
 *
 * @param {HTMLElement} element - the module element
 * @returns {Promise} - resolved when ad thumbnail has been loaded enough
 * The promise has additional method `unsubscribe` to remove event listeners;
 * make sure to call it when destroying module instance
 */
export function thumbnailReady(element) {
  let checkReadyState = {
    // typically there will be only one `.js-ad-thumbnail`, but just in case
    thumbnails: [],
    // array each item of which is a promise that resolves when respective thumbnail is ready
    thumbnailsReady: [],
  };

  let unsubscribe;
  const ready = new Promise((resolve) => {
    let observer;
    let thumbnailsReady;
    unsubscribe = () => {
      if (observer) {
        observer.disconnect();
      }
      if (thumbnailsReady) {
        thumbnailsReady.unsubscribe();
      }
    };

    // exit if thumbnail node already exists in DOM
    thumbnailsReady = checkReady(element, checkReadyState);
    if (thumbnailsReady) {
      thumbnailsReady.then(resolve);
      return;
    }

    // otherwise listen for DOM mutation to see if any of them adds a thumbnail
    observer = new MutationObserver(() => {
      thumbnailsReady = checkReady(element, checkReadyState);
      if (thumbnailsReady) {
        thumbnailsReady.then(resolve);
        observer.disconnect();
      }
    });
    observer.observe(element, {'subtree': true, 'attributes': true, 'childList': true});
  });
  ready.unsubscribe = unsubscribe;
  // when promise resolves, make sure all remaining observers/event listeners/timeouts are cleared
  ready.then(ready.unsubscribe);
  return ready;
}
