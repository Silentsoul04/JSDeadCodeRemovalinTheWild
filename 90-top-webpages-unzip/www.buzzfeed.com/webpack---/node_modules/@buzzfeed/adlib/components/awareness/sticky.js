import { Application } from 't3js';
import Sticky, { initEvent as stickyInitEvent } from '@buzzfeed/buzzblocks/js/behaviors/stick-to-top';
import { detectTransitionEnd } from '@buzzfeed/buzzblocks/js/services/dom';
import { getUniqueEventName } from '@buzzfeed/buzzblocks/js/services/util/standalone';
import stickyRegistry from '@buzzfeed/buzzblocks/js/services/sticky-registry';
import dismissBtnTmpl from './_close.html';


const dom = { detectTransitionEnd };
const util = { getUniqueEventName };


/**
 * Scroll depth in px that serves as a threshold for the unit becoming sticky/non-sticky
 */
const STICKY_THRESHOLD = 3000;

const STICKY_PARAMS = {
  default: {
    maxScrollDepth: STICKY_THRESHOLD,
    positionMode: 'translate',
    priority: 'medium',
    breakpoints: ['ALL']
  }
};


class AwarenessSticky extends Sticky {
  constructor() {
    super(...arguments);
    this.config.initOnMsg = true;
    this.reset();

    this.config = {...this.config, ...STICKY_PARAMS.default};
    this.unstickAfter = this.getPosition().inDocument + this.config.maxScrollDepth;

    this.onmessage[util.getUniqueEventName('ad-reveal', this.element)] = ({type, isSticky = true} = {}) => {
      /* for some reason this event can be fired multiple times,
      which leads to initializing sticky behavior and listeners each time,
      so we need to prevent this */
      delete this.onmessage[util.getUniqueEventName('ad-reveal', this.element)];

      if (!isSticky) {
        this.destroy();
        return;
      }

      if (type === 'spotlight') {
        this.config.breakpoints = ['md', 'lg'];
      }

      const test = Promise.resolve(type === 'spotlight');
      // @todo Uncomment if we need to re-test
      /*test = abeagle.getExperimentVariant('awareness_card_animated_sticky_exp', {rejectErrors: false})
        .then((variant) => variant === 'sticky');*/
      test.then((shouldStick) => {
        if (!shouldStick) {
          this.destroy();
          return;
        }

        this.element.querySelector('.js-awareness-wrapper')
          .insertAdjacentHTML('beforeend', dismissBtnTmpl.render());
        this.element.querySelector('.js-awareness-dismiss').addEventListener('click', this._onDismiss);

        this.context.application.broadcast(util.getUniqueEventName(stickyInitEvent, this.element));
      });
    };
  }

  reset() {
    this.isHidden = false;
    this.userDismissed = false;
    this.element.classList.remove('sticky--show', 'sticky--hide');
    // add this class so the first appearance can be customized (e.g. not animated on As/Is and News)
    this.element.classList.add('sticky--first-time');
  }

  manageSticky() {
    super.manageSticky(...arguments);

    if (!this.isFixed || this.userDismissed) {
      return;
    }
    if (window.pageYOffset <= this.unstickAfter) {
      this.stickyShow();
    } else {
      this.stickyHide();
    }
  }

  stick() {
    super.stick(...arguments);
    this.isHidden = true;
    // remove until it's added back in `stickyShow`
    // (to prevent paginated sidebar from sliding down and up right afterwards)
    stickyRegistry.remove(this.element);
  }

  unstick() {
    super.unstick(...arguments);
    this.reset();
  }

  stickyShow() {
    if (!this.isFixed || !this.isHidden) {
      return;
    }
    this.isHidden = false;
    this.element.classList.remove('sticky--hide');
    // `top` is the property we animate to show/hide the unit
    dom.detectTransitionEnd(this.element, {properties: ['top']}).then(() => {
      stickyRegistry.add(this.element, this.stickyRegistryOpts);
    });
    this.element.classList.add('sticky--show');
  }

  stickyHide() {
    if (!this.isFixed || this.isHidden) {
      return;
    }
    this.isHidden = true;
    this.element.classList.remove('sticky--show', 'sticky--first-time');
    dom.detectTransitionEnd(this.element, {properties: ['top']}).then(() => {
      stickyRegistry.remove(this.element);
    });
    this.element.classList.add('sticky--hide');
  }

  _onDismiss = (ev) => {
    this.userDismissed = true;
    setTimeout(() => this.stickyHide(), 500);
    ev.preventDefault();
  }

  destroy() {
    const dismissBtn = this.element.querySelector('.js-awareness-dismiss');
    if (dismissBtn) {
      dismissBtn.removeEventListener('click', this._onDismiss);
    }
    super.destroy();
  }
}

const name = 'ad-awareness-sticky';

Application.addBehavior(name, (context) => new AwarenessSticky(context));

export { name };
