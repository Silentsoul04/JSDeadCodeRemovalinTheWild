import { Application } from 't3js';
import { isObject, merge } from 'lodash';
import prepareTemplate from '@buzzfeed/buzzblocks/js/services/nunjucks-env';
import solid from '@buzzfeed/buzzblocks/js/services/solid/standalone';
import { getUniqueEventName } from '@buzzfeed/buzzblocks/js/services/util/standalone';
import AdError from '../error';


const AD_MANAGER_EVENTS = {
  FEED_LOADED: 'feed-ready-for-ads'
};


/**
 * A special exception that indicates the behavior/module instance is not enabled
 *
 * Using old-style class/inheritance because babel has issues with inheriting from built-in classes.
 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Custom_Error_Types
 */
function Disabled() {
  Error.apply(this, arguments);
}
Disabled.prototype = Object.create(Error.prototype);
Disabled.prototype.constructor = Disabled;


/**
 * Indicates the end of iteration when a generator-like function returns an object of this type
 * (similar to `done: true` in native generators)
 */
class Done {}

function isDone(obj) {
  return obj instanceof Done;
}


/**
 * @class
 * @classdesc Base class for use with components that dynamically load content and need ads inserted
 * See the readme for usage examples
 */
class AdManager {
  /**
   * @constructor
   * @param {Object} context - T3 context object (passed automatically by T3)
   * @param {String} [options.mode=behavior] - whether the instance will be used as behavior of xpager's T3 module
   *   (the default and preferred way)
   *   or as a standalone T3 module
   */
  constructor(context, {mode} = {mode: 'behavior'}) {
    this.operationMode = {isBehavior: mode === 'behavior', isModule: mode === 'module'};
    this.config = (this.operationMode.isBehavior ? context.getConfig('ads') : context.getConfig()) || {};
    this.element = context.getElement();
    if (this.operationMode.isBehavior) {
      this.feedLoadedMsg = getUniqueEventName(AD_MANAGER_EVENTS.FEED_LOADED, this.element);
    } else {
      this.feedLoadedMsg = this.feedLoadedMsg || this.config.feedLoadedMsg;
    }
    this.onmessage = {};
    this._state = {};
    this.isActive = true;
  }

  init() {
    this.resolveConfig();
    this.initialized = Promise.resolve()
      .then(() => this.isEnabled())
      .then((isEnabled) => {
        // if it has been destroyed elsewhere while waiting for `isEnabled`
        if (!this.isActive || !isEnabled) {
          throw new Disabled();
        }
      })
      .then(() => this.configure());

    // handle possible errors and make sure a `catch` won't accidentally suppress them
    // if someone `then`s on `init` return value
    this.initialized.catch((reason) => {
      if (this.operationMode.isModule) {
        Application.stop(this.element);
      } else {
        this.destroy();
      }
      return (reason instanceof Disabled) ? Promise.resolve() : Promise.reject(reason);
    });

    if (this.feedLoadedMsg) {
      this.onmessage[this.feedLoadedMsg] = this.handleFeedLoad;
    }

    return this.initialized; // for tests
  }

  destroy() {
    this.isActive = false;
    delete this.onmessage;
    delete this._state;
    delete this.element;
  }

  /**
   * Specifies whether the instance is enabled;
   * can be async
   * @returns {(Boolean|Promise)}
   */
  isEnabled() {
    // ad components whose `is_enabled` evaluates to False on backend will end up as nulls on frontend
    return (
      this.units.filter((ad) => ad).length > 0
      || this.unitsRepeated.filter((ad) => ad).length > 0
    );
  }

  /**
   * Configures the instance parameters such as density (for example, based on page classification or an A/B test);
   * can be async
   * @returns {(undefined|Promise)}
   */
  configure() {}

  /**
   * Resolves config options
   */
  resolveConfig() {
    const breakpoints = Object.keys(solid.cssBreakpoints);
    const breakpoint = solid.getBreakPoint();
    const resolve = (key) => {
      let value = this[`${key}_${breakpoint}`] || this.config[`${key}_${breakpoint}`];
      if (value !== undefined) {
        return value;
      }
      value = this[key] || this.config[key];
      // if it's not an object or doesn't contain neither breakpoints keys nor `default`, it must be a plain value
      if (!isObject(value) || !(breakpoints.some((bp) => bp in value) || 'default' in value)) {
        return value;
      }
      if (breakpoint in value) {
        value = value[breakpoint];
      } else {
        value = value.default;
      }
      return value;
    };

    this.units = resolve('units') || [];
    this.unitsRepeated = resolve('unitsRepeated') || [];
    this.placements = resolve('placements') || [];
    this.density = Number(resolve('density')) || 0;
  }

  /**
   * Generates a sequence of ad units and returns next ad on every call,
   * unless `{pause: true}` is passed, in which case the last return value will be returned on next call too.
   * First uses units from the `units` array,
   * then cycles through the `unitsRepeated` array indefinitely.
   * Restarts from the beginning when `reset` is called
   * @param {Boolean} [options.pause=false] - whether to go to next ad or to pause on last one
   * @returns {(Object|Done)} - ad unit config or a special `Done` instance
   *   when all available ad units are already used
   */
  getNextAd({pause} = {pause: false}) { // @todo Consider using a generator instead?
    if (!('currAd' in this._state)) {
      this._state.currAd = {idx: -1, isStale: true};
    }
    const state = this._state.currAd;

    if (isDone(state.ad)) {
      return state.ad;
    }

    if (pause) {
      state.isStale = false;
      return state.ad;
    }
    if (!state.isStale) {
      state.isStale = true;
      return state.ad;
    }

    const idx = state.idx + 1;
    const ad = this.getAd(idx);
    state.ad = ad;
    state.idx = idx;
    state.isStale = true;

    return ad || null;
  }

  getAd(idx) {
    let ad;
    let isRepeated = false;
    if (idx < this.units.length) {
      ad = this.units[idx];
    } else if (this.unitsRepeated.length > 0) {
      // cycle through repeated units infinitely
      ad = this.unitsRepeated[(idx - this.units.length) % this.unitsRepeated.length];
      isRepeated = true;
    } else {
      ad = new Done();
    }

    // for when the unit has additional template vars besides `slot`
    if (ad && !isDone(ad) && !('slot' in ad)) {
      ad = {'slot': ad};
    }

    // `isInfinitePost` logic is not related to base ad manager itself
    // @todo Move it where it belongs
    if (isRepeated || this.isInfinitePost) {
      // make sure wids don't repeat on the page
      ad.slot.isInfinite = true;
    }

    return ad;
  }

  /**
   * Generates a sequence of ad positions in feed and returns next position on every call,
   * unless `{pause: true}` is passed, in which case the last return value will be returned on next call too.
   * First uses positions from the `placements` array, if provided,
   * then switches to calculating positions based on `density` and continues indefinitely.
   * Restarts from the beginning when `reset` is called
   * @param {Boolean} [options.pause=false] - whether to go to next ad or to pause on last one
   * @returns {(Number|Done)} - position in feed or a special `Done` instance
   *   when all available positions are already used
   */
  getNextPlacement({pause} = {pause: false}) { // @todo Consider using a generator instead?
    if (!('currPlacement' in this._state)) {
      this._state.currPlacement = {idx: -1, placement: -1, isStale: true};
    }
    const state = this._state.currPlacement;

    if (isDone(state.placement)) {
      return state.placement;
    }

    if (pause) {
      state.isStale = false;
      return state.placement;
    }
    if (!state.isStale) {
      state.isStale = true;
      return state.placement;
    }

    const placements = this.placements;
    const density = this.density;
    const idx = state.idx + 1;

    let placement;
    if (idx < placements.length) {
      // subtract 1 since config placements are 1-based while the iteration is 0-based
      placement = placements[idx] - 1;
    // density will be 0 if density settings for this breakpoint were not found in the config
    } else if (density > 0) {
      placement = state.placement + density;
    } else {
      placement = new Done();
    }

    state.placement = placement;
    state.idx = idx;
    state.isStale = true;

    return placement;
  }

  /**
   * Handles `FEED_LOADED` event
   * @param {(NodeList|HTMLCollection|Array)} feedItems - HTML elements representing feed items
   */
  handleFeedLoad(feedItems) {
    return this.initialized.then(
      () => this.injectAds(feedItems),
      () => {} // no need to do anything here, errors will be handled in the dedicated `catch` (see above)
    );
  }

  /**
   * Inserts ads between the feed items according to rules specified in the config
   * @param {(NodeList|HTMLCollection|Array)} feedItems - HTML elements representing feed items
   */
  injectAds(feedItems) {
    if (!('currFeedItem' in this._state)) {
      this._state.currFeedItem = {idx: -1};
    }
    const state = this._state.currFeedItem;

    if (isDone(state.item)) {
      return;
    }

    // skip feed items processed at previous occurences of `FEED_LOADED` event
    // and go straight to new ones
    let _idx = state.item ? [].indexOf.call(feedItems, state.item) + 1 : 0;
    let feedItemIdx = state.idx;
    let feedItem = state.item;
    for (_idx; _idx < feedItems.length; _idx++) {
      feedItem = feedItems[_idx];

      // omit unwanted elements (e.g. hidden on this breakpoint)
      if (!this.isEligibleForAd(feedItem)) {
        continue;
      }

      // increment the counter since this feed item is eligible for ad
      feedItemIdx++;

      const newFeedItem = this.processFeedItem(feedItem, feedItemIdx);
      if (isDone(newFeedItem)) {
        feedItem = new Done();
        break;
      } else if (newFeedItem !== feedItem) {
        // increment the counter since the ad is now a feed item too
        feedItemIdx++;
      }
    }

    // keep a reference to last feed item (whether it's a regular item or a newly inserted ad)
    // so we can start from there the next time `FEED_LOADED` event occurs
    state.item = feedItem;
    state.idx = feedItemIdx;
  }

  /**
   * Inserts an ad before the feed item if there should be one
   * @param {HTMLElement} feedItem - HTML element representing feed item
   * @param {Number} feedItemIdx - position of the feed item in the feed
   * @returns {(HTMLElement|Done)} - HTML element representing newly inserted ad
   *   or the feed item itself if no ad was inserted,
   *   or a special `Done` instance when all available ad units or positions are already used
   */
  processFeedItem(feedItem, feedItemIdx) {
    // in most cases only `feedItemIdx` will be needed, but also pass `feedItem` just in case
    let ad = this.getAdForPlacement(feedItemIdx, feedItem);

    // if all ads are already inserted or no next placement is defined
    if (isDone(ad)) {
      return new Done();
    }

    // if there should be no ad after this item
    if (!ad) {
      return feedItem;
    }

    ad = this.prepareAd(ad, feedItemIdx);
    const adTemplate = this.getAdModuleTemplate(ad);
    if (!adTemplate) {
      return feedItem;
    }
    const adMarkup = prepareTemplate(adTemplate).render(ad);
    let adFeedItem;
    let adElement; // for application starting
    if (this.config.injectMethod === 'inside') {
      feedItem.insertAdjacentHTML('afterbegin', adMarkup);
      adFeedItem = feedItem;
      adElement = feedItem.firstElementChild;
    } else if (this.config.injectMethod === 'after') {
      feedItem.insertAdjacentHTML('afterend', adMarkup);
      adElement = adFeedItem = feedItem.nextElementSibling;
    } else {
      feedItem.insertAdjacentHTML('beforebegin', adMarkup);
      adElement = adFeedItem = feedItem.previousElementSibling;
    }

    if (adElement.hasAttribute('data-module')) {
      Application.start(adElement);
    } else { // if nested in a wrapper
      Application.startAll(adElement);
    }
    return adFeedItem;
  }

  /**
   */
  reset() {
    delete this._state.currAd;
    delete this._state.currPlacement;
  }

  /**
   * Checks whether an HTML element representing a feed item can have an ad before it
   * @param {HTMLElement} element - element to check
   * @returns {Boolean}
   */
  isEligibleForAd(feedItem) {
    // just in case the feed item is not in the DOM anymore
    // (e.g. was removed based on an A/B test variant after it was selected)
    return feedItem.parentNode !== null;
  }

  /**
   * Determines whether an ad should be inserted before the specified feed item
   * and returns ad unit's config if so, or null if not;
   * can also return a special `Done` instance when all available ad units or positions are already used
   * @param {Number} feedItemIdx - position of the feed item in the feed
   * @param {HTMLElement} feedItem - HTML element representing feed item
   * @returns {(Object|null|Done)}
   */
  getAdForPlacement(feedItemIdx) {
    const placement = this.getNextPlacement();
    if (isDone(placement)) {
      return new Done();
    } else if (feedItemIdx === placement) {
      return this.getNextAd();
    } else {
      this.getNextPlacement({pause: true});
      return null;
    }
  }

  /**
   * Modifies ad config before the ad is inserted
   * (for example, to provide additional custom targeting parameters)
   * @param {Object} ad - ad unit config
   * @param {Number} feedItemIdx - position of the feed item in the feed
   * @returns {Object}
   */
  prepareAd(ad, feedItemIdx) {
    ad = merge({}, ad); // to avoid mutations of config data in next calls
    // add 1 since the iteration is 0-based while BFA position should be 1-based
    ad.slot.position = feedItemIdx + 1;
    return ad;
  }

  /**
   * Returns a T3 module template corresponding to ad unit.
   * Must be overriden in derived classes
   * @param {Object} ad - ad unit config
   * @returns {Object} - nunjucks template
   * @throws {AdError} if the method is not overriden in derived class
   */
  getAdModuleTemplate() {
    throw new AdError('The method should be implemented in a derived class');
  }
}

AdManager.Done = Done;
AdManager.isDone = isDone;

/**
 * Returns function that generates a T3 behavior instance
 * @returns {Function} - callback to T3's `addBehavior` function
 */
AdManager.generateBehavior = function() {
  const Cls = this;
  return (context) => {
    return new Cls(context, {mode: 'behavior'});
  };
};

/**
 * Returns function that generates a T3 module instance
 * @returns {Function} - callback to T3's `addModule` function
 */
AdManager.generateModule = function() {
  const Cls = this;
  return (context) => {
    return new Cls(context, {mode: 'module'});
  };
};


export { AdManager, AD_MANAGER_EVENTS };
