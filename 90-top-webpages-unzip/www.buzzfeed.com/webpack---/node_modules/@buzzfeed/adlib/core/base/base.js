import { get } from 'lodash';
import { excludeFromNavigation } from '@buzzfeed/buzzblocks/js/services/a11y';
import '@buzzfeed/buzzblocks/js/services/scrollbar-width'; // in order for `ad--fullwidth` css class to work
import solid from '@buzzfeed/buzzblocks/js/services/solid/standalone';
import {
  Deferred, decorateWithMixins, idGenerator, moduleIsInContext
} from '@buzzfeed/buzzblocks/js/services/util/standalone';
import { optOut } from '@buzzfeed/buzzblocks/js/services/webbridge';
import { isGSAAgent } from '@buzzfeed/bf-utils/lib';

import bzfd from '../../js/services/bzfd';
import size from '../../js/services/size';
import scrollSubscription from '../../js/services/scroll-subscription';
import { name as adWireframe } from '../../js/behaviors/wireframe';
import { name as HouseAds } from '../../js/behaviors/house-ads';
import { name as adTracking } from '../../js/behaviors/tracking';
import { name as adContentNotifier } from '../../js/behaviors/content-notifier';
import { name as viewable } from '../../js/behaviors/ad-viewable';
import ads from '../../core/ads';
import { events as eventsMixin } from '../../core/mixins/events';
import { loadInSidebar } from '../../core/mixins/loadInSidebar';
import { infiniteWid } from '../../core/mixins/infinite-wid';


/**
 * Module config
 * @typedef {Object} AdConfig
 * @property {Number} wid - widget id (examples: 13, 42)
 * @property {String} adPos - ad position (examples: 'bigstory', 'awareness')
 * @property {String} adType - ad type (examples: 'promotion', 'awareness')
 * @property {Number[]|'fluid'} size - slot size (width and height, or 'fluid')
 * @property {Object} targeting - slot targeting options
 * @property {String[]} [supports=null] - screen sizes (in the form of solid breakpoints) on which the unit should load (example: ['md', 'lg']; do not specify if the unit should load on any screen size)
 * @property {String} [platform=null] - another way of specifying screen sizes
 *    `platform='mobileweb'` is the same as `supports=['xs', 'sm']`,
 *    `platform='desktop'` is the same as `supports=['md', 'lg']`;
 *    do not specify if the unit should load on any screen size
 */


// namespace for easier testing
const util = { moduleIsInContext };
const webbridge = { optOut };


/**
 * Associates unique id with each module instance so that we can keep track of them
 */
const generateId = idGenerator();


/**
 * Returns function that generates a T3 module which is a thin wrapper for `AdUnit` descendant classes
 * @memberof AdUnit
 * @returns {Function} - callback to T3 `addModule` method
 */
function generateModule() {
  const Cls = this; // since this is a static class method, `this` is a class itself

  return (context) => {
    return new Cls(context);
  };
}


/**
 * @classdesc Base class for ad units
 */
class AdUnit {
  /**
   * @example
   *   class Ad extends AdUnit.withMixins(DFPMessageListener, multiTemplate) {}
   */
  static withMixins(...mixins) {
    return decorateWithMixins(this, ...mixins);
  }

  static withNewStyleMixins(...mixins) {
    // make an inheritance chain by applying mixins one by one
    return mixins.reduce((Class, mixin) => mixin(Class), this);
  }

  /**
   * @constructor
   * @param {Object} context - T3 module context
   */
  constructor(context) {
    this.context = context;
    this.element = context.getElement();
    /** @type {AdConfig} */
    this.config = context.getConfig();
    if (!('advertiserContext' in this.config)) {
      this.config.advertiserContext = bzfd.isAdPost(this.element);
    }
    this.behaviors = [viewable, adContentNotifier, adTracking, adWireframe, HouseAds];
    this.isRendered = false;
    this.initEvents();
    this.instanceId = generateId();
    if (this.config.isInfinite) {
      this.makeInfiniteWid();
    }
    this.setupSizes();
    this.addA11yMarkup();
    this.addCssClasses();
    this.onmessage = {};
    // Sync ad-loading with page-view tracking for accurate 3rd party pixels
    this.forceWaitForInContext();
  }

  get skin() {
    return this.config.skin || this.config.zone1 || null;
  }

  /**
   * This method is called by T3 when it starts the application
   */
  init() {
    if(!this.isFirstInit()) {
      return;
    }

    // save a copy of ad's initial state in case of reset
    this.initialState = this.element.cloneNode(true);

    const {wid} = this.config;

    // add a `data-instance-id` attribute to mark the element as initialized
    this.element.dataset.instanceId = this.instanceId;

    const isEnabled = this.isEnabled();
    if (get(isEnabled, 'then') && get(isEnabled, 'catch')) {
      console.error('`isEnabled` returns a promise. You should use the `asyncInit` mixin in this case');
    }
    if (!isEnabled) {
      this.stop();
      return;
    }

    // handle broadcasts
    this.startMessaging();
    this.addMessageHandler(`ad-wireframe-collapse-finish-${wid}`, this.stop);
    this.addMessageHandler(`ad-content-error-${wid}`, this.handleContentError);
    this._handleSlotRenderEndedBound = this.handleSlotRenderEnded.bind(this);
    ads.addSlotRenderEndedHandler(wid, this._handleSlotRenderEndedBound);
    this.setup();
    this.context.application.broadcast(`ad-init-${wid}`);
  }

  isFirstInit() {
    /**
     * If the element already has a `data-instance-id` attribute by this time,
     * it means that there was a module instance associated with it at some point in the past
     * that was destroyed due to ad slot being unfilled.
     * We do not need to proceed in this case
     */
    return !this.element.hasAttribute('data-instance-id');
  }

  isEnabled() {
    return (
      // don't load if opted out of ads via scroll.com subscription
      !scrollSubscription.isEnabled
      // don't load if opted out of ads in app
      && !webbridge.optOut()
      && this.isPlatformCorrect()
    );
  }

  stop() {
    /**
     * Push it to the end of the browser queue to make sure it is called after `init`,
     * because T3 doesn't let destroy modules that have not been initialized yet
     */
    setTimeout(() => {
      if (!this.context.application.isStarted(this.element)) {
        return; // do nothing if already destroyed
      }
      // tell T3 app to destroy child modules
      // wrap into try/catch because T3 throws error if the module is already destroyed (or never started)
      try {
        this.context.application.stopAll(this.element);
      } catch (exc) {}
      // tell T3 app to destroy this module
      try {
        this.context.application.stop(this.element);
      } catch (exc) {}
    }, 0);
  }

  /**
   * Prevent ads from loading immediately on pages where context may change (e.g. infinite post feeds)
   * This allows us to sync 3rd party pixels with page views.
   */
  forceWaitForInContext() {
    this.isInContext = new Deferred();
    if (util.moduleIsInContext(this.element)) {
      this.isInContext.resolve();
    } else {
      this.onmessage['buzz-context-changed'] = () => {
        if (util.moduleIsInContext(this.element)) {
          this.isInContext.resolve();
          delete this.onmessage['buzz-context-changed'];
        }
      };
    }
  }

  /**
   * Excludes wide sizes for ad call on mobile
   */
  setupSizes() {
    const isMobile = solid.isXsmall();
    const checkGSA = isGSAAgent();
    if (isMobile) {
      this.filterProgrammaticSizes({max: bzfd.adSizes.PROGRAMMATIC_SMARTPHONE_BANNER});
      this.excludeSize(bzfd.adSizes.PROGRAMMATIC_VERTICAL);
      // Checks if Goodle Search App is in user agent and exludes videos on mobile
      if (checkGSA) {
        this.excludeSize(bzfd.adSizes.FLUID);
      }
    }
  }

  /**
   * This method gets called when T3 application starts if the module should initialize
   */
  setup() {}

  /**
   * Request ad from DFP using GPT lib
   */
  render() {
    if (this.isRendered) {
      return Promise.resolve();
    }

    this.isRendered = true;
    // collapse wireframes for ads that have no valid sizes
    if (this.config.size.length === 0) {
      this.collapse();
      return Promise.resolve();
    }

    return this.isInContext
      .then(() => ads.renderWidget(this.config))
      .catch((reason) => {
        this.collapse();

        // in case promise has been rejected not deliberately, but because of a real error
        if (!(reason instanceof ads.AdError)) {
          return Promise.reject(reason);
        }
        return Promise.resolve(); // to conform eslint consistent-return
      });
  }

  addA11yMarkup() {
    this.element.setAttribute('role', 'complementary');
    this.element.setAttribute('aria-label', 'Advertisement');
  }

  /**
   * Add CSS classes during init
   * @returns {Void}
   */
  addCssClasses() {
    const {wid} = this.config;
    this.element.classList.add('js-ad', `js-ad-${wid}`);
    const skin = this.config.skin;
    if (skin) {
      this.element.classList.add(`ad--${skin}`);
    }
    if (this.config.advertiserContext) {
      this.element.classList.add('ad--partner');
    }
    const slot = ads.getSlotContainer(wid);
    // there may be no slot container yet, it'll be created later in `ads.renderWidget` in this case
    if (slot) {
      slot.classList.add('ad-slot', 'js-ad-slot', `js-ad-slot-${wid}`);
    }
  }

  /**
   * Checks whether the screen sizes the component is supposed to run on match the actual screen size
   * @returns {Boolean}
   */
  isPlatformCorrect() {
    let platform = this.context.getConfig('platform') || null;
    let supports = this.context.getConfig('supports') || null;
    let breakpoints;
    if (platform) {
      if (platform === 'desktop') {
        breakpoints = ['md', 'lg'];
      } else if (platform === 'mobileweb') {
        breakpoints = ['xs', 'sm'];
      }
    }
    if (supports) {
      breakpoints = supports;
    }
    if (Array.isArray(breakpoints)) {
      return solid.isAny(breakpoints);
    }
    return true;
  }

  /**
   * Called when `SlotRenderEndedEvent` GPT event occurs
   * @param {Object} gptEv - GPT `SlotRenderEndedEvent`, see ads service for details
   */
  handleSlotRenderEnded(gptEv) {
    // `#div-gpt-ad-` element
    const slot = ads.getSlotContainer(this.config.wid);
    if (ads.isIframeContent(gptEv, this.config.size)) {
      slot.classList.remove('ad-slot-invisible');
    } else {
      slot.classList.add('ad-slot-invisible');
      excludeFromNavigation(slot); // prevent 5x5 iframes from being focusable
    }
  }

  handleContentError() {
    this.collapse();
  }

  /**
   * Adds size(s) to ad call.
   * Does nothing if the unit already has the size.
   * Should be run before `render`, otherwise will have no effect.
   * @param {...Number[2]} size - slot size, a [width, height] pair;
   *   preferred way is to use sizes from `bzfd.adSizes`
   * @example
   * this.addSize(bzfd.adSizes.PROGRAMMATIC_MEDIUM_RECTANGLE, bzfd.adSizes.PROGRAMMATIC_VERTICAL)
   */
  addSize(...sizes) {
    const isMobile = solid.isXsmall();
    const checkGSA = isGSAAgent();

    // We want to ensure that any fluid ads that may get added from somewhere else are removed
    // if the user is on a mobile device AND their user agent includes GSA
    if (isMobile && checkGSA) {
      sizes = sizes.filter((_size) => _size !== 'fluid');
    }
    this.config.size = size.add(this.config.size, ...sizes);
  }

  /**
   * Excludes size(s) from ad call.
   * Does nothing if the unit doesn't have the size.
   * Should be run before `render`, otherwise will have no effect.
   * @param {...Number[2]} size - slot size, a [width, height] pair;
   *   preferred way is to use sizes from `bzfd.adSizes`
   * @example
   * this.excludeSize(bzfd.adSizes.PROGRAMMATIC_HORIZONTAL_8to1)
   */
  excludeSize(...sizes) {
    this.config.size = size.exclude(this.config.size, ...sizes);
  }

  /**
   * Excludes programmatic sizes whose width is bigger or smaller than desired.
   * Should be run before `render`, otherwise will have no effect.
   * @param {Number[2]} options.min - size whose *width* will be used as a threshold,
   *   and only unit sizes of equal and larger width will be kept;
   *   preferred way is to use sizes from `bzfd.adSizes`
   * @param {Number[2]} options.max - size whose *width* will be used as a threshold,
   *   and only unit sizes of equal and smaller width will be kept;
   *   preferred way is to use sizes from `bzfd.adSizes`
   * @example
   * this.filterProgrammaticSizes({max: bzfd.adSizes.PROGRAMMATIC_SMARTPHONE_BANNER})
   */
  filterProgrammaticSizes(options = {}) {
    this.config.size = size.filterProgrammatic(this.config.size, options);
  }

  /**
   * Adds a behavior. Safe to call multiple times (will exit if the behavior is already in the list)
   * Note this will take no effect if called in/after module init (due to how T3 processes behaviors)
   * @param {String} behaviorName - behavior to add
   */
  addBehavior(behaviorName) {
    if (!behaviorName) {
      return;
    }
    const isAdded = this.behaviors.indexOf(behaviorName) > -1;
    if (!isAdded) {
      this.behaviors.push(behaviorName);
    }
  }

  /**
   * Removes a behavior
   * Note this will take no effect if called in/after module init (due to how T3 processes behaviors)
   * @param {String} behaviorName - behavior to add
   */
  removeBehavior(behaviorName) {
    this.behaviors = this.behaviors.filter((bh) => bh !== behaviorName);
  }

  /**
   * Run collapsing animation and destroy the instance in the end
   * (the destroying part is handled in the `ad-wireframe-collapse-finish` listener)
   */
  collapse() {
    ads.collapse(this.config.wid);
  }

  /**
   * Destroys the module instance: unsubscribes from messages, removes or hides the element.
   * Removes the element from DOM if the ad hasn't been rendered yet.
   * Otherwise just hide the element,
   * as the `#div-gpt-ad-` element is still needed for GPT to correctly track ad slots visibility.
   *
   * This method is supposed to be called by T3 when it shuts down the module (via `Application.stop`).
   * Do not call this derectly! Use `stop` instead.
   */
  destroy() {
    // if `destroy` was called not by T3, call `stop` to properly destroy the module and behaviors
    setTimeout(() => {
      if (this.context.application.isStarted(this.element)) {
        this.stop();
      } else {
        // only delete the reference to element when we're sure it won't be needed
        // because the instance has been destroyed properly
        delete this.element;
      }
    }, 1);

    delete this.onmessage;
    ads.removeSlotRenderEndedHandler(this.config.wid, this._handleSlotRenderEndedBound);
    delete this._handleSlotRenderEndedBound;
    // hide empty wireframe
    if (this.element.parentElement.classList.contains('ad-wireframe-wrapper')) {
      this.element.parentElement.classList.add('js-hidden');
    }
    // hide or destroy element
    if (this.isRendered) {
      this.element.classList.add('js-hidden');
    } else {
      this.element.parentElement.removeChild(this.element);
    }
    // broadcast that this ad has been destroyed
    this.context.application.broadcast(`ad-destroy-${this.config.wid}`);
  }
}

AdUnit = decorateWithMixins(AdUnit, eventsMixin, infiniteWid, loadInSidebar);

AdUnit.generateModule = generateModule;


export { AdUnit };
