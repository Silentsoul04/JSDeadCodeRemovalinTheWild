import { forEach, partialRight } from 'lodash';
import ads from '../ads';
import widRegistry from '../../js/services/wid-registry';


function updateConfig(config, widInitial, widUnique, targeting) {
  forEach(config, (value, key) => {
    if (key === 'wid' && String(value) === String(widInitial)) {
      config[key] = widUnique;
    } else if (typeof value === 'object' && value !== null) {
      updateConfig(value, widInitial, widUnique, targeting);
    }
    if (key === 'targeting') {
      Object.assign(value, targeting);
    }
  });
}

function updateId(el, widInitial, widUnique) {
  el.id = el.id.replace(widInitial, widUnique);
}

function updateClasses(el, classNames, widInitial, widUnique) {
  classNames.forEach((className) => {
    const hasClass = el.classList.contains(className);
    el.classList.remove(className);
    if (hasClass) {
      el.classList.add(className.replace(widInitial, widUnique));
    }
  });
}


function infiniteWid() {
  return {
    /**
     * Updates the wid so it's unique across all ad units on the page
     *
     * @param {Object} options
     * @param {Boolean} [options.sameIfFirst = false] - whether to keep wid unchanged in the case
     *   when it's not in `widRegistry` yet (i.e. not used by any other module on the page)
     *   defaults to false, can be overridden in derived classes
     *   (primary use-case is components that can receive userwidget ads).
     *   When using `sameIfFirst: true`, make sure the module element's id is *not* hardcoded in template
     *   because it will mess up T3's internal module setup
     *   (as it uses ids to keep track of module instances, behaviors, T3 and DOM events, etc.),
     *   which will prevent T3 from initializing "infinite" instances of the module
     * @param {String} [options.separator = '-'] - a symbol inserted between initial wid and unique suffix
     */
    makeInfiniteWid({sameIfFirst = false, separator = '-'} = {}) {
      if (!this.config.isInfinite || !this.isFirstInit()) {
        return;
      }
      const widInitial = this.config.wid;
      const unique = widRegistry.getUnique(widInitial, {startFrom: sameIfFirst ? 0 : 1});

      if (unique === 0) {
        return;
      }
      const widUnique = `${widInitial}${separator}${unique}`;

      const updateConfigBound = partialRight(
        updateConfig,
        // pass `infinite_index` targeting param to DFP
        widInitial, widUnique, {'infinite_index': unique}
      );
      const updateIdBound = partialRight(
        updateId,
        widInitial, widUnique
      );
      const updateClassesBound = partialRight(
        updateClasses,
        [
          `js-ad-${widInitial}`, `js-ad-format-${widInitial}`, `js-ad-slot-${widInitial}`,
          `ad-wireframe-${widInitial}`, `ad-fade-${widInitial}` // userwidget classes
        ], widInitial, widUnique
      );

      updateConfigBound(this.config);

      // patch config JSON so that all behaviors and nested modules use the updated wid when they initialize
      this.element.querySelectorAll('script[type="text/x-config"]').forEach((configEl) => {
        const config = JSON.parse(configEl.textContent);
        updateConfigBound(config);
        configEl.textContent = JSON.stringify(config);
      });

      // can be this.element or a nested element
      const bfWidget = (
        /^BF_WIDGET_/.test(this.element.id) ? this.element : this.element.querySelector(`#BF_WIDGET_${widInitial}`)
      );
      if (bfWidget) {
        // safe update this.element's id as long as the instance is not initialized by T3 yet
        // (i.e. before `init` is called),
        // because T3 uses element ids to keep track of module instance's behaviors, events, etc.
        updateIdBound(bfWidget);
      }

      const slot = this.element.querySelector(`#${ads.getSlotContainerId(widInitial)}`);
      if (slot) {
        updateIdBound(slot);
      }

      // used by userwidget and programmatic ads
      const slotWrapper = this.element.querySelector(`#bf-item-${widInitial}-1`);
      if (slotWrapper) {
        updateIdBound(slotWrapper);
      }

      updateClassesBound(this.element);
      this.element.querySelectorAll('*').forEach((el) => updateClassesBound(el));
    }
  };
}


export { infiniteWid };
