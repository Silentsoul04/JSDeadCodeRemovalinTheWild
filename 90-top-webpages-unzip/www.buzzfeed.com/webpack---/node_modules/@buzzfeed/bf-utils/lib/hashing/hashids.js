/*
    Hashids
    http://hashids.org/javascript
    (c) 2013 Ivan Akimov
    https://github.com/ivanakimov/hashids.js
    hashids may be freely distributed under the MIT license.
*/

export function Hashids(salt, minHashLength, alphabet) {

  var uniqueAlphabet; var i; var j; var len; var sepsLength; var diff; var guardCount;

  this.version = '1.0.1';

  /* internal settings */

  this.minAlphabetLength = 16;
  this.sepDiv = 3.5;
  this.guardDiv = 12;

  /* error messages */

  this.errorAlphabetLength = 'error: alphabet must contain at least X unique characters';
  this.errorAlphabetSpace = 'error: alphabet cannot contain spaces';

  /* alphabet vars */

  this.alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890';
  this.seps = 'cfhistuCFHISTU';
  this.minHashLength = parseInt(minHashLength, 10) > 0 ? minHashLength : 0;
  this.salt = (typeof salt === 'string') ? salt : '';

  if (typeof alphabet === 'string') {
    this.alphabet = alphabet;
  }

  for (uniqueAlphabet = '', i = 0, len = this.alphabet.length; i !== len; i++) {
    if (uniqueAlphabet.indexOf(this.alphabet[i]) === -1) {
      uniqueAlphabet += this.alphabet[i];
    }
  }

  this.alphabet = uniqueAlphabet;

  if (this.alphabet.length < this.minAlphabetLength) {
    throw this.errorAlphabetLength.replace('X', this.minAlphabetLength);
  }

  if (this.alphabet.search(' ') !== -1) {
    throw this.errorAlphabetSpace;
  }

  /* seps should contain only characters present in alphabet; alphabet should not contains seps */

  for (i = 0, len = this.seps.length; i !== len; i++) {

    j = this.alphabet.indexOf(this.seps[i]);
    if (j === -1) {
      this.seps = this.seps.substr(0, i) + ' ' + this.seps.substr(i + 1);
    } else {
      this.alphabet = this.alphabet.substr(0, j) + ' ' + this.alphabet.substr(j + 1);
    }

  }

  this.alphabet = this.alphabet.replace(/ /g, '');

  this.seps = this.seps.replace(/ /g, '');
  this.seps = this.consistentShuffle(this.seps, this.salt);

  if (!this.seps.length || (this.alphabet.length / this.seps.length) > this.sepDiv) {

    sepsLength = Math.ceil(this.alphabet.length / this.sepDiv);

    if (sepsLength === 1) {
      sepsLength++;
    }

    if (sepsLength > this.seps.length) {

      diff = sepsLength - this.seps.length;
      this.seps += this.alphabet.substr(0, diff);
      this.alphabet = this.alphabet.substr(diff);

    } else {
      this.seps = this.seps.substr(0, sepsLength);
    }

  }

  this.alphabet = this.consistentShuffle(this.alphabet, this.salt);
  guardCount = Math.ceil(this.alphabet.length / this.guardDiv);

  if (this.alphabet.length < 3) {
    this.guards = this.seps.substr(0, guardCount);
    this.seps = this.seps.substr(guardCount);
  } else {
    this.guards = this.alphabet.substr(0, guardCount);
    this.alphabet = this.alphabet.substr(guardCount);
  }

}

Hashids.prototype.encode = function() {

  var ret = ''; var i; var len;


  var numbers = Array.prototype.slice.call(arguments);

  if (!numbers.length) {
    return ret;
  }

  if (numbers[0] instanceof Array) {
    numbers = numbers[0];
  }

  for (i = 0, len = numbers.length; i !== len; i++) {
    if (typeof numbers[i] !== 'number' || numbers[i] % 1 !== 0 || numbers[i] < 0) {
      return ret;
    }
  }

  return this._encode(numbers);

};

Hashids.prototype.decode = function(hash) {

  var ret = [];

  if (!hash.length || typeof hash !== 'string') {
    return ret;
  }

  return this._decode(hash, this.alphabet);

};

Hashids.prototype.encodeHex = function(str) {

  var i; var len; var numbers;

  str = str.toString();
  if (!/^[0-9a-fA-F]+$/.test(str)) {
    return '';
  }

  numbers = str.match(/[\w\W]{1,12}/g);

  for (i = 0, len = numbers.length; i !== len; i++) {
    numbers[i] = parseInt('1' + numbers[i], 16);
  }

  return this.encode.apply(this, numbers);

};

Hashids.prototype.decodeHex = function(hash) {

  var ret = []; var i; var len;


  var numbers = this.decode(hash);

  for (i = 0, len = numbers.length; i !== len; i++) {
    ret += (numbers[i]).toString(16).substr(1);
  }

  return ret;

};

Hashids.prototype._encode = function(numbers) {

  var ret; var lottery; var i; var len; var number; var buffer;
  var last; var sepsIndex; var guardIndex; var guard; var halfLength; var excess;


  var alphabet = this.alphabet;


  var numbersSize = numbers.length;


  var numbersHashInt = 0;

  for (i = 0, len = numbers.length; i !== len; i++) {
    numbersHashInt += (numbers[i] % (i + 100));
  }

  lottery = ret = alphabet[numbersHashInt % alphabet.length];
  for (i = 0, len = numbers.length; i !== len; i++) {

    number = numbers[i];
    buffer = lottery + this.salt + alphabet;

    alphabet = this.consistentShuffle(alphabet, buffer.substr(0, alphabet.length));
    last = this.hash(number, alphabet);

    ret += last;

    if (i + 1 < numbersSize) {
      number %= (last.charCodeAt(0) + i);
      sepsIndex = number % this.seps.length;
      ret += this.seps[sepsIndex];
    }

  }

  if (ret.length < this.minHashLength) {

    guardIndex = (numbersHashInt + ret[0].charCodeAt(0)) % this.guards.length;
    guard = this.guards[guardIndex];

    ret = guard + ret;

    if (ret.length < this.minHashLength) {

      guardIndex = (numbersHashInt + ret[2].charCodeAt(0)) % this.guards.length;
      guard = this.guards[guardIndex];

      ret += guard;

    }

  }

  halfLength = parseInt(alphabet.length / 2, 10);
  while (ret.length < this.minHashLength) {

    alphabet = this.consistentShuffle(alphabet, alphabet);
    ret = alphabet.substr(halfLength) + ret + alphabet.substr(0, halfLength);

    excess = ret.length - this.minHashLength;
    if (excess > 0) {
      ret = ret.substr(excess / 2, this.minHashLength);
    }

  }

  return ret;

};

Hashids.prototype._decode = function(hash, alphabet) {

  var ret = []; var i = 0;


  var lottery; var len; var subHash; var buffer;


  var r = new RegExp('[' + this.guards + ']', 'g');


  var hashBreakdown = hash.replace(r, ' ');


  var hashArray = hashBreakdown.split(' ');

  if (hashArray.length === 3 || hashArray.length === 2) {
    i = 1;
  }

  hashBreakdown = hashArray[i];
  if (typeof hashBreakdown[0] !== 'undefined') {

    lottery = hashBreakdown[0];
    hashBreakdown = hashBreakdown.substr(1);

    r = new RegExp('[' + this.seps + ']', 'g');
    hashBreakdown = hashBreakdown.replace(r, ' ');
    hashArray = hashBreakdown.split(' ');

    for (i = 0, len = hashArray.length; i !== len; i++) {

      subHash = hashArray[i];
      buffer = lottery + this.salt + alphabet;

      alphabet = this.consistentShuffle(alphabet, buffer.substr(0, alphabet.length));
      ret.push(this.unhash(subHash, alphabet));

    }

    if (this._encode(ret) !== hash) {
      ret = [];
    }

  }

  return ret;

};

Hashids.prototype.consistentShuffle = function(alphabet, salt) {

  var integer; var j; var temp; var i; var v; var p;

  if (!salt.length) {
    return alphabet;
  }

  for (i = alphabet.length - 1, v = 0, p = 0; i > 0; i--, v++) {

    v %= salt.length;
    p += integer = salt[v].charCodeAt(0);
    j = (integer + v + p) % i;

    temp = alphabet[j];
    alphabet = alphabet.substr(0, j) + alphabet[i] + alphabet.substr(j + 1);
    alphabet = alphabet.substr(0, i) + temp + alphabet.substr(i + 1);

  }

  return alphabet;

};

Hashids.prototype.hash = function(input, alphabet) {

  var hash = '';


  var alphabetLength = alphabet.length;

  do {
    hash = alphabet[input % alphabetLength] + hash;
    input = parseInt(input / alphabetLength, 10);
  } while (input);

  return hash;

};

Hashids.prototype.unhash = function(input, alphabet) {

  var number = 0; var pos; var i;

  for (i = 0; i < input.length; i++) {
    pos = alphabet.indexOf(input[i]);
    number += pos * Math.pow(alphabet.length, input.length - i - 1);
  }

  return number;

};
