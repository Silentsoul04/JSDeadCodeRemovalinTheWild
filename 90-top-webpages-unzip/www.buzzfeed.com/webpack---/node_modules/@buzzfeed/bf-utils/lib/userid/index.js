import XDomainCookieManager from '../XDomainCookieManager';
import { decode, encode } from '../hashing';

// in-memory new user identifier
// ensures multiple async calls return the same value when cookie does not exist initially
const idSeed = parseInt(Math.random() * 10000000000, 10);

const unhash = val => {
  if (val.indexOf('.') !== 0) {
    // This may be a V1, unhashed id
    // TODO: instrument this
    const m = /[0-9A-Za-z]+/.exec(val);
    if (m !== null && m[0] === val) {
      return parseInt(val, 36);
    } else {
      // this is not a valid id
      return false;
    }
  }

  const salt = val.substr(1, 2);
  const strId = val.substr(3);

  return decode(strId, { salt });
};

const hash = id => {
  const salt = parseInt(Math.random() * 25 + 10, 10).toString(36) +
    parseInt(Math.random() * 25 + 10, 10).toString(36);
  return `.${salt}${encode(id, { salt, length: 0 })}`;
};

const parseFromCookieValue = cookieValue => {
  const identifier = decodeURIComponent(cookieValue)
    .split('&')
    .filter(token => token.indexOf('u=') !== -1)
    .map(token => token.split('=')[1])
    .pop();

  return unhash(identifier || '');
};

export const getUserId = ({ env, create = true }) => {
  const cookieManager = new XDomainCookieManager({
    namespace: 'bf-xdomain-tracking',
    cookieName: 'bf_visit',
    daysExpiry: 10000,
    env,
  });

  return cookieManager.get()
    .then(value => {
      if (!value && create) {
        const hashedId = hash(idSeed);
        cookieManager.set(encodeURIComponent(`u=${hashedId}&v=2`));
        return idSeed;
      }

      return parseFromCookieValue(value);
    });
};

export default {
  getUserId
};
