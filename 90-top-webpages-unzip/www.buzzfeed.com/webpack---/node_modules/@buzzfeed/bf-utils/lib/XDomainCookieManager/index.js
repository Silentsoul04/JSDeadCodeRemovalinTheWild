import XDomainCookies from '../XDomainCookies';
import { getLocalCookieDomain, getSourceOfTruthCookieDomain } from '../XDomainCookies/default-domains';

/**
 * A simple interface to make it easier to setting up a
 * particular cookie with the assumption that most of the
 * parameters will stay the same, allowing you to instantiate
 * it once and then continue to re-use.
 */
export default class XDomainCookieManager {
  /**
   * @param {Object} args
   * @param {String} args.cookieName - The name, or key, of the cookie
   * @param {Number} args.daysExpiry - How long, in days, the cookie
   *   should live before expiring.
   * @param {String} args.env - The current context, should be 'prod' or otherwise.
   * @param {String} args.namespace - The XDomainCookies namespace.
   * @param {Number} args.throttleTimer - If a number is specified here, we'll
   *   throttle how often we check the XDomainCookies for a value. This will
   *   prevent reading from cookies more often than we need. The default
   *   null value provides no throttling.
   * @param {Boolean} args.secureOnly - Whether the cookie will be set
   *   as secure only when being written. Defaults to true.
   * @param {String} args.localDomain - The domain we're reading the
   *   cookies from. This will default to a best guess attempt based on
   *   known BuzzFeed domains, while trying not to limit to a particular
   *   subdomain other than stage.
   * @param {String} args.sourceOfTruthDomain - The domain to be used
   *   as the source of truth for the cookies. Will default to buzzfeed.com
   *   or stage.buzzfeed.com for non-prod.
   */
  constructor({
    cookieName,
    daysExpiry,
    env,
    namespace,
    sourceOfTruthDomain,
    throttleTimer = null,
    secureOnly = true,
    localDomain = getLocalCookieDomain(),
  }) {
    // normalise environment variable
    env = env === 'live' ? 'prod' : env;
    this.xDomainCookies = new XDomainCookies({
      sourceOfTruthDomain: sourceOfTruthDomain || getSourceOfTruthCookieDomain(env),
      namespace,
      localDomain,
      env,
    });
    this.cookieName = cookieName;
    this.daysExpiry = daysExpiry;
    this.secureOnly = secureOnly;
    this.throttleTimer = throttleTimer;
    this.inMemoryValue = null;
  }

  get() {
    if (this.throttle) {
      return Promise.resolve(this.inMemoryValue);
    }
    return this.xDomainCookies.get(this.cookieName).then((cookieValue) => {
      this.inMemoryValue = cookieValue;
      this.resetThrottle();
      return cookieValue;
    });
  }

  set(value) {
    this.inMemoryValue = value;
    return this.xDomainCookies.set({
      name: this.cookieName,
      value,
      days: this.daysExpiry,
      secureOnly: this.secureOnly,
    });
  }

  // Private

  resetThrottle() {
    if (this.throttleTimer) {
      this.throttle = setTimeout(() => {
        this.throttle = null;
      }, this.throttleTimer);
    }
  }
}
