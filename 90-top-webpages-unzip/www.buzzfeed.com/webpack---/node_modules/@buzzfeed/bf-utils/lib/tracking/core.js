import zip from 'just-zip-it';

/**
 * Explicit type for function returning consumer's context
 * @typedef {Function} Context
 */

/**
 * A helper type to define object literals
 * @typedef {Object.<string, string|number>} LayerObject
 */

/**
 * Individual layer types can vary, currently supported types are:
 * - async function with an object as a return value
 * - an object
 * @typedef {LayerObject|function(Context=):(LayerObject|Promise.<LayerObject)} Layer
 */

/**
 * Generates a data object by evaluating all supplied data layers.
 * All layers are always represented as an append-only list.
 */
const eventFromLayers = async({ context, layers = [] }) => {
  let dataObj = {};
  for (let i = 0; i < layers.length; i++) {
    let layer = layers[i];
    if (typeof layer === 'function') {
      layer = await layer(context());
    }
    dataObj = { ...dataObj, ...layer };
  }
  return dataObj;
};

/**
 * Creates a builder function, which provides a way to add more data layers to an event
 * @param {Layer[]} [layers=[]] - initial data layers for an event
 * @return {Function} - function to add more data layers
 */
export const createLayerBuilder = (layers = []) =>
  (...externalLayers) => {
    layers.push(...externalLayers);
    return layers;
  };

/**
 * Creates a broadcasting function, which when called will evaluate all data layers
 * and send the resulting data structure back to the tracking upstream.
 * @param {Object} params
 * @param {Layer[]} params.layers - data layers for the event
 * @param {Function} params.broadcast - function to be called with the constructed event
 * @param {Context} [params.context] - function that provides contextual data for layers
 * @returns {Function} - when called will send a constructed event into the broadcasting function
 */
export const bindEventBroadcaster = ({ layers, broadcast, context = () => {} }) => {
  return async(...args) => {
    const evt = await eventFromLayers({ context, layers: [...layers, ...args] });
    return broadcast(evt);
  };
};

/**
 * Combines multiple event functions into one.
 * Example:
 * events = [
 *   [fn0, fn1],
 *   [fn2, fn3],
 *   [fn4, fn5],
 * ]
 *
 * will be combined into a pair of functions:
 * [fnExecEven, fnExecOdd]
*/
export const combineEvents = (...events) => {
  const createExecutors = fns => {
    return (...args) => {
      fns.forEach(fn => fn(...args));
    };
  };

  return zip(...events).map(createExecutors);
};
