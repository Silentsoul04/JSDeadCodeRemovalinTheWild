import defs from "./bfa_defs";
import utils from "./bfa_utils";
import { isString, isUndefined, isFunction, isArray, every, get, set, has, } from "lodash";

"use strict";

/**
 * Provides functionality for variable/property mapping
 * @param {string} destinationVarPath - destination variable path (for example obj.foo.bar)
 * @param {*} defaultValue - default value
 * @constructor
 */
function BfaMapperMapTo(destinationVarPath, defaultValue){
  if (isString(destinationVarPath) === false || destinationVarPath.length <= 0){
    throw new TypeError("\"mapTo\" should be a non empty string");
  }
  if (isUndefined(defaultValue)){
    defaultValue = null;
  }
  this.destinationVarPath = destinationVarPath;
  this.mappingType = this.mappingTypes.sourcePath;
  this.mappingFrom = undefined;
  this.preFormatters = [];
  this.defaultValue = defaultValue;
}

BfaMapperMapTo.prototype.mappingTypes = {
  sourcePath: 1,
  function: 2,
};

/**
 * Mapping source set up
 * @param {function|string} mapFrom - function (which has to receive source object in arguments and returns a value
 * for mapping) or path to some source object variable
 * @param {array} preFormatters - formatters that are going to be applied on result
 * @returns {BfaMapperMapTo} - this
 */
BfaMapperMapTo.prototype.mapFrom = function(mapFrom, preFormatters){
  if (isFunction(mapFrom)){
    this.mappingType = this.mappingTypes.function;
    this.mappingFrom = mapFrom;
  }
  else
  if (isString(mapFrom) && mapFrom.length > 0) {
    this.mappingType = this.mappingTypes.sourcePath;
    this.mappingFrom = mapFrom;
  }
  else {
    throw new TypeError("\"mapFrom\" is object of wrong type: " + (typeof mapFrom).toString());
  }
  if (isArray(preFormatters) && every(preFormatters, function(v){
      return v instanceof Function;
    })){
    this.preFormatters.push.apply(this.preFormatters, preFormatters);
  }
  return this;
};

/**
 * Method which returns value that has to be mapped to corresponded destination variable
 * @param {object} source - source object
 * @param {object} destination - destination object
 * @param {*} currentContext - mapping context
 * @returns {*|null} - value
 */
BfaMapperMapTo.prototype.map = function(source, destination, currentContext){
  var result = this.defaultValue;

  if (!isUndefined(this.mappingFrom)){
    switch (this.mappingType){
      case this.mappingTypes.function:
        result = this.mappingFrom.call(currentContext, source, destination);
        break;
      case this.mappingTypes.sourcePath:
        result = get(source, this.mappingFrom, this.defaultValue);
        break;
    }
  }
  if (isUndefined(result)){
    result = this.defaultValue;
  }
  if (this.preFormatters.length > 0){
    this.preFormatters.forEach(function(formatter){
      result = formatter.call(currentContext, result);
    });
  }
  set(destination, this.destinationVarPath, result);
  return result;
};

/**
 * Class provides map configuration set up functionality
 * @param {object} options - options
 * @constructor
 */
function BfaMapperMapConfig(options){
  this.options = options;
  this.mapToCollection = [];
}

/**
 * Method for mapping destination configuration
 * @param {string} destinationVarPath - destination of variable/property for mapping
 * @param {*} defaultValue - default value
 * @returns {BfaMapperMapTo} - instance of BfaMapperMapTo
 */
BfaMapperMapConfig.prototype.addMapTo = function (destinationVarPath, defaultValue) {
  var newMapTo = new BfaMapperMapTo(destinationVarPath, defaultValue);
  this.mapToCollection.push(newMapTo);
  return newMapTo;
};

/**
 * BfaMapperConfig extended with template functionality
 * @param {object} options - options
 * @constructor
 */
function BfaMapperMapConfigExtended(options){
  BfaMapperMapConfig.call(this, options);
  this.templatesToApply = [];
}

BfaMapperMapConfigExtended.prototype = Object.create(BfaMapperMapConfig.prototype);
BfaMapperMapConfigExtended.prototype.constructor = BfaMapperMapConfigExtended;

/**
 * Applies template (map config that was added as template) by name
 * @param {string} templateName - name of already added template
 * @returns {Void} - void
 */
BfaMapperMapConfigExtended.prototype.applyTemplateByName = function(templateName){
  if (this.templatesToApply.indexOf(templateName) === -1){
    this.templatesToApply.push(templateName);
  }
};

/**
 * Model for route function and corresponded map config storing
 * @param {function} routeFunc - function that checks source object and returns true if corresponded map config
 * should be used, false otherwise
 * @param {BfaMapperMapConfig} mapConfig - corresponded map config
 * @constructor
 */
function BfaMapperRoute(routeFunc, mapConfig){
  if (!routeFunc || !isFunction(routeFunc)){
    throw new Error("routeFunc should be a function that receives src object as parameter and returns bool");
  }
  if (!mapConfig || !(mapConfig instanceof BfaMapperMapConfig)){
    throw new Error("mapConfig should be an instance of BfaMapperMapConfig");
  }
  this.routeFunc = routeFunc;
  this.mapConfig = mapConfig;
}

/**
 * Class that provides possibility to use different map configs for different source state
 * @param {string} mapName - mapper router name
 * @param {object} options - options
 * @constructor
 */
function BfaMapperRouter(mapName, options){
  this.mapName = mapName;
  this.options = options;
  this.routers = [];
  this.defaultMapConfig = null;
}

/**
 * Returns map config which is correspond to source state
 * @param {object} src - source
 * @param {*} currentContext context for route functions
 * @returns {*} - map config object
 */
BfaMapperRouter.prototype.getMapConfig = function(src, currentContext) {
  var resultedMapConfig = null;
  for (var i = 0; i < this.routers.length; i++) {
    var route = this.routers[i];
    if (route.routeFunc.call(currentContext, src) === true) {
      resultedMapConfig = route.mapConfig;
      break;
    }
  }
  if (resultedMapConfig === null){
    resultedMapConfig = this.defaultMapConfig;
  }
  return resultedMapConfig;
};

/**
 * Creates new map config for specified route function
 * @param {function} routeFunc - have to check source object and return true/false (is current route can be used
 * for mapping)
 * @returns {BfaMapperMapConfig|*} - new mapping config
 */
BfaMapperRouter.prototype.createConfigForRoute = function(routeFunc){
  var newRoute = new BfaMapperRoute(routeFunc, new BfaMapperMapConfigExtended(this.options));
  this.routers.push(newRoute);
  return newRoute.mapConfig;
};

/**
 * Creates default map config
 * @returns {BfaMapperMapConfig|*} - new default mapping config
 */
BfaMapperRouter.prototype.createDefaultConfig = function(){
  this.defaultMapConfig = new BfaMapperMapConfigExtended(this.options);
  return this.defaultMapConfig;
};

/**
 * @classdesc BfaMapper provides flexible mapping functionality
 * @class
 */
function BfaMapper() {
  this.mapRouters = {};
  this.mapTemplates = {};
  this._utils = {
    utils: utils,
    defs: defs,
  };
}

/**
 * Method for adding utility functions, which is providing possibility to use added utilities
 * inside mapFrom functions: this[utilityName]
 * @param {string} utilityName - name of utility property
 * @param {*} utility - object, function, variable
 * @returns {BfaMapper} - instance of current mapper
 */
BfaMapper.prototype.addUtility = function(utilityName, utility){
  if (!this.validateName(utilityName)){
    throw new TypeError("`utilityName` have to be not empty string");
  }
  if (has(this._utils, utilityName)){
    throw new Error("utility with " + utilityName + " already exists");
  }
  this._utils[utilityName] = utility;
  return this;
};

/**
 * Returns already added instance / create new instance of map config class by name
 * @param {string} mapName - name of map config
 * @param {object} options - options
 * @returns {null|BfaMapperMapConfigExtended|*} - returns instance of map config class
 */
BfaMapper.prototype.getOrCreateMap = function(mapName, options){
  if (!this.validateName(mapName)){
    throw new TypeError("mapName must be a not empty string");
  }
  if (this.mapRouters[mapName]){
    return this.mapRouters[mapName].defaultMapConfig;
  }
  var newMapRouter = new BfaMapperRouter(mapName, options);

  this.mapRouters[mapName] = newMapRouter;
  return newMapRouter.createDefaultConfig();
};

/**
 * Checks if map with specified name is exists
 * @param {string} mapName - map name
 * @returns {bool} - true if mapConfig with specified name is exists, false otherwise
 */
BfaMapper.prototype.isExists = function(mapName){
  return has(this.mapRouters, mapName);
};

/**
 * Returns already added instance / create new instance of map router class by name
 * @param {string} routedMapName - name of map router
 * @param {object} options - options
 * @returns {null|BfaMapperMapConfigExtended|*} - returns instance of map router class
 */
BfaMapper.prototype.getOrCreateRouter = function(routedMapName, options){
  if (!this.validateName(routedMapName)){
    throw new TypeError("`routeName` should be not empty string");
  }
  if (has(this.mapRouters, routedMapName)){
    return this.mapRouters[routedMapName];
  }
  var newMapRouter = new BfaMapperRouter(routedMapName, options);
  this.mapRouters[routedMapName] = newMapRouter;
  return newMapRouter;
};

/**
 * Returns already added instance / create new instance of map config class by name (this map config can be reused
 * inside another map config)
 * @param {string} templateName - name of map config
 * @param {object} options - options
 * @returns {null|BfaMapperMapConfigExtended|*} - returns instance of map config class
 */
BfaMapper.prototype.createMapTemplate = function(templateName, options){
  if (!this.validateName(templateName)){
    throw new TypeError("`templateName` should be not empty string");
  }
  if (has(this.mapTemplates[templateName])){
    return this.mapTemplates[templateName];
  }
  var newMapConfig = new BfaMapperMapConfig(options);
  this.mapTemplates[templateName] = newMapConfig;
  return newMapConfig;
};

BfaMapper.prototype.validateName = function (name){
  if (isString(name) === false || name.length <= 0){
    return false;
  }
  return true;
};
/**
 * Maps data from a source to a destination. Uses the map config / router with a name which was specified in arguments
 * @param {string} mapName - name of the map configuration / router
 * @param {object} source - source object
 * @param {object} destination - destination object
 * @returns {object} - returns destination
 */
BfaMapper.prototype.map = function(mapName, source, destination){
  var _this = this;
  if (isUndefined(destination) || destination === null){
    destination = {};
  }
  if (isUndefined(source) || source === null){
    return destination;
  }
  if (!has(this.mapRouters, mapName)){
    return destination;
  }
  var mapConfig = this.mapRouters[mapName].getMapConfig(source, _this._utils);
  if (mapConfig === null){
    return destination;
  }
  var mapToCollection = mapConfig.mapToCollection;
  if (mapToCollection.length > 0) {
    mapToCollection.forEach(function (mapToObj) {
      mapToObj.map(source, destination, _this._utils);
    });
  }
  var templatesToApply = mapConfig.templatesToApply;
  if (templatesToApply.length > 0) {
    templatesToApply.forEach(function (templateName) {
      if (has(_this.mapTemplates, templateName)){
        var templateMapToColl = _this.mapTemplates[templateName].mapToCollection;
        templateMapToColl.forEach(function (mapToObj) {
          mapToObj.map(source, destination, _this._utils);
        });
      }
    });
  }
  return destination;
};
/**
 * Formatters collection
 * @type {{strToLowerCase: BfaMapper.formatters.strToLowerCase,
 * strCutTo255Characters: BfaMapper.formatters.strCutTo255Characters}}
 */
BfaMapper.prototype.formatters = {
  strToLowerCase: function(val){
    return isString(val) ? val.toLowerCase() : val;
  },
  strCutTo255Characters: function(val){
    return isString(val) && val.length > 255 ? val.substr(0, 255) : val;
  },
  strToInt: function(val) {
    try {
      return parseInt(val);
    }
    catch (err) {
      return val;
    }
  },
};


/**
 * Provides functionality for variable/property mapping to an array element
 * @param {string} destinationVarPath - destination array path (for example obj.foo.bar)
 * @param {*} defaultValue - default value
 * @constructor
 */
function BfaMapperMapToArray(destinationVarPath, defaultValue){
  if (isString(destinationVarPath) === false || destinationVarPath.length <= 0){
    throw new TypeError("\"mapTo\" should be a non empty string");
  }
  if (isUndefined(defaultValue)){
    defaultValue = null;
  }
  this.destinationVarPath = destinationVarPath;
  this.mappings = [];
  this.defaultValue = defaultValue;
}

BfaMapperMapToArray.prototype.mappingTypes = {
  sourcePath: 1,
  function: 2,
};

/**
 * Mapping source set up
 * @param {function|string} mapFrom - function (which has to receive source object in arguments and returns a value
 * for mapping) or path to some source object variable
 * @param {array} preFormatters - formatters that are going to be applied on result
 * @returns {BfaMapperMapTo} - this
 */
BfaMapperMapToArray.prototype.mapFrom = function(mapFrom, preFormatters){
  var mapping = {mappingFrom: mapFrom, preFormatters: [], };
  if (isFunction(mapFrom)){
    mapping.mappingType = this.mappingTypes.function;
  }
  else
  if (isString(mapFrom) && mapFrom.length > 0) {
    mapping.mappingType = this.mappingTypes.sourcePath;
  }
  else {
    throw new TypeError("\"mapFrom\" is object of wrong type: " + (typeof mapFrom).toString());
  }
  if (isArray(preFormatters) && every(preFormatters, function(v){
      return v instanceof Function;
    })){
    mapping.preFormatters.push.apply(this.preFormatters, preFormatters);
  }

  this.mappings.push(mapping);
  return this;
};

/**
 * Method which fills destination object with values from source according to configured mappings
 * @param {object} source - source object
 * @param {object} destination - destination object
 * @param {*} currentContext - mapping context
 * @returns {*|null} - returns nothing
 */
BfaMapperMapToArray.prototype.map = function(source, destination, currentContext){
  var _this = this;
  var destField = get(destination, this.destinationVarPath);
  if (!destField){
    destField = [];
  }
  if (!isArray(destField)){
    throw new TypeError("\"Destination\" is an object of wrong type: " + (typeof destField).toString()
      + ". Array is expected");
  }

  this.mappings.forEach(function (mapping) {
    var result = _this.defaultValue;
    if (!isUndefined(mapping.mappingFrom)){
      switch (mapping.mappingType){
        case _this.mappingTypes.function:
          result = mapping.mappingFrom.call(currentContext, source, destination);
          break;
        case _this.mappingTypes.sourcePath:
          result = get(source, mapping.mappingFrom, _this.defaultValue);
          break;
      }
    }
    if (isUndefined(result)){
      result = _this.defaultValue;
    }
    if (mapping.preFormatters.length > 0){
      mapping.preFormatters.forEach(function(formatter){
        result = formatter.call(currentContext, result);
      });
    }
    destField.push(result);
  });

  set(destination, this.destinationVarPath, destField);
};

/**
 * Method for mapping destination configuration
 * @param {string} destinationVarPath - destination of variable/property for mapping
 * @param {*} defaultValue - default value
 * @returns {BfaMapperMapToArray} - instance of BfaMapperMapToArray
 */
BfaMapperMapConfig.prototype.addMapToArray = function (destinationVarPath, defaultValue) {
  var newMapTo = new BfaMapperMapToArray(destinationVarPath, defaultValue);
  this.mapToCollection.push(newMapTo);
  return newMapTo;
};

export default BfaMapper;
