import BFAttributeParser from "./../bf_attribute_parser.js";
const parser = new BFAttributeParser();
const visibilityThreshold = .5;

/**
 * Parses element's data-bfa attribute and converts its value to eventInfo.
 * Sets bfa-impression-tracked attr on the element to prevent double tracking.
 * Sends eventInfo to the impression tracking route.
 * @param {Object} tracker - BFA global.
 * @param {Object} element - The element to track.
 * @returns {Function} - performs action above when executed.
 */
const trackElement = (tracker, element) => {
  const parsed = parser.parse(element);
  const eventInfo = {
    t: "scroll",
    n: parsed.action,
    l: parsed.location,
    d: parsed.description,
    data: parsed.data,
    opt: parsed.options,
  };
  tracker("track/scroll/impression", eventInfo);
};

function BFScrollInviewBinder(options, executable) {
  this.options = options || {};
  this.executable = executable;

  this.init = function () {
    if (!options || !options.locators || !executable || typeof window[executable] !== "function") {
      return;
    }

    this.observedElements = [];
    this.elementQuery = this.options.locators.join(",");
    this.updateTargets();
  };

  this.updateTargets = () => {
    let trackableElements = Array.from(document.querySelectorAll(this.elementQuery));
    let newElements = trackableElements.filter(elem => this.observedElements.indexOf(elem) < 0);
    this.observedElements = trackableElements;

    if (newElements.length) {
      this.observeElements(newElements);
    }
  }

  this.onObserve = (items, observer) => {
    items.forEach(item => {
      if (item.isIntersecting) {
        trackElement(window[this.executable], item.target);
        observer.unobserve(item.target);
      }
    });
  }

  this.observeElements = (elements) => {
    const observer = new IntersectionObserver(this.onObserve, { threshold: visibilityThreshold });
    elements.forEach(elem => observer.observe(elem));
  }
}

export default BFScrollInviewBinder;
