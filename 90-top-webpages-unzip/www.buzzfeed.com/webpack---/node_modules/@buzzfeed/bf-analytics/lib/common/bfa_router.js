import crossroads from "crossroads";
import { isString, slice, startsWith, cloneDeep, isEmpty, isFunction, isObject, has, } from "lodash";

"use strict";

/**
 * BFARouter class. Currently wraps `crossroads` router.
 * @constructor
 */
function BFARouter(){
  // main router initializing
  this._router = crossroads.create();
  this._routes = {};

  // default router"s settings
  this._router.normalizeFn = crossroads.NORM_AS_OBJECT;
  this._router.ignoreState = true;
  // greedy = true - means that all suitable routs will be called not only first one (by default)
  this._router.greedy = true;
  this._routes = [];
}

/**
 * Publishes arguments to route (route value must be passed as the first argument)
 * @param {string} route - route value (for example "/track/page/view")
 * @returns {BFARouter} - this
 */
BFARouter.prototype.pub = function (route){
  if (isString(route)){
    var args = slice(arguments, 1);
    var data;
    // tricky solution, as we support only one `default argument` that connected with crossroads solution
    // so if someone send more than two args (route, and dataObj) we combine them to array
    // if someone send only one route we are sending empty object
    if (args.length === 1){
      data = args[0];
    }
    else if (args.length > 1){
      data = args;
    }
    this._router.parse(route, [data, ]);
  }
  return this;
};

/**
 * Some hacky method/solution (we must clone event info objects before sending them to subscribers)
 * @param {string} route - route pattern
 * @param {function} cb - callback function
 * @param {*} context - context
 * @return {function} - modified callback
 */
BFARouter.prototype.modifySubCB = function(route, cb, context){
  if (startsWith(route, "track/")){
    return function(){
      cb.apply(context, cloneDeep(Array.prototype.slice.call(arguments)));
    };
  }
  return cb;
};

/**
 * Subscribes on route
 * @param {string} route - route value
 * @param {function} cb - callback
 * @param {*} context - context in which callback must be ran
 * @param {object} rules - additional rules
 * @param {boolean} once - subscribes only once true/false
 * @returns {BFARouter} - this
 */
BFARouter.prototype.sub = function (route, cb, context, rules, once) {
  if (!isString(route) || isEmpty(route)){
    this.log.error("`route` must be not empty string");
    return this;
  }
  if (!isFunction(cb)){
    this.log.error("`cb` must be a function");
    return this;
  }
  if (rules && !isObject(rules)){
    this.log.error("`rules` must be an object or not specified");
    return this;
  }
  // has to be discussed
  var modCb = this.modifySubCB(route, cb, context);
  var subTypeName = once ? "addOnce" : "add";
  if (!has(this._routes, route) && !rules){
    this._routes[route] = this._router.addRoute(route);
    this._routes[route].matched[subTypeName](modCb, context);
  }
  else {
    if (rules){
      var tmpRoute = this._router.addRoute(route);
      tmpRoute.rules = rules;
      tmpRoute.matched[subTypeName](modCb, context);
    }
    else {
      this._routes[route].matched[subTypeName](modCb, context);
    }
  }
  return this;
};

/**
 * logger mock
 * @type {{error: BFARouter.log.error, log: BFARouter.log.log, info: BFARouter.log.info,
 * warn: BFARouter.log.warn, enabled: BFARouter.log.enabled}}
 */
BFARouter.prototype.log = {
  error: function() {},
  log: function() {},
  info: function() {},
  warn: function() {},
  enabled: function(){},
};

export default BFARouter;
