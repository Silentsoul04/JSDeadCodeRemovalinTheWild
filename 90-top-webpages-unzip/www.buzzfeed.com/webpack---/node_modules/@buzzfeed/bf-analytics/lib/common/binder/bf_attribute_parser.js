"use strict";
/**
 * Represents attribute parser for BFAnalytics data binder
 * @param {object} config Configuration data for "data-bfa" attribute parser
 * @constructor
 */
function BFAttributeParser(config) {
  this.defaultConfig = {
    start: "@",
    end: ";",
    separator: ":",
    objectPropertySeparator: ",",
    objectStart: "{",
    objectEnd: "}",
    arrayStart: "[",
    arrayEnd: "]",
    parts: {
      action: "a",
      description: "d",
      location: "l",
      data: "e",
      options: "o",
    },
  };

  this.config = config || this.defaultConfig;

  /**
   * Function that begins the cain of parsing process.
   * @param {HtmlElement} element Element which attribute should be parsed.
   * @returns {*} Returns array with "action", "location", "description", "data"
   */
  this.parse = function (element) {
    var result = {};
    var attribute = element.getAttribute("data-bfa");
    if (attribute === null || attribute === "") {
      result = {action: "", location: "", description: "", data: {}, options: {}, };
    }
    else {
      result = this.processAttribute(attribute);
    }
    if (result.location === "") {
      result.location = this.findLocation(element.parentElement);
    }

    result.action = this.grabDataSource(result.action);
    result.location = this.grabDataSource(result.location);
    result.description = this.grabDataSource(result.description);
    return result;
  };

  /**
   * Parse text value of "data-bfa" attribute.
   * @param {string} attribute Attribute"s value that should be parsed.
   * @returns {{action: string, location: string, description: string, data: string}} Returns "action", "location",
   * "description", "data" values in one object
   */
  this.processAttribute = function (attribute) {
    var collector = [];
    for (var part in this.config.parts) {
      if (this.config.parts.hasOwnProperty(part)) {
        var idx = attribute.indexOf(this.config.start + this.config.parts[part] + this.config.separator);
        if (idx > -1) {
          collector.push({part: part, idx: idx, });
        }
      }
    }

    collector = collector.sort(function (a, b) {
      return a.idx < b.idx ? -1 : a.idx === b.idx ? 0 : 1;
    });

    var result = {action: "", location: "", description: "", data: "", options: "", };
    for (var i = 0; i < collector.length; i++) {
      if (i < collector.length - 1) {
        result[collector[i].part] = attribute.substring(collector[i].idx, collector[i + 1].idx);
      }
      else {
        result[collector[i].part] = attribute.substring(collector[i].idx);
      }
    }

    for (var key in result) {
      if (result.hasOwnProperty(key)) {
        result[key] = result[key]
          .replace(this.config.start + this.config.parts[key] + this.config.separator, "")
          .trim();
        if (result[key][result[key].length - 1] === this.config.end) {
          result[key] = result[key].substring(0, result[key].length - 1);
        }
      }
    }

    result.data = this.convertToObject(result.data);
    result.options = this.convertToObject(result.options);
    return result;
  };

  /**
   * Function that searches the element which contains location value.
   * @param {HtmlElement} element Element from which search would be started to the top of DOM tree.
   * @returns {string} Returns location value.
   */
  this.findLocation = function (element) {
    while (element !== null && element.getAttribute) {
      var attr = element.getAttribute("data-bfa");
      if (attr !== null && attr !== "") {
        var result = this.processAttribute(attr);
        if (result.location === "") {
          element = element.parentElement;
          continue;
        }
        return result.location;
      }
      else {
        element = element.parentElement;
      }
    }
    return "";
  };

  this.objectParseMode = {
    propertyName: 1,
    propertyValue: 2,
    propertyArray: 4,
  };

  /**
   * Converts "data" part value to object
   * @param {string} value Text value of "data" part of "data-bfa" attribute
   * @returns {{}} Returns value as an object
   */
  this.convertToObject = function (value) {
    var resultedObj = {};
    value = value.trim().replace("\"", "").replace("'", "");

    if (typeof value !== "string"
      || value.indexOf(this.defaultConfig.objectStart) !== 0
      || value.indexOf(this.defaultConfig.objectEnd) !== value.length - 1){
      return resultedObj;
    }
    var currentPropertyName = "";
    var currentPropertyValue = "";
    var currentArrayValue = "";
    var parseMode = this.objectParseMode.propertyName;
    for (var i = 1; i < value.length - 1; i++) {
      // if separator and mode is property name parsing we should recheck wich kind of prop value are next array or
      // usual value
      if (value[i] === this.defaultConfig.separator
        && parseMode === this.objectParseMode.propertyName){
        if (value[i + 1] && value[i + 1] === this.defaultConfig.arrayStart){
          parseMode = this.objectParseMode.propertyArray;
          i++;
        }
        else {
          parseMode = this.objectParseMode.propertyValue;
        }
        continue;
      }

      switch (parseMode){
        // Array parsing
        case this.objectParseMode.propertyArray:
          if (!currentPropertyValue){
            currentPropertyValue = [];
          }
          // if array end element we should add array to property and reset all vars
          if (value[i] === this.defaultConfig.arrayEnd){
            currentPropertyValue.push(currentArrayValue.trim());
            resultedObj[currentPropertyName.trim()] = currentPropertyValue;
            currentPropertyName = "";
            currentArrayValue = "";
            currentPropertyValue = "";
            parseMode = this.objectParseMode.propertyName;
            break;
          }
          // if separator we should add value to array and reset array value
          if (value[i] === this.defaultConfig.objectPropertySeparator){
            currentPropertyValue.push(currentArrayValue);
            currentArrayValue = "";
            break;
          }
          currentArrayValue += value[i];
          break;
        // property value parsing
        case this.objectParseMode.propertyValue:
          //if separator or last char before obj close symbol we should save value and reset vars
          if (value[i] === this.defaultConfig.objectPropertySeparator || i === value.length - 2) {
            resultedObj[currentPropertyName.trim()] = (currentPropertyValue +
            (value[i] !== this.defaultConfig.objectPropertySeparator ? value[i] : "")).trim();
            currentPropertyName = "";
            currentPropertyValue = "";
            parseMode = this.objectParseMode.propertyName;
          }
          else {
            currentPropertyValue += value[i];
          }
          break;
        // property name parsing
        case this.objectParseMode.propertyName:
          if (value[i] !== this.defaultConfig.objectPropertySeparator){
            currentPropertyName += value[i];
          }
          break;
      }
    }
    return resultedObj;
  };

  /**
   * Function related for invocation of data-source functions.
   * @param {string} value Value of the data-bfa attribute"s part.
   * @returns {string} Result of data-source invokation. If data-source is unavailable than returns plain
   * provided value in argument.
   */
  this.grabDataSource = function (value) {
    if (value.indexOf("source:") > -1) {
      var funcFullName = value.replace("source:", "").trim();
      if (funcFullName && window) {
        var context = window;
        var namespaces = funcFullName.split(".");
        var funcName = namespaces.pop();

        for (var i = 0; i < namespaces.length; i++) {
          context = context[namespaces[i]];
        }
        var func = context[funcName];
        if (func) {
          return func();
        }
      }
    }
    return value;
  };
}

/**
 * Attribute parser module of Buzzfeed analytics event binder.
 */
export default BFAttributeParser;
