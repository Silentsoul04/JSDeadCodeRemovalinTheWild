"use strict";
/**
 * Implements elements scroll binder. Handles the position of the scroll by predefined with
 * configuration HTML elements that were passed. Results are represented as percentage of passed elements
 * that calculated as ratio: passed / expected * 100. This mode is usually used for pages with AJAX loaders.
 * @param {object} options Object with all the configuration parameters such as mode, bounds, etc.
 * @param {string} executable Function that should be invoked with position calculation results
 * if scroll event triggered. Results of calculation represented as BFEventInfo class.
 * @constructor
 */
function ElementsScrollBinder(options, executable) {
  this.options = options || {};
  this.executable = executable;
  this.points = [];

  /**
   * Initialization method. Executes preparation of checkpoints.
   * @returns {Function} Returns handler.
   */
  this.init = function(){
    this.fillCheckPoints();
  };

  /**
   * Handler for the 'onscroll' event. Tracks the position of scroll on the page according to the
   * checkpoints and sends data to the BFA. Results are represented as BFEventInfo.
   * @returns {Function} Returns handler.
   */
  this.track = function () {
    if (!this.options.elementMode.element || !this.options.elementMode.expected) {
      return;
    }

    // 1px added to handle 100% scroll on iphone
    var currentScroll = window.pageYOffset + document.documentElement.clientHeight + 1;
    var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
    var clientTop = document.documentElement.clientTop || document.body.clientTop || 0;
    var elements = document.querySelectorAll(this.options.elementMode.element);

    var passedElementsCount = 0;
    var i;
    for (i = 0; i < elements.length; i++) {
      var elTop = elements[i].getBoundingClientRect().top + scrollTop - clientTop;
      if (elTop <= currentScroll) {
        passedElementsCount++;
      }
    }
    var currentPercentage = passedElementsCount / this.options.elementMode.expected * 100;

    var anchor = null;
    for (i = 0; i < this.options.bottomBounds.length; i++) {
      anchor = document.querySelector(this.options.bottomBounds[i]);
      if (anchor) {
        break;
      }
    }
    if (anchor) {
      var anchorPosition = anchor.getBoundingClientRect().top + scrollTop - clientTop;
      if (currentScroll >= anchorPosition && currentPercentage < 100) {
        currentPercentage = 100;
      }
    }
    // dirty hack [end]

    for (i = 0; i < this.options.checkpoints.length; i++) {
      if (this.points[i].percentage <= currentPercentage && !this.points[i].passed) {
        this.points[i].passed = true;
        var trackingInfo = ["track/scroll/post", { t: "scroll", n: "post",
          d: this.points[i].percentage.toString(), }, ];
        if (this.executable && window[this.executable] instanceof Function) {
          window[this.executable].apply(this, trackingInfo);
        }
      }
    }
  };

  /**
   * Fills the checkpoints for current module and mark them as not passed.
   * @returns {Function} Returns handler.
   */
  this.fillCheckPoints = function () {
    for (var i = 0; i < this.options.checkpoints.length; i++) {
      this.points.push({
        percentage: this.options.checkpoints[i],
        passed: false,
      });
    }
  };
}

export default ElementsScrollBinder;
