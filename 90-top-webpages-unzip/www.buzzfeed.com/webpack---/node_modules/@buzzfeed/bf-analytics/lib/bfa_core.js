import utils from "./common/bfa_utils.js";
import defs from "./common/bfa_defs.js";
import Router from "./common/bfa_router.js";
import Signal from "signals";
import { isString, isPlainObject, isFunction, has, isArray,
          get, isUndefined, keys, after, defer, } from "lodash";


"use strict";

/**
 * BF analytics core class
 * @constructor
 */
function BFACore(){
  this._modules = {};
  this._plugins = {};
  this._instances = {};
  this._router = new Router();

  this.inited = new Signal();
  this.active = new Signal();
  this.crashed = new Signal();

  this._inited = false;
  this._active = false;
  this._crashed = false;

  this.crashed.add(function(){
    this._crashed = true;
    this.log.error("CRASHED");
  }, this, Number.MAX_VALUE);

  // subscribe route init
  this._router.sub("bfa/subscribe/{action}/{eventName}", this._subscribe, this,  {
    action: ["add", "addOnce", "remove", ],
    eventName: function(value){
      return isString(value) && value.length > 0;
    },
  });
  this.inited.add(function(){
    this._inited = true;
  }, this, Number.MAX_VALUE);

  this.active.add(function(){
    this._active = true;
  }, this, Number.MAX_VALUE);

  /**
   * Default SandBox constructor
   * @param {BFACore} core - bfa core instance
   * @param {string} instanceId - module instance identifier
   * @param {object} settings - module settings
   * @param {string} moduleId - module identifier
   * @returns {Sandbox} - this
   * @constructor
   */
  this.Sandbox = function(core, instanceId, settings, moduleId) {
    this.instanceId = instanceId;
    this.moduleInited = new Signal();
    this.moduleActive = new Signal();
    this.fillModuleRoute = function(route){
      return "module/" + instanceId + "/" + route;
    };
    this.subOn = function(pattern, cb, context){
      core._router.sub(pattern, cb, context);
    };
    this.settings = settings || {};
    this.moduleId = moduleId;
    this.utils = core.utils;
    this.defs = core.defs;
    return this;
  };

  this.construct.dispatch(this);
}

/**
 * logger mock
 * @todo Due to the current initialization lifecycle, nothing will be logged until LoggerPlugin is active.
 * This mock is reassigned inside the LoggerPlugin.
 * The core itself doesn't know if the current env enabled logging until generalSettings plugin is active.
 * Logging errors regardless of environment for now.
 * Production errors are reported to sentry anyway.
 * @type {{error: BFACore.log.error, log: BFACore.log.log,
 * info: BFACore.log.info, warn: BFACore.log.warn, enabled: BFACore.log.enabled}}
 */
BFACore.prototype.log = {
  error: function(msg) {
    /* eslint-disable no-console */
    if (window.console) {
      window.console.error("BFA [ BFACore ] " + msg);
    }
    /* eslint-enable no-console */
  },
  log: function() {},
  info: function() {},
  warn: function() {},
  enabled: function(){},
};

/**
 * On construct event
 */
BFACore.prototype.construct = new Signal();
BFACore.prototype.utils = utils;
BFACore.prototype.defs = defs;

/**
 * Handler for bfa/subscribe/{action}/{eventName} route. Checks that all args are valid, checks for the property with
 * the name specified in params.eventName with type of Signal, calls it with args from dataObj
 * @param {object} dataObj - must contains fn property (type of Function) and context property with specified context
 * @param {object} params - params from router
 * @returns {BFACore} - instance of BFCore
 * @private
 */
BFACore.prototype._subscribe = function(dataObj, params){
  if (isPlainObject(dataObj) && isPlainObject(params)
    && this[params.eventName] instanceof Signal
    && isFunction(dataObj.fn)
    && dataObj.context) {
    this[params.eventName][params.action](dataObj.fn, dataObj.context);
  }
  return this;
};

/**
 * Registers module in BFA Core
 * @param {function} module - module constructor
 * @param {object} settings - module settings
 * @param {string} moduleId - module identifier (optional)
 * @returns {BFACore} - this
 */
BFACore.prototype.registerModule = function(module, settings, moduleId){
  // have to be removed when we will support this in the future
  if (this._inited === true){
    this.log.warn("You can't register module after activation");
    return this;
  }
  settings = settings || {};
  var err = this.utils.checkType("function", module, "module") ||
    this.utils.checkType("object", settings, "settings");
  if (err){
    throw new TypeError(err);
  }
  if (!isString(moduleId) && isString(module.defaultId)){
    moduleId = module.defaultId;
  }
  if (!isString(moduleId) || moduleId.length === 0){
    throw new TypeError("moduleId has to be specified (as third argument or as `id` property of module)" +
      " and must be not empty string");
  }
  if (has(this._modules, moduleId)){
    this.log.warn("module " + moduleId + " was already registered");
    return this;
  }
  this.push("module/" + moduleId + "/added");
  this._modules[moduleId] = {
    Creator: module,
    settings: settings,
    id: moduleId,
  };
  return this;
};

/**
 * Registers plugin in BFA Core
 * @param {function} Plugin - plugin constructor
 * @param {object} settings - settings
 * @param {string} pluginId - plugin identifier (optional)
 * @returns {BFACore} - this
 */
BFACore.prototype.plugin = function(Plugin, settings, pluginId){
  // have to be removed when we will support this in the future
  if (this._inited === true){
    this.log.warn("You can't add plugins after activation");
    return this;
  }
  settings = settings || {};
  var err = this.utils.checkType("function", Plugin, "plugin") ||
    this.utils.checkType("object", settings, "settings");
  if (err){
    throw new TypeError(err);
  }
  if (!isString(pluginId) && isString(Plugin.defaultId)){
    pluginId = Plugin.defaultId;
  }
  if (!isString(pluginId) || pluginId.length === 0){
    throw new TypeError("pluginId has to be specified (as third argument or as `id` property of plugin)" +
      " and must be not empty string");
  }
  if (has(this._plugins, pluginId)){
    this.log.warn("plugin " + pluginId + " was already registered");
    return this;
  }

  this._plugins[pluginId] = {
    Creator: Plugin,
    instance: null,
    settings: settings,
    id: pluginId,
  };
  return this;
};

/**
 * Activates added plugins
 * @return {Void} - void
 */
BFACore.prototype.activatePlugins = function(){
  if (this._crashed === true){
    this.log.error("Plugins activation interrupted");
    return;
  }
  // activation started
  // Plugins dependencies resolving functionality based on topological sorting
  var sortedPluginIds  = [];
  var visitedPlugins = {};
  var _this = this;
  function visitPlugin(name, ancestors) {
    if (!isArray(ancestors)){
      ancestors = [];
    }
    ancestors.push(name);
    visitedPlugins[name] = true;
    get(_this._plugins[name], "Creator.require", []).forEach(function(dep) {
      if (isUndefined(_this._plugins[dep])) {
        throw new Error("Can't resolve \"" + dep + "\" for \"" + name + "\" plugin");
      }
      if (ancestors.indexOf(dep) >= 0){
        throw new Error("Circular dependency \"" +  dep + "\" is required by \"" + name + "\" plugin: "
          + ancestors.join(" -> "));
      }
      if (visitedPlugins[dep]) return;
      visitPlugin(dep, ancestors.slice(0)); // recursive call
    },_this);
    if (sortedPluginIds.indexOf(name) < 0){
      sortedPluginIds.push(name);
    }
  }
  try {
    // ordering plugins ids by dependencies
    this.utils.forOwn(this._plugins, function(plugin){
      visitPlugin(plugin.id);
    }, this);

    // plugins init process
    for (var i = 0; i < sortedPluginIds.length; i++){
      var pluginId = sortedPluginIds[i];
      if (this._plugins[pluginId].instance === null){
        this._plugins[pluginId].instance = new this._plugins[pluginId]
          .Creator(this, this._plugins[pluginId].settings);
        this.push("plugin/" + pluginId + "/added");
      }
      else {
        this.log.warn("Plugin " + pluginId + " already added and activated");
      }
    }
  }
  catch (err){
    // report the crashed plugin to sentry.io
    if (typeof window.BZFD !== "undefined" &&
      (window.BZFD.Config.env === "live" ||
      window.BZFD.Config.env === "prod") &&
      window.raven) {
      raven.captureException(err);
    }

    this.log.error(err);
    this.log.error("Plugins activation interrupted");
    this.crashed.dispatch();
    return;
  }
}

/**
 * Activates BFA Core (initializes modules and sandboxes). Runs activatePlugins for plugins activation as well.
 * @return {Void} - void
 */
BFACore.prototype.activate = function(){
  if (this._inited === true){
    this.log.warn("Already initialized");
    return;
  }
  this.activatePlugins();
  if (this._crashed === true){
    this.log.error("Activation interrupted");
    return;
  }
  var _this = this;

  this.utils.forOwn(this._modules, function(moduleContainer){
    var instanceId = moduleContainer.Creator.defaultId;
    var err = false;
    if (isString(moduleContainer.settings.instanceId)){
      instanceId = moduleContainer.settings.instanceId;
    }
    // module's sandbox init process
    var sandboxInst = new this.Sandbox(this, instanceId, moduleContainer.settings, moduleContainer.Creator.defaultId);
    if (isArray(moduleContainer.Creator.require) && moduleContainer.Creator.require.length > 0) {
      // required plugins functionality injection
      for (var index = 0; index < moduleContainer.Creator.require.length; index++){
        var pluginName = moduleContainer.Creator.require[index];
        if (has(this._plugins, pluginName)
          && has(this._plugins[pluginName].instance, "modifySBInstance")){
          this._plugins[pluginName].instance.modifySBInstance(sandboxInst);
        }
        else {
          err = "Module " + moduleContainer.Creator.defaultId + " require plugin " + pluginName;
          break;
        }
      }
    }
    if (!err){
      var moduleInstance = new moduleContainer.Creator(sandboxInst);
      if (has(moduleInstance, "init")){
        this._instances[instanceId] = {
          module: moduleInstance,
          sandbox: sandboxInst,
        };
        this.push("module/" + instanceId + "/added");
      }
      else {
        err = "Constructor of module " + module.defaultId + " returned not valid object";
      }
    }
    if (err){
      this.log.error(err);
      this.log.error("Instance " + instanceId + " of module " + module.defaultId + " is not added properly");
    }
  }, this);

  var instancesLength = keys(this._instances).length;
  var initCallback = after(instancesLength, function () {
    _this.inited.dispatch(_this);
  });
  var activeCallback = after(instancesLength, function () {
    _this.active.dispatch(_this);
  });

  // init process
  this.utils.forOwn(this._instances, function(instance){
    instance.sandbox.moduleInited.addOnce(initCallback);
    instance.sandbox.moduleActive.addOnce(activeCallback);
    defer(instance.module.init);
  }, this);
};

/**
 * Method for events pushing
 * @returns {Void} - void
 */
BFACore.prototype.push = function(){
  this._router.pub.apply(this._router, arguments);
};

export default BFACore;
